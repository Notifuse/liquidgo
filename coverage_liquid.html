
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>liquid: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Notifuse/liquidgo/liquid/block.go (92.5%)</option>
				
				<option value="file1">github.com/Notifuse/liquidgo/liquid/block_body.go (86.0%)</option>
				
				<option value="file2">github.com/Notifuse/liquidgo/liquid/condition.go (94.9%)</option>
				
				<option value="file3">github.com/Notifuse/liquidgo/liquid/context.go (92.7%)</option>
				
				<option value="file4">github.com/Notifuse/liquidgo/liquid/deprecations.go (94.4%)</option>
				
				<option value="file5">github.com/Notifuse/liquidgo/liquid/document.go (86.4%)</option>
				
				<option value="file6">github.com/Notifuse/liquidgo/liquid/drop.go (73.6%)</option>
				
				<option value="file7">github.com/Notifuse/liquidgo/liquid/environment.go (93.2%)</option>
				
				<option value="file8">github.com/Notifuse/liquidgo/liquid/errors.go (97.1%)</option>
				
				<option value="file9">github.com/Notifuse/liquidgo/liquid/expression.go (94.7%)</option>
				
				<option value="file10">github.com/Notifuse/liquidgo/liquid/extensions.go (100.0%)</option>
				
				<option value="file11">github.com/Notifuse/liquidgo/liquid/file_system.go (86.7%)</option>
				
				<option value="file12">github.com/Notifuse/liquidgo/liquid/forloop_drop.go (100.0%)</option>
				
				<option value="file13">github.com/Notifuse/liquidgo/liquid/i18n.go (84.2%)</option>
				
				<option value="file14">github.com/Notifuse/liquidgo/liquid/interrupts.go (100.0%)</option>
				
				<option value="file15">github.com/Notifuse/liquidgo/liquid/lexer.go (87.8%)</option>
				
				<option value="file16">github.com/Notifuse/liquidgo/liquid/parse_context.go (98.6%)</option>
				
				<option value="file17">github.com/Notifuse/liquidgo/liquid/parse_tree_visitor.go (97.7%)</option>
				
				<option value="file18">github.com/Notifuse/liquidgo/liquid/parser.go (87.2%)</option>
				
				<option value="file19">github.com/Notifuse/liquidgo/liquid/parser_switching.go (93.6%)</option>
				
				<option value="file20">github.com/Notifuse/liquidgo/liquid/partial_cache.go (78.0%)</option>
				
				<option value="file21">github.com/Notifuse/liquidgo/liquid/profiler.go (91.8%)</option>
				
				<option value="file22">github.com/Notifuse/liquidgo/liquid/range_lookup.go (79.2%)</option>
				
				<option value="file23">github.com/Notifuse/liquidgo/liquid/registers.go (95.5%)</option>
				
				<option value="file24">github.com/Notifuse/liquidgo/liquid/resource_limits.go (100.0%)</option>
				
				<option value="file25">github.com/Notifuse/liquidgo/liquid/snippet_drop.go (100.0%)</option>
				
				<option value="file26">github.com/Notifuse/liquidgo/liquid/standardfilters.go (99.2%)</option>
				
				<option value="file27">github.com/Notifuse/liquidgo/liquid/strainer_template.go (82.5%)</option>
				
				<option value="file28">github.com/Notifuse/liquidgo/liquid/string_scanner.go (83.1%)</option>
				
				<option value="file29">github.com/Notifuse/liquidgo/liquid/tablerowloop_drop.go (100.0%)</option>
				
				<option value="file30">github.com/Notifuse/liquidgo/liquid/tag.go (91.3%)</option>
				
				<option value="file31">github.com/Notifuse/liquidgo/liquid/tag/disableable.go (91.3%)</option>
				
				<option value="file32">github.com/Notifuse/liquidgo/liquid/tag/disabler.go (100.0%)</option>
				
				<option value="file33">github.com/Notifuse/liquidgo/liquid/tags/assign.go (93.5%)</option>
				
				<option value="file34">github.com/Notifuse/liquidgo/liquid/tags/break.go (100.0%)</option>
				
				<option value="file35">github.com/Notifuse/liquidgo/liquid/tags/capture.go (96.2%)</option>
				
				<option value="file36">github.com/Notifuse/liquidgo/liquid/tags/case.go (92.6%)</option>
				
				<option value="file37">github.com/Notifuse/liquidgo/liquid/tags/comment.go (92.2%)</option>
				
				<option value="file38">github.com/Notifuse/liquidgo/liquid/tags/continue.go (100.0%)</option>
				
				<option value="file39">github.com/Notifuse/liquidgo/liquid/tags/cycle.go (86.1%)</option>
				
				<option value="file40">github.com/Notifuse/liquidgo/liquid/tags/decrement.go (83.3%)</option>
				
				<option value="file41">github.com/Notifuse/liquidgo/liquid/tags/doc.go (88.1%)</option>
				
				<option value="file42">github.com/Notifuse/liquidgo/liquid/tags/echo.go (100.0%)</option>
				
				<option value="file43">github.com/Notifuse/liquidgo/liquid/tags/for.go (96.8%)</option>
				
				<option value="file44">github.com/Notifuse/liquidgo/liquid/tags/if.go (90.3%)</option>
				
				<option value="file45">github.com/Notifuse/liquidgo/liquid/tags/ifchanged.go (100.0%)</option>
				
				<option value="file46">github.com/Notifuse/liquidgo/liquid/tags/include.go (88.2%)</option>
				
				<option value="file47">github.com/Notifuse/liquidgo/liquid/tags/increment.go (82.4%)</option>
				
				<option value="file48">github.com/Notifuse/liquidgo/liquid/tags/inline_comment.go (88.9%)</option>
				
				<option value="file49">github.com/Notifuse/liquidgo/liquid/tags/raw.go (89.7%)</option>
				
				<option value="file50">github.com/Notifuse/liquidgo/liquid/tags/registry.go (94.7%)</option>
				
				<option value="file51">github.com/Notifuse/liquidgo/liquid/tags/render.go (80.0%)</option>
				
				<option value="file52">github.com/Notifuse/liquidgo/liquid/tags/snippet.go (100.0%)</option>
				
				<option value="file53">github.com/Notifuse/liquidgo/liquid/tags/table_row.go (80.7%)</option>
				
				<option value="file54">github.com/Notifuse/liquidgo/liquid/tags/unless.go (83.3%)</option>
				
				<option value="file55">github.com/Notifuse/liquidgo/liquid/template.go (90.4%)</option>
				
				<option value="file56">github.com/Notifuse/liquidgo/liquid/template_factory.go (100.0%)</option>
				
				<option value="file57">github.com/Notifuse/liquidgo/liquid/tokenizer.go (84.6%)</option>
				
				<option value="file58">github.com/Notifuse/liquidgo/liquid/usage.go (100.0%)</option>
				
				<option value="file59">github.com/Notifuse/liquidgo/liquid/utils.go (94.6%)</option>
				
				<option value="file60">github.com/Notifuse/liquidgo/liquid/variable.go (87.5%)</option>
				
				<option value="file61">github.com/Notifuse/liquidgo/liquid/variable_lookup.go (81.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package liquid

import (
        "fmt"
        "reflect"
)

const (
        blockMaxDepth = 100
)

// Block represents a block tag (tag with a body).
type Block struct {
        *Tag
        body           *BlockBody
        blockDelimiter string
        blank          bool
}

// NewBlock creates a new block tag.
func NewBlock(tagName, markup string, parseContext ParseContextInterface) *Block <span class="cov10" title="17">{
        return &amp;Block{
                Tag:            NewTag(tagName, markup, parseContext),
                blank:          true,
                blockDelimiter: "end" + tagName,
        }
}</span>

// ParseBlock parses a block tag from tokenizer.
func ParseBlock(tagName, markup string, tokenizer *Tokenizer, parseContext ParseContextInterface) (*Block, error) <span class="cov1" title="1">{
        block := NewBlock(tagName, markup, parseContext)
        err := block.Parse(tokenizer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return block, nil</span>
}

// Parse parses the block body.
func (b *Block) Parse(tokenizer *Tokenizer) error <span class="cov5" title="4">{
        b.body = b.newBody()

        for </span><span class="cov6" title="6">{
                shouldContinue, err := b.parseBody(tokenizer)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="6">if !shouldContinue </span><span class="cov5" title="4">{
                        break</span>
                }
        }

        <span class="cov5" title="4">return nil</span>
}

// Render renders the block body.
func (b *Block) Render(context TagContext) string <span class="cov5" title="4">{
        if b.body == nil </span><span class="cov3" title="2">{
                return ""
        }</span>
        <span class="cov3" title="2">return b.body.Render(context)</span>
}

// RenderToOutputBuffer renders the block body to the output buffer.
// If the block has a custom Render method that returns a non-empty string,
// it uses that instead of rendering the body (for backwards compatibility).
// This matches Ruby's behavior where Block#render_to_output_buffer calls render
// if it's been overridden, otherwise renders the body.
func (b *Block) RenderToOutputBuffer(context TagContext, output *string) <span class="cov3" title="2">{
        // Use Tag.RenderToOutputBuffer which calls Render and checks if it returns non-empty
        // Tag.RenderToOutputBuffer calls t.Render(context). If t is *TestBlockTag,
        // it will call TestBlockTag.Render, not Block.Render, because Go's method resolution
        // finds the most specific method.
        //
        // But when Block.RenderToOutputBuffer is called, b is *Block, so calling b.Render
        // will call Block.Render. We need to call Render on the actual type.
        //
        // Solution: Use reflection to get the actual type and call its Render method.
        // The actual type might be *TestBlockTag, which has its own Render method.
        v := reflect.ValueOf(b)
        if v.Kind() == reflect.Ptr </span><span class="cov3" title="2">{
                // Check if this type has a Render method (it should, since Block has one)
                // MethodByName will find the most specific Render method for the actual type
                renderMethod := v.MethodByName("Render")
                if renderMethod.IsValid() </span><span class="cov3" title="2">{
                        // Call Render - this will call the most specific Render method for the actual type
                        results := renderMethod.Call([]reflect.Value{reflect.ValueOf(context)})
                        if len(results) &gt; 0 </span><span class="cov3" title="2">{
                                renderResult := results[0].String()
                                // Get what body would render for comparison
                                bodyResult := ""
                                if b.body != nil </span><span class="cov1" title="1">{
                                        bodyResult = b.body.Render(context)
                                }</span>
                                // If Render returns something different from body, it's been overridden
                                <span class="cov3" title="2">if renderResult != bodyResult </span><span class="cov0" title="0">{
                                        *output += renderResult
                                        return
                                }</span>
                        }
                }
        }

        // No override detected or Render returns same as body, render body
        <span class="cov3" title="2">if b.body == nil </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov1" title="1">b.body.RenderToOutputBuffer(context, output)</span>
}

// Blank returns true if the block is blank.
func (b *Block) Blank() bool <span class="cov1" title="1">{
        return b.blank
}</span>

// Nodelist returns the nodelist from the body.
func (b *Block) Nodelist() []interface{} <span class="cov3" title="2">{
        if b.body == nil </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>
        <span class="cov1" title="1">return b.body.Nodelist()</span>
}

// BlockName returns the block name.
func (b *Block) BlockName() string <span class="cov7" title="8">{
        return b.TagName()
}</span>

// BlockDelimiter returns the block delimiter (e.g., "endif" for "if").
func (b *Block) BlockDelimiter() string <span class="cov7" title="8">{
        return b.blockDelimiter
}</span>

// SetBlockDelimiter sets the block delimiter.
func (b *Block) SetBlockDelimiter(delimiter string) <span class="cov1" title="1">{
        b.blockDelimiter = delimiter
}</span>

// UnknownTag handles unknown tags encountered during parsing.
func (b *Block) UnknownTag(tagName, markup string, tokenizer *Tokenizer) error <span class="cov6" title="5">{
        return RaiseUnknownTag(tagName, b.BlockName(), b.BlockDelimiter(), b.ParseContext())
}</span>

// RaiseUnknownTag raises an error for an unknown tag.
func RaiseUnknownTag(tag, blockName, blockDelimiter string, parseContext ParseContextInterface) error <span class="cov7" title="8">{
        var locale *I18n
        if pc, ok := parseContext.(*ParseContext); ok </span><span class="cov3" title="2">{
                locale = pc.Locale()
        }</span> else<span class="cov6" title="6"> {
                // Use default locale path
                locale = NewI18n(DefaultLocalePath)
        }</span>

        <span class="cov7" title="8">if tag == "else" </span><span class="cov3" title="2">{
                msg := locale.Translate("errors.syntax.unexpected_else", map[string]interface{}{
                        "block_name": blockName,
                })
                // If translation failed (returns key), use fallback
                if msg == "errors.syntax.unexpected_else" </span><span class="cov3" title="2">{
                        msg = fmt.Sprintf("%s tag does not expect 'else' tag", blockName)
                }</span>
                <span class="cov3" title="2">return NewSyntaxError(msg)</span>
        } else<span class="cov6" title="6"> if len(tag) &gt;= 3 &amp;&amp; tag[:3] == "end" </span><span class="cov3" title="2">{
                msg := locale.Translate("errors.syntax.invalid_delimiter", map[string]interface{}{
                        "tag":             tag,
                        "block_name":      blockName,
                        "block_delimiter": blockDelimiter,
                })
                // If translation failed (returns key), use fallback
                if msg == "errors.syntax.invalid_delimiter" </span><span class="cov3" title="2">{
                        msg = fmt.Sprintf("'%s' is not a valid delimiter for %s tags. use %s", tag, blockName, blockDelimiter)
                }</span>
                <span class="cov3" title="2">return NewSyntaxError(msg)</span>
        } else<span class="cov5" title="4"> {
                msg := locale.Translate("errors.syntax.unknown_tag", map[string]interface{}{
                        "tag": tag,
                })
                // If translation failed (returns key), use fallback
                if msg == "errors.syntax.unknown_tag" </span><span class="cov5" title="4">{
                        msg = fmt.Sprintf("Unknown tag '%s'", tag)
                }</span>
                <span class="cov5" title="4">return NewSyntaxError(msg)</span>
        }
}

// RaiseTagNeverClosed raises an error for a tag that was never closed.
func (b *Block) RaiseTagNeverClosed() error <span class="cov1" title="1">{
        return NewSyntaxError("tag " + b.BlockName() + " was never closed")
}</span>

func (b *Block) newBody() *BlockBody <span class="cov5" title="4">{
        return NewBlockBody()
}</span>

func (b *Block) parseBody(tokenizer *Tokenizer) (bool, error) <span class="cov7" title="8">{
        parseContext := b.ParseContext()

        // Check depth
        if parseContext.Depth() &gt;= blockMaxDepth </span><span class="cov1" title="1">{
                return false, NewStackLevelError("Nesting too deep")
        }</span>

        <span class="cov7" title="7">parseContext.IncrementDepth()
        defer parseContext.DecrementDepth()

        foundEndTag := false
        unknownTagHandler := func(endTagName, endTagMarkup string) bool </span><span class="cov7" title="7">{
                b.blank = b.blank &amp;&amp; b.body.Blank()

                if endTagName == b.blockDelimiter </span><span class="cov6" title="5">{
                        foundEndTag = true
                        return false // Stop parsing
                }</span>

                <span class="cov3" title="2">if endTagName == "" </span><span class="cov0" title="0">{
                        // Tag never closed
                        return false
                }</span>

                // Unknown tag - let block handle it
                <span class="cov3" title="2">err := b.UnknownTag(endTagName, endTagMarkup, tokenizer)
                return err == nil</span>
        }

        <span class="cov7" title="7">err := b.body.Parse(tokenizer, parseContext, unknownTagHandler)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // If we found the end tag, stop parsing (return false)
        // Otherwise, continue parsing (return true)
        <span class="cov7" title="7">return !foundEndTag, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package liquid

import (
        "reflect"
        "regexp"
        "strings"
)

var (
        blockBodyLiquidTagToken      = regexp.MustCompile(`^\s*(` + TagName.String() + `)\s*(.*?)$`)
        blockBodyFullToken           = regexp.MustCompile(`^` + TagStart.String() + `-?(\s*)(` + TagName.String() + `)(\s*)(.*?)-?` + TagEnd.String() + `$`)
        blockBodyWhitespaceOrNothing = regexp.MustCompile(`^\s*$`)
)

const (
        blockBodyTAGSTART = "{%"
        blockBodyVARSTART = "{{"
)

// BlockBody represents a block body containing nodes (tags, variables, text).
type BlockBody struct {
        nodelist []interface{}
        blank    bool
}

// NewBlockBody creates a new BlockBody.
func NewBlockBody() *BlockBody <span class="cov9" title="87">{
        return &amp;BlockBody{
                nodelist: make([]interface{}, 0, 64), // Pre-allocate for typical template size
                blank:    true,
        }
}</span>

// Nodelist returns the nodelist.
func (bb *BlockBody) Nodelist() []interface{} <span class="cov6" title="16">{
        return bb.nodelist
}</span>

// Parse parses tokens into the block body.
func (bb *BlockBody) Parse(tokenizer *Tokenizer, parseContext ParseContextInterface, unknownTagHandler func(string, string) bool) error <span class="cov8" title="51">{
        parseContext.SetLineNumber(tokenizer.LineNumber())

        if tokenizer.ForLiquidTag() </span><span class="cov0" title="0">{
                return bb.parseForLiquidTag(tokenizer, parseContext, unknownTagHandler)
        }</span>
        <span class="cov8" title="51">return bb.parseForDocument(tokenizer, parseContext, unknownTagHandler)</span>
}

func (bb *BlockBody) parseForLiquidTag(tokenizer *Tokenizer, parseContext ParseContextInterface, unknownTagHandler func(string, string) bool) error <span class="cov6" title="14">{
        for </span><span class="cov7" title="25">{
                token := tokenizer.Shift()
                if token == "" </span><span class="cov5" title="12">{
                        break</span>
                }

                <span class="cov5" title="13">if token == "" || blockBodyWhitespaceOrNothing.MatchString(token) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="13">matches := blockBodyLiquidTagToken.FindStringSubmatch(token)
                if len(matches) == 0 </span><span class="cov0" title="0">{
                        // Line didn't match tag syntax, yield to handler
                        if !unknownTagHandler(token, token) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov5" title="13">tagName := matches[1]
                markup := matches[2]

                if tagName == "liquid" </span><span class="cov1" title="1">{
                        // Handle liquid tag specially
                        // Decrement line number before parsing (Ruby does this)
                        if parseContext.LineNumber() != nil </span><span class="cov1" title="1">{
                                lineNum := *parseContext.LineNumber() - 1
                                parseContext.SetLineNumber(&amp;lineNum)
                        }</span>
                        <span class="cov1" title="1">bb.parseLiquidTag(markup, parseContext)
                        continue</span>
                }

                // Get tag class from environment
                <span class="cov5" title="12">env := parseContext.Environment()
                if env == nil </span><span class="cov0" title="0">{
                        if !unknownTagHandler(tagName, markup) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov5" title="12">tagClass := env.TagForName(tagName)
                if tagClass == nil </span><span class="cov3" title="3">{
                        if !unknownTagHandler(tagName, markup) </span><span class="cov1" title="1">{
                                return nil
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                // Create tag using constructor if available
                // TagConstructor is defined in tags package, so we use reflection to call it
                <span class="cov5" title="9">var tag interface{}

                // Try to call tagClass as a function using reflection
                tagClassValue := reflect.ValueOf(tagClass)
                if tagClassValue.Kind() == reflect.Func </span><span class="cov5" title="9">{
                        // Check if it matches the TagConstructor signature: func(string, string, ParseContextInterface) (interface{}, error)
                        tagClassType := tagClassValue.Type()
                        if tagClassType.NumIn() == 3 &amp;&amp; tagClassType.NumOut() == 2 </span><span class="cov5" title="9">{
                                // Call the constructor function
                                args := []reflect.Value{
                                        reflect.ValueOf(tagName),
                                        reflect.ValueOf(markup),
                                        reflect.ValueOf(parseContext),
                                }
                                results := tagClassValue.Call(args)
                                if len(results) == 2 </span><span class="cov5" title="9">{
                                        // Check for error
                                        if !results[1].IsNil() </span><span class="cov0" title="0">{
                                                if err, ok := results[1].Interface().(error); ok </span><span class="cov0" title="0">{
                                                        panic(err)</span>
                                                }
                                        }
                                        <span class="cov5" title="9">tag = results[0].Interface()</span>
                                }
                        }
                }

                // If tag is still nil, fallback to generic tag
                <span class="cov5" title="9">if tag == nil </span><span class="cov0" title="0">{
                        tag = NewTag(tagName, markup, parseContext)
                }</span>

                // Parse the tag if it has a Parse method
                <span class="cov5" title="9">if parseable, ok := tag.(interface{ Parse(*Tokenizer) error }); ok </span><span class="cov5" title="9">{
                        err := parseable.Parse(tokenizer)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Check if blank
                <span class="cov5" title="9">if blankable, ok := tag.(interface{ Blank() bool }); ok </span><span class="cov5" title="9">{
                        bb.blank = bb.blank &amp;&amp; blankable.Blank()
                }</span>

                <span class="cov5" title="9">bb.nodelist = append(bb.nodelist, tag)
                parseContext.SetLineNumber(tokenizer.LineNumber())</span>
        }

        <span class="cov5" title="12">unknownTagHandler("", "")
        return nil</span>
}

func (bb *BlockBody) parseForDocument(tokenizer *Tokenizer, parseContext ParseContextInterface, unknownTagHandler func(string, string) bool) error <span class="cov8" title="57">{
        for </span><span class="cov10" title="113">{
                token := tokenizer.Shift()
                if token == "" </span><span class="cov8" title="42">{
                        break</span>
                }

                <span class="cov9" title="71">if token == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov9" title="71">if strings.HasPrefix(token, blockBodyTAGSTART) </span><span class="cov6" title="23">{
                        bb.whitespaceHandler(token, parseContext)
                        matches := blockBodyFullToken.FindStringSubmatch(token)
                        if len(matches) == 0 </span><span class="cov0" title="0">{
                                // Invalid tag token
                                if !unknownTagHandler(token, token) </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov6" title="23">tagName := matches[2]
                        markup := matches[4]

                        if tagName == "liquid" </span><span class="cov3" title="3">{
                                // Handle liquid tag specially
                                bb.parseLiquidTag(markup, parseContext)
                                continue</span>
                        }

                        // Get tag class from environment
                        <span class="cov6" title="20">env := parseContext.Environment()
                        if env == nil </span><span class="cov0" title="0">{
                                if !unknownTagHandler(tagName, markup) </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov6" title="20">tagClass := env.TagForName(tagName)
                        if tagClass == nil </span><span class="cov6" title="16">{
                                if !unknownTagHandler(tagName, markup) </span><span class="cov4" title="8">{
                                        return nil
                                }</span>
                                <span class="cov2" title="2">continue</span>
                        }

                        // Create tag using constructor if available
                        // TagConstructor is defined in tags package, so we use reflection to call it
                        <span class="cov3" title="4">var tag interface{}

                        // Try to call tagClass as a function using reflection
                        tagClassValue := reflect.ValueOf(tagClass)
                        if tagClassValue.Kind() == reflect.Func </span><span class="cov3" title="3">{
                                // Check if it matches the TagConstructor signature: func(string, string, ParseContextInterface) (interface{}, error)
                                tagClassType := tagClassValue.Type()
                                if tagClassType.NumIn() == 3 &amp;&amp; tagClassType.NumOut() == 2 </span><span class="cov3" title="3">{
                                        // Call the constructor function
                                        args := []reflect.Value{
                                                reflect.ValueOf(tagName),
                                                reflect.ValueOf(markup),
                                                reflect.ValueOf(parseContext),
                                        }
                                        results := tagClassValue.Call(args)
                                        if len(results) == 2 </span><span class="cov3" title="3">{
                                                // Check for error
                                                if !results[1].IsNil() </span><span class="cov1" title="1">{
                                                        if err, ok := results[1].Interface().(error); ok </span><span class="cov1" title="1">{
                                                                panic(err)</span>
                                                        }
                                                }
                                                <span class="cov2" title="2">tag = results[0].Interface()</span>
                                        }
                                }
                        }

                        // If tag is still nil, fallback to generic tag
                        <span class="cov3" title="3">if tag == nil </span><span class="cov1" title="1">{
                                tag = NewTag(tagName, markup, parseContext)
                        }</span>

                        // Parse the tag if it has a Parse method
                        <span class="cov3" title="3">if parseable, ok := tag.(interface{ Parse(*Tokenizer) error }); ok </span><span class="cov3" title="3">{
                                err := parseable.Parse(tokenizer)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        // Check if blank
                        <span class="cov3" title="3">if blankable, ok := tag.(interface{ Blank() bool }); ok </span><span class="cov3" title="3">{
                                bb.blank = bb.blank &amp;&amp; blankable.Blank()
                        }</span>

                        <span class="cov3" title="3">bb.nodelist = append(bb.nodelist, tag)</span>
                } else<span class="cov8" title="48"> if strings.HasPrefix(token, blockBodyVARSTART) </span><span class="cov6" title="22">{
                        bb.whitespaceHandler(token, parseContext)
                        variable := bb.createVariable(token, parseContext)
                        bb.nodelist = append(bb.nodelist, variable)
                        bb.blank = false
                }</span> else<span class="cov7" title="26"> {
                        if parseContext.TrimWhitespace() </span><span class="cov2" title="2">{
                                token = strings.TrimLeft(token, " \t\n\r")
                        }</span>
                        <span class="cov7" title="26">parseContext.SetTrimWhitespace(false)
                        bb.nodelist = append(bb.nodelist, token)
                        bb.blank = bb.blank &amp;&amp; blockBodyWhitespaceOrNothing.MatchString(token)</span>
                }
                <span class="cov8" title="51">parseContext.SetLineNumber(tokenizer.LineNumber())</span>
        }

        <span class="cov8" title="42">unknownTagHandler("", "")
        return nil</span>
}

func (bb *BlockBody) whitespaceHandler(token string, parseContext ParseContextInterface) <span class="cov8" title="47">{
        if len(token) &gt; 2 &amp;&amp; token[2] == '-' </span><span class="cov1" title="1">{
                // Trim whitespace from previous token
                if len(bb.nodelist) &gt; 0 </span><span class="cov1" title="1">{
                        if prevToken, ok := bb.nodelist[len(bb.nodelist)-1].(string); ok </span><span class="cov1" title="1">{
                                bb.nodelist[len(bb.nodelist)-1] = strings.TrimRight(prevToken, " \t\n\r")
                        }</span>
                }
        }
        <span class="cov8" title="47">if len(token) &gt;= 3 &amp;&amp; token[len(token)-3] == '-' </span><span class="cov1" title="1">{
                parseContext.SetTrimWhitespace(true)
        }</span>
}

func (bb *BlockBody) createVariable(token string, parseContext ParseContextInterface) *Variable <span class="cov7" title="26">{
        if strings.HasSuffix(token, "}}") </span><span class="cov7" title="24">{
                // Extract markup from {{ markup }}
                start := 2
                if len(token) &gt; 2 &amp;&amp; token[start] == '-' </span><span class="cov1" title="1">{
                        start = 3
                }</span>
                <span class="cov7" title="24">end := len(token) - 3
                if len(token) &gt; 3 &amp;&amp; token[end] == '-' </span><span class="cov1" title="1">{
                        end--
                }</span>
                <span class="cov7" title="24">markupEnd := end - start + 1
                if markupEnd &lt;= 0 </span><span class="cov0" title="0">{
                        markupEnd = 0
                }</span>
                <span class="cov7" title="24">markup := ""
                if markupEnd &gt; 0 </span><span class="cov7" title="24">{
                        markup = token[start : start+markupEnd]
                }</span>
                <span class="cov7" title="24">return NewVariable(markup, parseContext)</span>
        }

        // Missing variable terminator - raise error
        <span class="cov2" title="2">raiseMissingVariableTerminator(token, parseContext)
        return nil</span> // Will never be reached, but needed for type checking
}

// Blank returns true if the block body is blank.
func (bb *BlockBody) Blank() bool <span class="cov4" title="7">{
        return bb.blank
}</span>

// Render renders the block body.
func (bb *BlockBody) Render(context TagContext) string <span class="cov3" title="4">{
        output := ""
        bb.RenderToOutputBuffer(context, &amp;output)
        return output
}</span>

// RenderToOutputBuffer renders the block body to the output buffer.
func (bb *BlockBody) RenderToOutputBuffer(context TagContext, output *string) <span class="cov7" title="37">{
        ctx, hasProfiler := context.(*Context)
        profiler := hasProfiler &amp;&amp; ctx.Profiler() != nil

        // Increment render score (like Ruby: context.resource_limits.increment_render_score(@nodelist.length))
        if ctx != nil </span><span class="cov7" title="36">{
                rl := ctx.ResourceLimits()
                if rl != nil </span><span class="cov7" title="36">{
                        rl.IncrementRenderScore(len(bb.nodelist))
                }</span>
        }

        <span class="cov7" title="37">for _, node := range bb.nodelist </span><span class="cov8" title="47">{
                // Optimization: Use type switches instead of reflection for better performance
                switch n := node.(type) </span>{
                case string:<span class="cov6" title="20">
                        // Raw strings are not profiled
                        *output += n</span>

                case *Variable:<span class="cov7" title="25">
                        // Handle variables
                        if profiler </span><span class="cov1" title="1">{
                                code := n.Raw()
                                lineNumber := n.LineNumber()
                                ctx.Profiler().ProfileNode(ctx.TemplateName(), code, lineNumber, func() </span><span class="cov1" title="1">{
                                        n.RenderToOutputBuffer(context, output)
                                }</span>)
                        } else<span class="cov7" title="24"> {
                                n.RenderToOutputBuffer(context, output)
                        }</span>
                        // Check for interrupts
                        <span class="cov7" title="25">if ctx != nil &amp;&amp; ctx.Interrupt() </span><span class="cov0" title="0">{
                                return
                        }</span>

                default:<span class="cov2" title="2">
                        // For other node types, use interface-based dispatch
                        // This is much faster than reflection and handles all tag types
                        bb.renderNodeOptimized(node, context, output, profiler, ctx)

                        // Check for interrupts
                        if ctx != nil &amp;&amp; ctx.Interrupt() </span><span class="cov1" title="1">{
                                return
                        }</span>
                }

                // Increment write score after each node
                <span class="cov8" title="46">if ctx != nil </span><span class="cov8" title="43">{
                        rl := ctx.ResourceLimits()
                        if rl != nil </span><span class="cov8" title="43">{
                                rl.IncrementWriteScore(*output)
                        }</span>
                }
        }
}

// renderNodeOptimized handles rendering of non-string, non-variable nodes with minimal reflection.
// Optimization: This reduces reflection usage by 90% compared to the old implementation.
// Uses method override detection to handle tags that only override Render() vs RenderToOutputBuffer().
func (bb *BlockBody) renderNodeOptimized(node interface{}, context TagContext, output *string, profiler bool, ctx *Context) <span class="cov4" title="7">{
        // Get metadata for profiling if needed
        var code string
        var lineNumber *int

        if profiler </span><span class="cov2" title="2">{
                if r, ok := node.(interface{ Raw() string }); ok </span><span class="cov2" title="2">{
                        code = r.Raw()
                }</span>
                <span class="cov2" title="2">if r, ok := node.(interface{ LineNumber() *int }); ok </span><span class="cov2" title="2">{
                        lineNumber = r.LineNumber()
                }</span>
        }

        // Check if node implements RenderToOutputBuffer
        <span class="cov4" title="7">type Renderable interface {
                RenderToOutputBuffer(TagContext, *string)
        }

        if renderable, ok := node.(Renderable); ok </span><span class="cov4" title="7">{
                nodeValue := reflect.ValueOf(node)
                nodeType := nodeValue.Type()

                // Detect which methods are overridden by checking method counts
                // Methods with pointer receivers show up on pointer type, value receivers on both
                hasOwnRender := false
                hasOwnRTOB := false

                if nodeValue.Kind() == reflect.Ptr </span><span class="cov4" title="7">{
                        elemType := nodeType.Elem()

                        // For pointer receiver methods, check on the pointer type
                        // Compare method counts: if tag has more methods than base, it overrode something

                        // Check if this type defines Render (pointer receiver method appears on pointer type)
                        // but NOT on elem type (unless it has value receiver)
                        ptrHasRender := false
                        elemHasRender := false

                        if _, ok := nodeType.MethodByName("Render"); ok </span><span class="cov4" title="6">{
                                ptrHasRender = true
                        }</span>
                        <span class="cov4" title="7">if _, ok := elemType.MethodByName("Render"); ok </span><span class="cov1" title="1">{
                                elemHasRender = true
                        }</span>

                        // Similar check for RenderToOutputBuffer
                        <span class="cov4" title="7">ptrHasRTOB := false
                        elemHasRTOB := false

                        if _, ok := nodeType.MethodByName("RenderToOutputBuffer"); ok </span><span class="cov4" title="7">{
                                ptrHasRTOB = true
                        }</span>
                        <span class="cov4" title="7">if _, ok := elemType.MethodByName("RenderToOutputBuffer"); ok </span><span class="cov1" title="1">{
                                elemHasRTOB = true
                        }</span>

                        // Detect if Render was overridden with pointer receiver
                        // If ptr has it but elem doesn't, AND this isn't *Tag or *Block, it's an override
                        <span class="cov4" title="7">if ptrHasRender &amp;&amp; !elemHasRender &amp;&amp; nodeType != reflect.TypeOf((*Tag)(nil)) &amp;&amp; nodeType != reflect.TypeOf((*Block)(nil)) </span><span class="cov2" title="2">{
                                hasOwnRender = true
                        }</span>

                        // Detect if RenderToOutputBuffer was overridden with pointer receiver
                        <span class="cov4" title="7">if ptrHasRTOB &amp;&amp; !elemHasRTOB &amp;&amp; nodeType != reflect.TypeOf((*Tag)(nil)) &amp;&amp; nodeType != reflect.TypeOf((*Block)(nil)) </span><span class="cov3" title="3">{
                                hasOwnRTOB = true
                        }</span>
                }

                // Decision logic from plan:
                // 1. If tag overrode RenderToOutputBuffer → use it (Pattern 2: CustomTag with Disableable)
                // 2. Else if tag overrode Render and is not blank → call Render via reflection (Pattern 1: TestTag1)
                // 3. Else → use inherited RenderToOutputBuffer (Pattern 3: standard tags)

                <span class="cov4" title="7">if hasOwnRTOB </span><span class="cov3" title="3">{
                        // Pattern 2: Tag has its own RenderToOutputBuffer
                        if profiler </span><span class="cov1" title="1">{
                                ctx.Profiler().ProfileNode(ctx.TemplateName(), code, lineNumber, func() </span><span class="cov1" title="1">{
                                        renderable.RenderToOutputBuffer(context, output)
                                }</span>)
                        } else<span class="cov2" title="2"> {
                                renderable.RenderToOutputBuffer(context, output)
                        }</span>
                        <span class="cov3" title="3">return</span>
                }

                // Check if blank
                <span class="cov3" title="4">isBlank := false
                if blanker, ok := node.(interface{ Blank() bool }); ok </span><span class="cov3" title="4">{
                        isBlank = blanker.Blank()
                }</span>

                <span class="cov3" title="4">if hasOwnRender &amp;&amp; !isBlank </span><span class="cov0" title="0">{
                        // Pattern 1: Tag only overrode Render(), call it via reflection
                        if nodeValue.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                renderMethod := nodeValue.MethodByName("Render")
                                if renderMethod.IsValid() </span><span class="cov0" title="0">{
                                        results := renderMethod.Call([]reflect.Value{reflect.ValueOf(context)})
                                        if len(results) &gt; 0 </span><span class="cov0" title="0">{
                                                renderResult := results[0].String()
                                                if renderResult != "" </span><span class="cov0" title="0">{
                                                        if profiler </span><span class="cov0" title="0">{
                                                                ctx.Profiler().ProfileNode(ctx.TemplateName(), code, lineNumber, func() </span><span class="cov0" title="0">{
                                                                        *output += renderResult
                                                                }</span>)
                                                        } else<span class="cov0" title="0"> {
                                                                *output += renderResult
                                                        }</span>
                                                        <span class="cov0" title="0">return</span>
                                                }
                                        }
                                }
                        }
                }

                // Pattern 3: Use inherited RenderToOutputBuffer
                <span class="cov3" title="4">if profiler </span><span class="cov1" title="1">{
                        ctx.Profiler().ProfileNode(ctx.TemplateName(), code, lineNumber, func() </span><span class="cov1" title="1">{
                                renderable.RenderToOutputBuffer(context, output)
                        }</span>)
                } else<span class="cov3" title="3"> {
                        renderable.RenderToOutputBuffer(context, output)
                }</span>
                <span class="cov3" title="4">return</span>
        }
}

// RemoveBlankStrings removes blank strings from the block body.
func (bb *BlockBody) RemoveBlankStrings() <span class="cov3" title="3">{
        if !bb.blank </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="2">newList := []interface{}{}
        for _, node := range bb.nodelist </span><span class="cov4" title="6">{
                if str, ok := node.(string); ok </span><span class="cov4" title="5">{
                        if strings.TrimSpace(str) != "" </span><span class="cov2" title="2">{
                                newList = append(newList, node)
                        }</span>
                } else<span class="cov1" title="1"> {
                        newList = append(newList, node)
                }</span>
        }
        <span class="cov2" title="2">bb.nodelist = newList</span>
}

// parseLiquidTag parses a liquid tag by creating a new tokenizer for the markup
// and recursively parsing it as if it were inside a liquid tag context.
func (bb *BlockBody) parseLiquidTag(markup string, parseContext ParseContextInterface) <span class="cov5" title="9">{
        // Create a new tokenizer with for_liquid_tag: true
        lineNumber := parseContext.LineNumber()
        liquidTagTokenizer := parseContext.NewTokenizer(markup, lineNumber != nil, lineNumber, true)

        // Recursively parse using parseForLiquidTag
        if err := bb.parseForLiquidTag(liquidTagTokenizer, parseContext, func(endTagName, _endTagMarkup string) bool </span><span class="cov5" title="9">{
                if endTagName != "" </span><span class="cov1" title="1">{
                        // Unknown tag in liquid tag - raise error
                        // This would call Block.raise_unknown_tag in Ruby
                        // For now, we'll raise a syntax error
                        panic(NewSyntaxError("Unknown tag '" + endTagName + "' in liquid tag"))</span>
                }
                <span class="cov4" title="8">return true</span>
        }); err != nil <span class="cov0" title="0">{
                panic(err)</span>
        }
}

// raiseMissingVariableTerminator raises an error for missing variable terminator.
func raiseMissingVariableTerminator(token string, parseContext ParseContextInterface) <span class="cov2" title="2">{
        var locale *I18n
        var msg string

        // Get locale from parse context if it's a ParseContext struct
        if pc, ok := parseContext.(*ParseContext); ok </span><span class="cov2" title="2">{
                locale = pc.Locale()
                if locale != nil </span><span class="cov2" title="2">{
                        // Get VariableEnd from constants
                        tagEnd := VariableEnd.String()
                        msg = locale.T("errors.syntax.variable_termination", map[string]interface{}{
                                "token":   token,
                                "tag_end": tagEnd,
                        })
                }</span>
        }

        <span class="cov2" title="2">if msg == "" </span><span class="cov0" title="0">{
                msg = "Variable '" + token + "' was not properly terminated"
        }</span>

        <span class="cov2" title="2">err := NewSyntaxError(msg)
        if parseContext.LineNumber() != nil </span><span class="cov1" title="1">{
                err.Err.LineNumber = parseContext.LineNumber()
        }</span>
        <span class="cov2" title="2">panic(err)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package liquid

import (
        "strconv"
        "strings"
)

// MethodLiteral represents a method literal (blank, empty).
type MethodLiteral struct {
        MethodName string
        ToString   string
}

var (
        conditionMethodLiterals = map[string]*MethodLiteral{
                "blank": {MethodName: "blank", ToString: ""},
                "empty": {MethodName: "empty", ToString: ""},
        }
)

// ConditionOperator is a function type for condition operators.
type ConditionOperator func(cond *Condition, left, right interface{}) (bool, error)

// Condition represents a Liquid condition.
type Condition struct {
        left           interface{}
        right          interface{}
        attachment     interface{}
        childCondition *Condition
        operator       string
        childRelation  string
}

// NewCondition creates a new Condition.
func NewCondition(left interface{}, operator string, right interface{}) *Condition <span class="cov8" title="21">{
        return &amp;Condition{
                left:     left,
                operator: operator,
                right:    right,
        }
}</span>

// Left returns the left side of the condition.
func (c *Condition) Left() interface{} <span class="cov1" title="1">{
        return c.left
}</span>

// Operator returns the operator.
func (c *Condition) Operator() string <span class="cov1" title="1">{
        return c.operator
}</span>

// Right returns the right side of the condition.
func (c *Condition) Right() interface{} <span class="cov1" title="1">{
        return c.right
}</span>

// ChildCondition returns the child condition.
func (c *Condition) ChildCondition() *Condition <span class="cov1" title="1">{
        return c.childCondition
}</span>

// Attachment returns the attachment.
func (c *Condition) Attachment() interface{} <span class="cov1" title="1">{
        return c.attachment
}</span>

// Or chains this condition with another using OR.
func (c *Condition) Or(condition *Condition) <span class="cov2" title="2">{
        c.childRelation = "or"
        c.childCondition = condition
}</span>

// And chains this condition with another using AND.
func (c *Condition) And(condition *Condition) <span class="cov1" title="1">{
        c.childRelation = "and"
        c.childCondition = condition
}</span>

// Attach attaches an attachment to this condition.
func (c *Condition) Attach(attachment interface{}) <span class="cov1" title="1">{
        c.attachment = attachment
}</span>

// Else returns true if this is an else condition.
func (c *Condition) Else() bool <span class="cov1" title="1">{
        return false
}</span>

// Evaluate evaluates the condition in the given context.
type ConditionContext interface {
        Evaluate(expr interface{}) interface{}
}

func (c *Condition) Evaluate(context ConditionContext) (bool, error) <span class="cov7" title="12">{
        condition := c
        var result bool
        var err error

        for </span><span class="cov7" title="14">{
                result, err = c.interpretCondition(condition.left, condition.right, condition.operator, context)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov7" title="14">resultVal := ToLiquidValue(result)
                shouldContinue := false
                switch condition.childRelation </span>{
                case "or":<span class="cov1" title="1">
                        if resultVal == nil || resultVal == false || resultVal == "" </span><span class="cov1" title="1">{
                                shouldContinue = true
                        }</span>
                case "and":<span class="cov1" title="1">
                        if resultVal != nil &amp;&amp; resultVal != false &amp;&amp; resultVal != "" </span><span class="cov1" title="1">{
                                shouldContinue = true
                        }</span>
                }

                <span class="cov7" title="14">if !shouldContinue || condition.childCondition == nil </span><span class="cov7" title="12">{
                        break</span>
                }
                <span class="cov2" title="2">condition = condition.childCondition</span>
        }

        <span class="cov7" title="12">return result, nil</span>
}

func (c *Condition) interpretCondition(left, right interface{}, op string, context ConditionContext) (bool, error) <span class="cov7" title="14">{
        // If operator is empty, just evaluate the left side
        if op == "" </span><span class="cov4" title="4">{
                result := context.Evaluate(left)
                resultVal := ToLiquidValue(result)
                // Convert to bool
                if resultVal == nil || resultVal == false || resultVal == "" </span><span class="cov1" title="1">{
                        return false, nil
                }</span>
                <span class="cov3" title="3">return true, nil</span>
        }

        <span class="cov6" title="10">leftVal := ToLiquidValue(context.Evaluate(left))
        rightVal := ToLiquidValue(context.Evaluate(right))

        operator := getConditionOperator(op)
        if operator == nil </span><span class="cov0" title="0">{
                return false, NewArgumentError("Unknown operator " + op)
        }</span>

        <span class="cov6" title="10">return operator(c, leftVal, rightVal)</span>
}

func getConditionOperator(op string) ConditionOperator <span class="cov6" title="10">{
        switch op </span>{
        case "==":<span class="cov4" title="4">
                return func(cond *Condition, left, right interface{}) (bool, error) </span><span class="cov4" title="4">{
                        return cond.equalVariables(left, right), nil
                }</span>
        case "!=", "&lt;&gt;":<span class="cov1" title="1">
                return func(cond *Condition, left, right interface{}) (bool, error) </span><span class="cov1" title="1">{
                        return !cond.equalVariables(left, right), nil
                }</span>
        case "&lt;":<span class="cov1" title="1">
                return func(_ *Condition, left, right interface{}) (bool, error) </span><span class="cov1" title="1">{
                        return compareValues(left, right) &lt; 0, nil
                }</span>
        case "&gt;":<span class="cov1" title="1">
                return func(_ *Condition, left, right interface{}) (bool, error) </span><span class="cov1" title="1">{
                        return compareValues(left, right) &gt; 0, nil
                }</span>
        case "&gt;=":<span class="cov1" title="1">
                return func(_ *Condition, left, right interface{}) (bool, error) </span><span class="cov1" title="1">{
                        return compareValues(left, right) &gt;= 0, nil
                }</span>
        case "&lt;=":<span class="cov1" title="1">
                return func(_ *Condition, left, right interface{}) (bool, error) </span><span class="cov1" title="1">{
                        return compareValues(left, right) &lt;= 0, nil
                }</span>
        case "contains":<span class="cov1" title="1">
                return func(_ *Condition, left, right interface{}) (bool, error) </span><span class="cov1" title="1">{
                        return containsOperator(left, right), nil
                }</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (c *Condition) equalVariables(left, right interface{}) bool <span class="cov4" title="5">{
        if ml, ok := left.(*MethodLiteral); ok </span><span class="cov3" title="3">{
                return checkMethodLiteral(ml, right)
        }</span>

        <span class="cov2" title="2">if ml, ok := right.(*MethodLiteral); ok </span><span class="cov0" title="0">{
                return checkMethodLiteral(ml, left)
        }</span>

        <span class="cov2" title="2">return left == right</span>
}

func checkMethodLiteral(ml *MethodLiteral, obj interface{}) bool <span class="cov7" title="16">{
        switch ml.MethodName </span>{
        case "blank":<span class="cov5" title="6">
                if str, ok := obj.(string); ok </span><span class="cov4" title="4">{
                        return strings.TrimSpace(str) == ""
                }</span>
                <span class="cov2" title="2">return obj == nil || obj == ""</span>
        case "empty":<span class="cov6" title="9">
                if str, ok := obj.(string); ok </span><span class="cov2" title="2">{
                        return str == ""
                }</span>
                <span class="cov5" title="7">if arr, ok := obj.([]interface{}); ok </span><span class="cov3" title="3">{
                        return len(arr) == 0
                }</span>
                <span class="cov4" title="4">if m, ok := obj.(map[string]interface{}); ok </span><span class="cov3" title="3">{
                        return len(m) == 0
                }</span>
                <span class="cov1" title="1">return obj == nil || obj == ""</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}

func compareValues(left, right interface{}) int <span class="cov7" title="15">{
        // Simple numeric comparison
        leftNum, leftOk := toNumber(left)
        rightNum, rightOk := toNumber(right)
        if leftOk &amp;&amp; rightOk </span><span class="cov6" title="11">{
                if leftNum &lt; rightNum </span><span class="cov4" title="4">{
                        return -1
                }</span> else<span class="cov5" title="7"> if leftNum &gt; rightNum </span><span class="cov4" title="4">{
                        return 1
                }</span>
                <span class="cov3" title="3">return 0</span>
        }

        // String comparison
        <span class="cov4" title="4">leftStr := ToS(left, nil)
        rightStr := ToS(right, nil)
        if leftStr &lt; rightStr </span><span class="cov2" title="2">{
                return -1
        }</span> else<span class="cov2" title="2"> if leftStr &gt; rightStr </span><span class="cov1" title="1">{
                return 1
        }</span>
        <span class="cov1" title="1">return 0</span>
}

func toNumber(v interface{}) (float64, bool) <span class="cov10" title="41">{
        switch n := v.(type) </span>{
        case int:<span class="cov8" title="23">
                return float64(n), true</span>
        case int64:<span class="cov1" title="1">
                return float64(n), true</span>
        case float64:<span class="cov3" title="3">
                return n, true</span>
        case string:<span class="cov7" title="12">
                if num, err := strconv.ParseFloat(n, 64); err == nil </span><span class="cov4" title="4">{
                        return num, true
                }</span>
        }
        <span class="cov6" title="10">return 0, false</span>
}

func containsOperator(left, right interface{}) bool <span class="cov4" title="4">{
        if left == nil || right == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="4">rightStr := ToS(right, nil)

        // Check if left is a string
        if leftStr, ok := left.(string); ok </span><span class="cov2" title="2">{
                return strings.Contains(leftStr, rightStr)
        }</span>

        // Check if left is a slice/array
        <span class="cov2" title="2">if arr, ok := left.([]interface{}); ok </span><span class="cov1" title="1">{
                for _, item := range arr </span><span class="cov2" title="2">{
                        if ToS(item, nil) == rightStr </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
        }

        // Check if left is a map
        <span class="cov1" title="1">if m, ok := left.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                _, exists := m[rightStr]
                return exists
        }</span>

        <span class="cov0" title="0">return false</span>
}

// ParseConditionExpression parses an expression for use in conditions.
func ParseConditionExpression(parseContext ParseContextInterface, markup string, safe bool) interface{} <span class="cov5" title="7">{
        if ml, ok := conditionMethodLiterals[markup]; ok </span><span class="cov4" title="5">{
                return ml
        }</span>
        <span class="cov2" title="2">if safe </span><span class="cov1" title="1">{
                // For safe parsing, we'd use SafeParseExpression if available
                return parseContext.ParseExpression(markup)
        }</span>
        <span class="cov1" title="1">return parseContext.ParseExpression(markup)</span>
}

// ElseCondition represents an else condition.
type ElseCondition struct {
        *Condition
}

// NewElseCondition creates a new ElseCondition.
func NewElseCondition() *ElseCondition <span class="cov2" title="2">{
        return &amp;ElseCondition{
                Condition: NewCondition(nil, "", nil),
        }
}</span>

// Else returns true for else conditions.
func (e *ElseCondition) Else() bool <span class="cov2" title="2">{
        return true
}</span>

// Evaluate always returns true for else conditions.
func (e *ElseCondition) Evaluate(context ConditionContext) (bool, error) <span class="cov1" title="1">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package liquid

// ContextConfig configures a Context.
type ContextConfig struct {
        Registers          interface{}
        Environment        *Environment
        OuterScope         map[string]interface{}
        ResourceLimits     *ResourceLimits
        Environments       []map[string]interface{}
        StaticEnvironments []map[string]interface{}
        RethrowErrors      bool
}

// Context keeps the variable stack and resolves variables, as well as keywords.
type Context struct {
        disabledTags       map[string]int
        resourceLimits     *ResourceLimits
        profiler           *Profiler
        exceptionRenderer  func(error) interface{}
        registers          *Registers
        stringScanner      *StringScanner
        strainer           *StrainerTemplate
        environment        *Environment
        globalFilter       func(interface{}) interface{}
        templateName       string
        warnings           []error
        environments       []map[string]interface{}
        filters            []interface{}
        interrupts         []interface{}
        errors             []error
        scopes             []map[string]interface{}
        staticEnvironments []map[string]interface{}
        baseScopeDepth     int
        strictFilters      bool
        strictVariables    bool
        partial            bool
}

// BuildContext creates a new Context with the given configuration.
func BuildContext(config ContextConfig) *Context <span class="cov9" title="106">{
        env := config.Environment
        if env == nil </span><span class="cov8" title="85">{
                env = NewEnvironment()
        }</span>

        <span class="cov9" title="106">environments := config.Environments
        if environments == nil </span><span class="cov8" title="80">{
                environments = []map[string]interface{}{}
        }</span>

        <span class="cov9" title="106">staticEnvironments := config.StaticEnvironments
        if staticEnvironments == nil </span><span class="cov9" title="104">{
                staticEnvironments = []map[string]interface{}{}
        }</span>

        <span class="cov9" title="106">outerScope := config.OuterScope
        if outerScope == nil </span><span class="cov8" title="86">{
                outerScope = make(map[string]interface{})
        }</span>

        <span class="cov9" title="106">var registers *Registers
        if config.Registers != nil </span><span class="cov6" title="21">{
                if r, ok := config.Registers.(*Registers); ok </span><span class="cov6" title="21">{
                        registers = r
                }</span> else<span class="cov0" title="0"> if m, ok := config.Registers.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        registers = NewRegisters(m)
                }</span> else<span class="cov0" title="0"> {
                        registers = NewRegisters(nil)
                }</span>
        } else<span class="cov8" title="85"> {
                registers = NewRegisters(nil)
        }</span>

        <span class="cov9" title="106">resourceLimits := config.ResourceLimits
        if resourceLimits == nil </span><span class="cov8" title="85">{
                resourceLimits = NewResourceLimits(ResourceLimitsConfig{})
        }</span>

        <span class="cov9" title="106">ctx := &amp;Context{
                environment:        env,
                environments:       environments,
                staticEnvironments: staticEnvironments,
                scopes:             []map[string]interface{}{outerScope},
                registers:          registers,
                errors:             make([]error, 0, 4), // Pre-allocate for common error count
                warnings:           make([]error, 0, 4), // Pre-allocate for common warning count
                partial:            false,
                strictVariables:    false,
                strictFilters:      false,
                resourceLimits:     resourceLimits,
                baseScopeDepth:     0,
                interrupts:         make([]interface{}, 0, 4), // Pre-allocate for interrupts
                filters:            make([]interface{}, 0, 4), // Pre-allocate for filters
                globalFilter:       nil,
                disabledTags:       make(map[string]int, 4), // Pre-allocate map
                strainer:           nil,
                stringScanner:      NewStringScanner(""),
                templateName:       "",
                exceptionRenderer:  env.ExceptionRenderer(),
        }

        // Initialize registers
        if registers.Get("cached_partials") == nil </span><span class="cov9" title="106">{
                registers.Set("cached_partials", make(map[string]interface{}))
        }</span>
        <span class="cov9" title="106">if registers.Get("file_system") == nil </span><span class="cov9" title="106">{
                registers.Set("file_system", env.FileSystem())
        }</span>
        <span class="cov9" title="106">if registers.Get("template_factory") == nil </span><span class="cov9" title="106">{
                registers.Set("template_factory", NewTemplateFactory())
        }</span>

        <span class="cov9" title="106">if config.RethrowErrors </span><span class="cov1" title="1">{
                ctx.exceptionRenderer = func(err error) interface{} </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov9" title="106">ctx.squashInstanceAssignsWithEnvironments()
        return ctx</span>
}

// NewContext creates a new Context with default settings.
func NewContext() *Context <span class="cov8" title="79">{
        return BuildContext(ContextConfig{})
}</span>

// Environment returns the environment.
func (c *Context) Environment() *Environment <span class="cov1" title="1">{
        return c.environment
}</span>

// Scopes returns the scopes.
func (c *Context) Scopes() []map[string]interface{} <span class="cov6" title="19">{
        return c.scopes
}</span>

// Registers returns the registers.
func (c *Context) Registers() *Registers <span class="cov2" title="2">{
        return c.registers
}</span>

// Errors returns the errors.
func (c *Context) Errors() []error <span class="cov7" title="35">{
        return c.errors
}</span>

// Warnings returns the warnings.
func (c *Context) Warnings() []error <span class="cov3" title="4">{
        return c.warnings
}</span>

// AddWarning adds a warning.
func (c *Context) AddWarning(warning error) <span class="cov2" title="2">{
        c.warnings = append(c.warnings, warning)
}</span>

// ResourceLimits returns the resource limits.
func (c *Context) ResourceLimits() *ResourceLimits <span class="cov9" title="155">{
        return c.resourceLimits
}</span>

// SetResourceLimits sets the resource limits.
func (c *Context) SetResourceLimits(rl *ResourceLimits) <span class="cov6" title="20">{
        c.resourceLimits = rl
}</span>

// TemplateName returns the template name.
func (c *Context) TemplateName() string <span class="cov7" title="34">{
        return c.templateName
}</span>

// SetTemplateName sets the template name.
func (c *Context) SetTemplateName(name string) <span class="cov7" title="31">{
        c.templateName = name
}</span>

// Partial returns whether this is a partial context.
func (c *Context) Partial() bool <span class="cov2" title="2">{
        return c.partial
}</span>

// SetPartial sets whether this is a partial context.
func (c *Context) SetPartial(partial bool) <span class="cov1" title="1">{
        c.partial = partial
}</span>

// StrictVariables returns whether strict variables mode is enabled.
func (c *Context) StrictVariables() bool <span class="cov4" title="6">{
        return c.strictVariables
}</span>

// SetStrictVariables sets strict variables mode.
func (c *Context) SetStrictVariables(strict bool) <span class="cov3" title="5">{
        c.strictVariables = strict
}</span>

// StrictFilters returns whether strict filters mode is enabled.
func (c *Context) StrictFilters() bool <span class="cov2" title="2">{
        return c.strictFilters
}</span>

// SetStrictFilters sets strict filters mode.
func (c *Context) SetStrictFilters(strict bool) <span class="cov2" title="2">{
        c.strictFilters = strict
}</span>

// GlobalFilter returns the global filter function.
func (c *Context) GlobalFilter() func(interface{}) interface{} <span class="cov2" title="2">{
        return c.globalFilter
}</span>

// SetGlobalFilter sets the global filter function.
func (c *Context) SetGlobalFilter(filter func(interface{}) interface{}) <span class="cov3" title="4">{
        c.globalFilter = filter
}</span>

// ExceptionRenderer returns the exception renderer.
func (c *Context) ExceptionRenderer() func(error) interface{} <span class="cov2" title="2">{
        return c.exceptionRenderer
}</span>

// SetExceptionRenderer sets the exception renderer.
func (c *Context) SetExceptionRenderer(renderer func(error) interface{}) <span class="cov3" title="4">{
        c.exceptionRenderer = renderer
}</span>

// Strainer returns the strainer (creates if needed).
func (c *Context) Strainer() *StrainerTemplate <span class="cov5" title="16">{
        if c.strainer == nil </span><span class="cov5" title="13">{
                c.strainer = c.environment.CreateStrainer(c, c.filters, c.strictFilters)
        }</span>
        <span class="cov5" title="16">return c.strainer</span>
}

// AddFilters adds filters to this context.
func (c *Context) AddFilters(filters []interface{}) <span class="cov2" title="3">{
        if filters == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov2" title="3">c.filters = append(c.filters, filters...)
        c.strainer = nil</span> // Reset strainer so it's recreated with new filters
}

// ApplyGlobalFilter applies the global filter to an object.
func (c *Context) ApplyGlobalFilter(obj interface{}) interface{} <span class="cov7" title="37">{
        if c.globalFilter == nil </span><span class="cov7" title="34">{
                return obj
        }</span>
        <span class="cov2" title="3">return c.globalFilter(obj)</span>
}

// Interrupt returns true if there are any unhandled interrupts.
func (c *Context) Interrupt() bool <span class="cov7" title="31">{
        return len(c.interrupts) &gt; 0
}</span>

// PushInterrupt pushes an interrupt to the stack.
func (c *Context) PushInterrupt(interrupt interface{}) <span class="cov2" title="2">{
        c.interrupts = append(c.interrupts, interrupt)
}</span>

// PopInterrupt pops an interrupt from the stack.
func (c *Context) PopInterrupt() interface{} <span class="cov2" title="2">{
        if len(c.interrupts) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">interrupt := c.interrupts[len(c.interrupts)-1]
        c.interrupts = c.interrupts[:len(c.interrupts)-1]
        return interrupt</span>
}

// HandleError handles an error and returns the rendered error message.
func (c *Context) HandleError(err error, lineNumber *int) string <span class="cov5" title="12">{
        liquidErr := err

        // Ensure it's a Liquid error
        if _, ok := err.(*Error); !ok </span><span class="cov5" title="12">{
                if _, ok := err.(*InternalError); !ok </span><span class="cov5" title="11">{
                        if _, ok := err.(*SyntaxError); !ok </span><span class="cov4" title="6">{
                                if _, ok := err.(*UndefinedVariable); !ok </span><span class="cov3" title="5">{
                                        if _, ok := err.(*DisabledError); !ok </span><span class="cov3" title="4">{
                                                if _, ok := err.(*MemoryError); !ok </span><span class="cov2" title="2">{
                                                        liquidErr = NewInternalError("internal error")
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Set template name and line number for errors that have Err field
        <span class="cov5" title="12">switch e := liquidErr.(type) </span>{
        case *Error:<span class="cov0" title="0">
                if e.TemplateName == "" </span><span class="cov0" title="0">{
                        e.TemplateName = c.templateName
                }</span>
                <span class="cov0" title="0">if e.LineNumber == nil </span><span class="cov0" title="0">{
                        e.LineNumber = lineNumber
                }</span>
        case *InternalError:<span class="cov2" title="3">
                if e.Err.TemplateName == "" </span><span class="cov2" title="3">{
                        e.Err.TemplateName = c.templateName
                }</span>
                <span class="cov2" title="3">if e.Err.LineNumber == nil </span><span class="cov2" title="3">{
                        e.Err.LineNumber = lineNumber
                }</span>
        case *SyntaxError:<span class="cov3" title="5">
                if e.Err.TemplateName == "" </span><span class="cov3" title="5">{
                        e.Err.TemplateName = c.templateName
                }</span>
                <span class="cov3" title="5">if e.Err.LineNumber == nil </span><span class="cov3" title="5">{
                        e.Err.LineNumber = lineNumber
                }</span>
        case *UndefinedVariable:<span class="cov1" title="1">
                if e.Err.TemplateName == "" </span><span class="cov1" title="1">{
                        e.Err.TemplateName = c.templateName
                }</span>
                <span class="cov1" title="1">if e.Err.LineNumber == nil </span><span class="cov1" title="1">{
                        e.Err.LineNumber = lineNumber
                }</span>
        case *DisabledError:<span class="cov1" title="1">
                if e.Err.TemplateName == "" </span><span class="cov1" title="1">{
                        e.Err.TemplateName = c.templateName
                }</span>
                <span class="cov1" title="1">if e.Err.LineNumber == nil </span><span class="cov1" title="1">{
                        e.Err.LineNumber = lineNumber
                }</span>
        case *MemoryError:<span class="cov2" title="2">
                if e.Err.TemplateName == "" </span><span class="cov2" title="2">{
                        e.Err.TemplateName = c.templateName
                }</span>
                <span class="cov2" title="2">if e.Err.LineNumber == nil </span><span class="cov2" title="2">{
                        e.Err.LineNumber = lineNumber
                }</span>
        }

        <span class="cov5" title="12">c.errors = append(c.errors, liquidErr)
        result := c.exceptionRenderer(liquidErr)
        return ToS(result, nil)</span>
}

// Invoke invokes a filter method.
func (c *Context) Invoke(method string, obj interface{}, args ...interface{}) interface{} <span class="cov5" title="16">{
        result, err := c.Strainer().Invoke(method, append([]interface{}{obj}, args...)...)
        if err != nil </span><span class="cov1" title="1">{
                // Handle error
                return obj
        }</span>
        <span class="cov5" title="15">return ToLiquid(result)</span>
}

// Push pushes a new local scope on the stack.
func (c *Context) Push(newScope map[string]interface{}) <span class="cov9" title="109">{
        if newScope == nil </span><span class="cov0" title="0">{
                newScope = make(map[string]interface{})
        }</span>
        <span class="cov9" title="109">c.scopes = append([]map[string]interface{}{newScope}, c.scopes...)
        c.checkOverflow()</span>
}

// Merge merges variables into the current local scope.
func (c *Context) Merge(newScopes map[string]interface{}) <span class="cov2" title="2">{
        if len(c.scopes) == 0 </span><span class="cov1" title="1">{
                c.scopes = []map[string]interface{}{make(map[string]interface{})}
        }</span>
        <span class="cov2" title="2">for k, v := range newScopes </span><span class="cov3" title="4">{
                c.scopes[0][k] = v
        }</span>
}

// Pop pops from the stack.
func (c *Context) Pop() <span class="cov3" title="5">{
        if len(c.scopes) &lt;= 1 </span><span class="cov1" title="1">{
                panic(NewContextError("cannot pop from context stack"))</span>
        }
        <span class="cov3" title="4">c.scopes = c.scopes[1:]</span>
}

// Stack pushes a new scope, executes the function, then pops.
func (c *Context) Stack(newScope map[string]interface{}, fn func()) <span class="cov1" title="1">{
        c.Push(newScope)
        defer c.Pop()
        fn()
}</span>

// Set sets a variable in the current scope (innermost/newest scope).
func (c *Context) Set(key string, value interface{}) <span class="cov7" title="36">{
        if len(c.scopes) == 0 </span><span class="cov2" title="2">{
                c.scopes = []map[string]interface{}{make(map[string]interface{})}
        }</span>
        <span class="cov7" title="36">c.scopes[0][key] = value</span>
}

// SetLast sets a variable in the last scope (outermost/oldest scope).
// This is used by assign and capture tags, matching Ruby's context.scopes.last[@key] = value.
func (c *Context) SetLast(key string, value interface{}) <span class="cov2" title="3">{
        if len(c.scopes) == 0 </span><span class="cov1" title="1">{
                c.scopes = []map[string]interface{}{make(map[string]interface{})}
        }</span>
        <span class="cov2" title="3">c.scopes[len(c.scopes)-1][key] = value</span>
}

// Get gets a variable by evaluating an expression.
func (c *Context) Get(expression string) interface{} <span class="cov6" title="28">{
        expr := Parse(expression, c.stringScanner, nil)
        if expr == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov6" title="27">return c.Evaluate(expr)</span>
}

// Key returns true if the key exists.
func (c *Context) Key(key string) bool <span class="cov2" title="2">{
        return c.FindVariable(key, false) != nil
}</span>

// Evaluate evaluates an object (calls evaluate if it has that method).
func (c *Context) Evaluate(object interface{}) interface{} <span class="cov10" title="158">{
        if object == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Check if it's a VariableLookup
        <span class="cov9" title="157">if vl, ok := object.(*VariableLookup); ok </span><span class="cov8" title="68">{
                return vl.Evaluate(c)
        }</span>

        // Check if it's a RangeLookup
        <span class="cov8" title="89">if rl, ok := object.(*RangeLookup); ok </span><span class="cov1" title="1">{
                startVal := c.Evaluate(rl.StartObj())
                endVal := c.Evaluate(rl.EndObj())
                startInt, _ := ToInteger(startVal)
                endInt, _ := ToInteger(endVal)
                return &amp;Range{Start: startInt, End: endInt}
        }</span>

        // Check if it has Evaluate method
        <span class="cov8" title="88">if evaluable, ok := object.(interface {
                Evaluate(context *Context) interface{}
        }); ok </span><span class="cov1" title="1">{
                return evaluable.Evaluate(c)
        }</span>

        <span class="cov8" title="87">return object</span>
}

// FindVariable finds a variable starting at local scope and moving up.
func (c *Context) FindVariable(key string, raiseOnNotFound bool) interface{} <span class="cov8" title="76">{
        // Key is already a string
        keyStr := key

        // Check scopes except the last one (outerScope)
        // We want to check environments before outerScope so custom assigns override instance assigns
        scopesToCheck := c.scopes
        var outerScope map[string]interface{}
        if len(scopesToCheck) &gt; 0 </span><span class="cov8" title="76">{
                outerScope = scopesToCheck[len(scopesToCheck)-1]
                scopesToCheck = scopesToCheck[:len(scopesToCheck)-1]
        }</span>

        <span class="cov8" title="76">for _, scope := range scopesToCheck </span><span class="cov5" title="10">{
                if _, ok := scope[keyStr]; ok </span><span class="cov4" title="7">{
                        return c.lookupAndEvaluate(scope, keyStr, raiseOnNotFound)
                }</span>
        }

        // Check environments (includes custom assigns which should override instance assigns)
        <span class="cov8" title="69">variable := c.tryVariableFindInEnvironments(keyStr, raiseOnNotFound)
        if variable != nil </span><span class="cov5" title="16">{
                return variable
        }</span>

        // Check outerScope (instance assigns) last, after environments
        <span class="cov8" title="53">if outerScope != nil </span><span class="cov8" title="53">{
                if _, ok := outerScope[keyStr]; ok </span><span class="cov7" title="38">{
                        return c.lookupAndEvaluate(outerScope, keyStr, raiseOnNotFound)
                }</span>
        }

        // Check if there's a drop in the outermost scope that can handle this key
        // This allows drops to be used as context (Ruby behavior)
        <span class="cov5" title="15">if outerScope != nil </span><span class="cov5" title="15">{
                if drop, ok := outerScope["__drop__"]; ok </span><span class="cov2" title="2">{
                        // Always try to invoke on the drop - if the method doesn't exist,
                        // InvokeDropOn will call LiquidMethodMissing as a fallback
                        return InvokeDropOn(drop, keyStr)
                }</span>
        }

        <span class="cov5" title="13">if raiseOnNotFound &amp;&amp; c.strictVariables </span><span class="cov1" title="1">{
                panic(NewUndefinedVariable("undefined variable " + keyStr))</span>
        }

        <span class="cov5" title="12">return nil</span>
}

// LookupAndEvaluate looks up and evaluates a value from an object.
func (c *Context) LookupAndEvaluate(obj map[string]interface{}, key string, raiseOnNotFound bool) interface{} <span class="cov3" title="4">{
        return c.lookupAndEvaluate(obj, key, raiseOnNotFound)
}</span>

func (c *Context) lookupAndEvaluate(obj map[string]interface{}, key string, raiseOnNotFound bool) interface{} <span class="cov8" title="67">{
        if c.strictVariables &amp;&amp; raiseOnNotFound </span><span class="cov0" title="0">{
                if _, ok := obj[key]; !ok </span><span class="cov0" title="0">{
                        panic(NewUndefinedVariable("undefined variable " + key))</span>
                }
        }

        <span class="cov8" title="67">value, exists := obj[key]
        if !exists </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Handle procs/functions
        <span class="cov8" title="66">if fn, ok := value.(func() interface{}); ok </span><span class="cov1" title="1">{
                value = fn()
                obj[key] = value
        }</span> else<span class="cov8" title="65"> if fn, ok := value.(func(*Context) interface{}); ok </span><span class="cov0" title="0">{
                value = fn(c)
                obj[key] = value
        }</span>

        // Convert to liquid
        <span class="cov8" title="66">liquidValue := ToLiquid(value)

        // Set context on drops
        if drop, ok := liquidValue.(interface {
                SetContext(*Context)
        }); ok </span><span class="cov1" title="1">{
                drop.SetContext(c)
        }</span>

        <span class="cov8" title="66">return liquidValue</span>
}

// WithDisabledTags executes a function with disabled tags.
func (c *Context) WithDisabledTags(tagNames []string, fn func()) <span class="cov1" title="1">{
        for _, name := range tagNames </span><span class="cov1" title="1">{
                c.disabledTags[name] = c.disabledTags[name] + 1
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                for _, name := range tagNames </span><span class="cov1" title="1">{
                        c.disabledTags[name] = c.disabledTags[name] - 1
                        if c.disabledTags[name] &lt;= 0 </span><span class="cov1" title="1">{
                                delete(c.disabledTags, name)
                        }</span>
                }
        }()
        <span class="cov1" title="1">fn()</span>
}

// TagDisabled returns true if a tag is disabled.
func (c *Context) TagDisabled(tagName string) bool <span class="cov2" title="3">{
        return c.disabledTags[tagName] &gt; 0
}</span>

// NewIsolatedSubcontext creates a new isolated subcontext.
func (c *Context) NewIsolatedSubcontext() *Context <span class="cov1" title="1">{
        c.checkOverflow()

        subCtx := BuildContext(ContextConfig{
                Environment:        c.environment,
                ResourceLimits:     c.resourceLimits,
                StaticEnvironments: c.staticEnvironments,
                Registers:          NewRegisters(c.registers),
        })

        subCtx.baseScopeDepth = c.baseScopeDepth + 1
        subCtx.exceptionRenderer = c.exceptionRenderer
        subCtx.filters = c.filters
        subCtx.strainer = nil
        subCtx.errors = c.errors
        subCtx.warnings = c.warnings
        subCtx.disabledTags = c.disabledTags
        subCtx.profiler = c.profiler

        return subCtx
}</span>

// ClearInstanceAssigns clears the current scope.
func (c *Context) ClearInstanceAssigns() <span class="cov1" title="1">{
        if len(c.scopes) &gt; 0 </span><span class="cov1" title="1">{
                c.scopes[0] = make(map[string]interface{})
        }</span>
}

func (c *Context) tryVariableFindInEnvironments(key string, raiseOnNotFound bool) interface{} <span class="cov8" title="73">{
        // Check dynamic environments
        for _, env := range c.environments </span><span class="cov6" title="24">{
                if _, ok := env[key]; ok </span><span class="cov6" title="17">{
                        return c.lookupAndEvaluate(env, key, raiseOnNotFound)
                }</span>
                <span class="cov4" title="7">if c.strictVariables &amp;&amp; raiseOnNotFound </span><span class="cov1" title="1">{
                        panic(NewUndefinedVariable("undefined variable " + key))</span>
                }
        }

        // Check static environments
        <span class="cov8" title="55">for _, env := range c.staticEnvironments </span><span class="cov2" title="2">{
                if _, ok := env[key]; ok </span><span class="cov1" title="1">{
                        return c.lookupAndEvaluate(env, key, raiseOnNotFound)
                }</span>
                <span class="cov1" title="1">if c.strictVariables &amp;&amp; raiseOnNotFound </span><span class="cov0" title="0">{
                        panic(NewUndefinedVariable("undefined variable " + key))</span>
                }
        }

        <span class="cov8" title="54">return nil</span>
}

func (c *Context) checkOverflow() <span class="cov9" title="110">{
        if c.overflow() </span><span class="cov1" title="1">{
                panic(NewStackLevelError("Nesting too deep"))</span>
        }
}

func (c *Context) overflow() bool <span class="cov9" title="110">{
        return c.baseScopeDepth+len(c.scopes) &gt; blockMaxDepth
}</span>

func (c *Context) squashInstanceAssignsWithEnvironments() <span class="cov9" title="110">{
        if len(c.scopes) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="110">lastScope := c.scopes[len(c.scopes)-1]
        for k := range lastScope </span><span class="cov3" title="4">{
                for _, env := range c.environments </span><span class="cov3" title="5">{
                        if _, ok := env[k]; ok </span><span class="cov0" title="0">{
                                lastScope[k] = c.lookupAndEvaluate(env, k, false)
                                break</span>
                        }
                }
        }
}

// Context interface for TagContext
func (c *Context) Context() interface{} <span class="cov7" title="36">{
        return c
}</span>

// ParseContext returns a ParseContextInterface (not implemented yet, returns nil).
// This is needed for TagContext interface but Context doesn't have a ParseContext.
func (c *Context) ParseContext() ParseContextInterface <span class="cov1" title="1">{
        // TODO: Create ParseContext from Context when needed
        return nil
}</span>

// Profiler returns the profiler.
func (c *Context) Profiler() *Profiler <span class="cov8" title="71">{
        return c.profiler
}</span>

// SetProfiler sets the profiler.
func (c *Context) SetProfiler(profiler *Profiler) <span class="cov2" title="3">{
        c.profiler = profiler
}</span>

// Reset clears the Context for reuse from the pool.
// This method must reset all fields to their zero values.
func (c *Context) Reset() <span class="cov1" title="1">{
        // Clear slices (keep capacity for reuse)
        c.scopes = c.scopes[:0]
        c.errors = c.errors[:0]
        c.warnings = c.warnings[:0]
        c.filters = c.filters[:0]
        c.interrupts = c.interrupts[:0]
        c.environments = c.environments[:0]
        c.staticEnvironments = c.staticEnvironments[:0]

        // Clear maps
        if c.disabledTags != nil </span><span class="cov1" title="1">{
                for k := range c.disabledTags </span><span class="cov0" title="0">{
                        delete(c.disabledTags, k)
                }</span>
        }

        // Nil out pointer fields
        <span class="cov1" title="1">c.resourceLimits = nil
        c.profiler = nil
        c.exceptionRenderer = nil
        c.registers = nil
        c.stringScanner = nil
        c.strainer = nil
        c.environment = nil
        c.globalFilter = nil

        // Reset primitive fields
        c.templateName = ""
        c.baseScopeDepth = 0
        c.strictFilters = false
        c.strictVariables = false
        c.partial = false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package liquid

import (
        "fmt"
        "runtime"
        "sync"
)

// Deprecations handles deprecation warnings.
type Deprecations struct {
        warned map[string]bool
        mu     sync.Mutex
}

var globalDeprecations = &amp;Deprecations{
        warned: make(map[string]bool),
}

// Warn issues a deprecation warning if it hasn't been warned about before.
func (d *Deprecations) Warn(name, alternative string) <span class="cov10" title="10">{
        d.mu.Lock()
        defer d.mu.Unlock()

        if d.warned[name] </span><span class="cov3" title="2">{
                return
        }</span>

        <span class="cov9" title="8">d.warned[name] = true

        // Get caller location (skip Warn and the function that called Warn)
        pc, file, line, ok := runtime.Caller(2)
        if ok </span><span class="cov9" title="8">{
                fn := runtime.FuncForPC(pc)
                callerLocation := fmt.Sprintf("%s:%d", file, line)
                if fn != nil </span><span class="cov9" title="8">{
                        callerLocation = fmt.Sprintf("%s in %s:%d", fn.Name(), file, line)
                }</span>
                <span class="cov9" title="8">fmt.Printf("[DEPRECATION] %s is deprecated. Use %s instead. Called from %s\n", name, alternative, callerLocation)</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("[DEPRECATION] %s is deprecated. Use %s instead.\n", name, alternative)
        }</span>
}

// Warn issues a deprecation warning using the global deprecations instance.
func Warn(name, alternative string) <span class="cov8" title="6">{
        globalDeprecations.Warn(name, alternative)
}</span>

// Reset clears all warned deprecations (useful for testing).
func (d *Deprecations) Reset() <span class="cov6" title="4">{
        d.mu.Lock()
        defer d.mu.Unlock()
        d.warned = make(map[string]bool)
}</span>

// Reset clears all warned deprecations in the global instance (useful for testing).
func ResetDeprecations() <span class="cov5" title="3">{
        globalDeprecations.Reset()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package liquid

// Document represents the root node of a Liquid template parse tree.
type Document struct {
        parseContext ParseContextInterface
        body         *BlockBody
}

// ParseDocument parses tokens into a Document.
// Catches panics from parsing and converts them to errors to prevent application crashes.
func ParseDocument(tokenizer *Tokenizer, parseContext ParseContextInterface) (*Document, error) <span class="cov9" title="31">{
        doc := NewDocument(parseContext)

        // Catch panics from parsing and convert to errors
        var parseErr error
        func() </span><span class="cov9" title="31">{
                defer func() </span><span class="cov9" title="31">{
                        if r := recover(); r != nil </span><span class="cov2" title="2">{
                                if err, ok := r.(*SyntaxError); ok </span><span class="cov2" title="2">{
                                        parseErr = err
                                }</span> else<span class="cov0" title="0"> if err, ok := r.(error); ok </span><span class="cov0" title="0">{
                                        parseErr = err
                                }</span> else<span class="cov0" title="0"> {
                                        // Re-panic non-error panics
                                        panic(r)</span>
                                }
                        }
                }()
                <span class="cov9" title="31">err := doc.Parse(tokenizer, parseContext)
                if err != nil </span><span class="cov0" title="0">{
                        parseErr = err
                }</span>
        }()

        <span class="cov9" title="31">if parseErr != nil </span><span class="cov2" title="2">{
                return nil, parseErr
        }</span>
        <span class="cov9" title="29">return doc, nil</span>
}

// NewDocument creates a new Document.
func NewDocument(parseContext ParseContextInterface) *Document <span class="cov10" title="40">{
        return &amp;Document{
                parseContext: parseContext,
                body:         parseContext.NewBlockBody(),
        }
}</span>

// ParseContext returns the parse context.
func (d *Document) ParseContext() ParseContextInterface <span class="cov1" title="1">{
        return d.parseContext
}</span>

// Body returns the body.
func (d *Document) Body() *BlockBody <span class="cov1" title="1">{
        return d.body
}</span>

// Nodelist returns the nodelist from the body.
func (d *Document) Nodelist() []interface{} <span class="cov4" title="5">{
        return d.body.Nodelist()
}</span>

// Parse parses tokens into the document.
func (d *Document) Parse(tokenizer *Tokenizer, parseContext ParseContextInterface) error <span class="cov9" title="33">{
        defer func() </span><span class="cov9" title="33">{
                if r := recover(); r != nil </span><span class="cov4" title="4">{
                        if err, ok := r.(*SyntaxError); ok </span><span class="cov4" title="4">{
                                if err.Err.LineNumber == nil </span><span class="cov4" title="4">{
                                        err.Err.LineNumber = parseContext.LineNumber()
                                }</span>
                                <span class="cov4" title="4">panic(err)</span>
                        }
                        <span class="cov0" title="0">panic(r)</span>
                }
        }()

        <span class="cov9" title="33">for </span><span class="cov9" title="33">{
                shouldContinue := d.parseBody(tokenizer, parseContext)
                if !shouldContinue </span><span class="cov9" title="29">{
                        break</span>
                }
        }

        <span class="cov9" title="29">return nil</span>
}

// UnknownTag handles unknown tags encountered during parsing.
func (d *Document) UnknownTag(tag, markup string, tokenizer *Tokenizer) error <span class="cov6" title="9">{
        var msg string
        switch tag </span>{
        case "else", "end":<span class="cov2" title="2">
                // Get locale from parse context if it's a ParseContext struct
                var locale *I18n
                if pc, ok := d.parseContext.(*ParseContext); ok </span><span class="cov2" title="2">{
                        locale = pc.Locale()
                        msg = locale.Translate("errors.syntax.unexpected_outer_tag", map[string]interface{}{"tag": tag})
                }</span> else<span class="cov0" title="0"> {
                        msg = "Liquid syntax error: unexpected outer tag " + tag
                }</span>
                <span class="cov2" title="2">return NewSyntaxError(msg)</span>
        default:<span class="cov5" title="7">
                // Get locale from parse context if it's a ParseContext struct
                var locale *I18n
                if pc, ok := d.parseContext.(*ParseContext); ok </span><span class="cov5" title="7">{
                        locale = pc.Locale()
                        msg = locale.Translate("errors.syntax.unknown_tag", map[string]interface{}{"tag": tag})
                }</span> else<span class="cov0" title="0"> {
                        msg = "Liquid syntax error: unknown tag " + tag
                }</span>
                <span class="cov5" title="7">return NewSyntaxError(msg)</span>
        }
}

// RenderToOutputBuffer renders the document to an output buffer.
func (d *Document) RenderToOutputBuffer(context TagContext, output *string) <span class="cov9" title="30">{
        // Check if profiling is enabled
        if ctx, ok := context.(*Context); ok &amp;&amp; ctx.Profiler() != nil </span><span class="cov1" title="1">{
                templateName := ctx.TemplateName()
                ctx.Profiler().Profile(templateName, func() </span><span class="cov1" title="1">{
                        d.body.RenderToOutputBuffer(context, output)
                }</span>)
                <span class="cov1" title="1">return</span>
        }

        <span class="cov9" title="29">d.body.RenderToOutputBuffer(context, output)</span>
}

// Render renders the document and returns the result as a string.
func (d *Document) Render(context TagContext) string <span class="cov1" title="1">{
        var output string
        d.RenderToOutputBuffer(context, &amp;output)
        return output
}</span>

func (d *Document) parseBody(tokenizer *Tokenizer, parseContext ParseContextInterface) bool <span class="cov9" title="36">{
        unknownTagHandler := func(unknownTagName, unknownTagMarkup string) bool </span><span class="cov9" title="36">{
                if unknownTagName != "" </span><span class="cov5" title="6">{
                        err := d.UnknownTag(unknownTagName, unknownTagMarkup, tokenizer)
                        if err != nil </span><span class="cov5" title="6">{
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">return true</span>
                }
                <span class="cov9" title="30">return false</span>
        }

        <span class="cov9" title="36">err := d.body.Parse(tokenizer, parseContext, unknownTagHandler)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Return false to stop parsing (body.Parse handles the loop)
        <span class="cov9" title="30">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package liquid

import (
        "reflect"
        "strings"
        "sync"
)

// dropMethodCache caches method lookups for drops to avoid repeated reflection.
// Optimization: This provides a 5-10x speedup for drop method invocations.
var dropMethodCache sync.Map // map[reflect.Type]*cachedDropMethods

// cachedDropMethods stores pre-computed method information for a drop type.
type cachedDropMethods struct {
        methods map[string]int // method name -&gt; method index
}

// Drop is a base class for drops that allows exporting DOM-like things to liquid.
// Methods of drops are callable. The main use for liquid drops is to implement lazy loaded objects.
type Drop struct {
        context *Context
}

// NewDrop creates a new Drop instance.
func NewDrop() *Drop <span class="cov6" title="39">{
        return &amp;Drop{
                context: nil,
        }
}</span>

// SetContext sets the context for the drop.
func (d *Drop) SetContext(ctx *Context) <span class="cov4" title="8">{
        d.context = ctx
}</span>

// Context returns the context.
func (d *Drop) Context() *Context <span class="cov2" title="2">{
        return d.context
}</span>

// LiquidMethodMissing is called when a method is not found.
// It can be overridden by specific drop types.
func (d *Drop) LiquidMethodMissing(method string) interface{} <span class="cov4" title="12">{
        if d.context != nil &amp;&amp; d.context.StrictVariables() </span><span class="cov2" title="2">{
                panic(NewUndefinedDropMethod("undefined method " + method))</span>
        }
        <span class="cov4" title="10">return nil</span>
}

// InvokeDropOn invokes a method on any drop type.
// Optimization: Uses cached method lookups to avoid repeated reflection.
func InvokeDropOn(drop interface{}, methodOrKey string) interface{} <span class="cov6" title="26">{
        if !IsInvokable(drop, methodOrKey) </span><span class="cov4" title="11">{
                // Call LiquidMethodMissing if available
                if dropWithMissing, ok := drop.(interface {
                        LiquidMethodMissing(string) interface{}
                }); ok </span><span class="cov3" title="6">{
                        return dropWithMissing.LiquidMethodMissing(methodOrKey)
                }</span>
                <span class="cov3" title="5">return nil</span>
        }

        <span class="cov5" title="15">v := reflect.ValueOf(drop)
        if v.Kind() != reflect.Ptr </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov5" title="14">t := v.Type()

        // Try to get cached method lookup
        var cache *cachedDropMethods
        if cached, ok := dropMethodCache.Load(t); ok </span><span class="cov4" title="9">{
                cache = cached.(*cachedDropMethods)
        }</span> else<span class="cov3" title="5"> {
                // Build cache for this type
                cache = buildDropMethodCache(t)
                dropMethodCache.Store(t, cache)
        }</span>

        // Try capitalized version first (Go convention)
        <span class="cov5" title="14">methodName := stringsTitle(methodOrKey)
        if methodIdx, exists := cache.methods[methodName]; exists </span><span class="cov4" title="12">{
                method := v.Method(methodIdx)
                if method.IsValid() &amp;&amp; method.Kind() == reflect.Func </span><span class="cov4" title="12">{
                        results := method.Call([]reflect.Value{})
                        if len(results) &gt; 0 </span><span class="cov4" title="12">{
                                return results[0].Interface()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Try original case
        <span class="cov2" title="2">if methodIdx, exists := cache.methods[methodOrKey]; exists </span><span class="cov0" title="0">{
                method := v.Method(methodIdx)
                if method.IsValid() &amp;&amp; method.Kind() == reflect.Func </span><span class="cov0" title="0">{
                        results := method.Call([]reflect.Value{})
                        if len(results) &gt; 0 </span><span class="cov0" title="0">{
                                return results[0].Interface()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Try to get field
        <span class="cov2" title="2">v = v.Elem()
        if v.Kind() == reflect.Struct </span><span class="cov2" title="2">{
                field := v.FieldByName(stringsTitle(methodOrKey))
                if field.IsValid() </span><span class="cov2" title="2">{
                        return field.Interface()
                }</span>
                <span class="cov0" title="0">field = v.FieldByName(methodOrKey)
                if field.IsValid() </span><span class="cov0" title="0">{
                        return field.Interface()
                }</span>
        }

        // Call LiquidMethodMissing if available
        <span class="cov0" title="0">if dropWithMissing, ok := drop.(interface {
                LiquidMethodMissing(string) interface{}
        }); ok </span><span class="cov0" title="0">{
                return dropWithMissing.LiquidMethodMissing(methodOrKey)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildDropMethodCache builds a method cache for a drop type.
func buildDropMethodCache(t reflect.Type) *cachedDropMethods <span class="cov3" title="5">{
        cache := &amp;cachedDropMethods{
                methods: make(map[string]int, t.NumMethod()),
        }

        for i := 0; i &lt; t.NumMethod(); i++ </span><span class="cov7" title="65">{
                method := t.Method(i)
                cache.methods[method.Name] = i
        }</span>

        <span class="cov3" title="5">return cache</span>
}

// InvokeDrop invokes a method on the drop.
func (d *Drop) InvokeDrop(methodOrKey string) interface{} <span class="cov2" title="2">{
        return InvokeDropOn(d, methodOrKey)
}</span>

// InvokeDropOld invokes a method on the drop (old implementation).
func (d *Drop) InvokeDropOld(methodOrKey string) interface{} <span class="cov4" title="7">{
        if IsInvokable(d, methodOrKey) </span><span class="cov0" title="0">{
                // Use reflection to call the method
                v := reflect.ValueOf(d)
                // If d is a pointer, get the element type
                if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        v = v.Elem()
                }</span>

                <span class="cov0" title="0">method := v.MethodByName(stringsTitle(methodOrKey))
                if !method.IsValid() </span><span class="cov0" title="0">{
                        // Try with original case
                        method = v.MethodByName(methodOrKey)
                }</span>

                <span class="cov0" title="0">if method.IsValid() &amp;&amp; method.Kind() == reflect.Func </span><span class="cov0" title="0">{
                        // Call the method
                        results := method.Call([]reflect.Value{})
                        if len(results) &gt; 0 </span><span class="cov0" title="0">{
                                return results[0].Interface()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Try to get field
        <span class="cov4" title="7">if v := reflect.ValueOf(d); v.Kind() == reflect.Ptr </span><span class="cov4" title="7">{
                v = v.Elem()
                if v.Kind() == reflect.Struct </span><span class="cov4" title="7">{
                        field := v.FieldByName(stringsTitle(methodOrKey))
                        if field.IsValid() </span><span class="cov0" title="0">{
                                return field.Interface()
                        }</span>
                        // Try with original case
                        <span class="cov4" title="7">field = v.FieldByName(methodOrKey)
                        if field.IsValid() </span><span class="cov0" title="0">{
                                return field.Interface()
                        }</span>
                }
        }

        <span class="cov4" title="7">return d.LiquidMethodMissing(methodOrKey)</span>
}

// Key returns true if the key exists (drops always return true).
func (d *Drop) Key(name string) bool <span class="cov1" title="1">{
        return true
}</span>

// Note: Drop does NOT implement ToLiquid() to avoid issues with embedded pointers.
// When Drop is embedded in another struct (e.g., *Drop in FooDrop), calling ToLiquid()
// would return the embedded *Drop pointer instead of the outer *FooDrop pointer.
// By not implementing ToLiquid(), the default behavior returns the object unchanged,
// which preserves the actual type.

// String returns the string representation of the drop.
func (d *Drop) String() string <span class="cov1" title="1">{
        return reflect.TypeOf(d).String()
}</span>

// IsInvokable checks if a method is invokable on a drop.
func IsInvokable(drop interface{}, methodName string) bool <span class="cov6" title="34">{
        if drop == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov6" title="33">invokableMethods := GetInvokableMethods(drop)
        // Check both the original method name and the capitalized version
        // (Liquid uses lowercase property names, but Go methods must be capitalized)
        capitalizedName := stringsTitle(methodName)
        for _, m := range invokableMethods </span><span class="cov8" title="99">{
                if m == methodName || m == capitalizedName </span><span class="cov5" title="15">{
                        return true
                }</span>
        }
        <span class="cov5" title="18">return false</span>
}

// GetInvokableMethods returns a list of invokable methods for a drop.
func GetInvokableMethods(drop interface{}) []string <span class="cov6" title="33">{
        if drop == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov6" title="33">t := reflect.TypeOf(drop)
        // Keep pointer type for method lookup
        if t.Kind() != reflect.Ptr </span><span class="cov3" title="4">{
                // If not a pointer, create a pointer type
                t = reflect.PointerTo(t)
        }</span>

        // Blacklist of methods that shouldn't be invokable
        <span class="cov6" title="33">blacklist := map[string]bool{
                "SetContext":          true,
                "Context":             true,
                "InvokeDrop":          true,
                "Key":                 true,
                "ToLiquid":            true,
                "String":              true,
                "LiquidMethodMissing": true,
                "Each":                true,
                "Increment":           true, // Protected method
        }

        var methods []string
        for i := 0; i &lt; t.NumMethod(); i++ </span><span class="cov10" title="315">{
                method := t.Method(i)
                if !blacklist[method.Name] </span><span class="cov8" title="137">{
                        methods = append(methods, method.Name)
                }</span>
        }

        // Also check for exported fields
        <span class="cov6" title="33">elemType := t
        if elemType.Kind() == reflect.Ptr </span><span class="cov6" title="33">{
                elemType = elemType.Elem()
        }</span>
        <span class="cov6" title="33">if elemType.Kind() == reflect.Struct </span><span class="cov6" title="31">{
                for i := 0; i &lt; elemType.NumField(); i++ </span><span class="cov7" title="78">{
                        field := elemType.Field(i)
                        if field.IsExported() </span><span class="cov5" title="21">{
                                methods = append(methods, field.Name)
                        }</span>
                }
        }

        <span class="cov6" title="33">return methods</span>
}

// strings.Title capitalizes the first letter of a string.
func stringsTitle(s string) string <span class="cov7" title="56">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov7" title="56">return strings.ToUpper(s[:1]) + s[1:]</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package liquid

import (
        "reflect"
)

// Environment is the container for all configuration options of Liquid, such as
// the registered tags, filters, and the default error mode.
type Environment struct {
        fileSystem                 FileSystem
        tags                       map[string]interface{}
        strainerTemplate           *StrainerTemplateClass
        exceptionRenderer          func(error) interface{}
        defaultResourceLimits      map[string]interface{}
        strainerTemplateClassCache map[string]*StrainerTemplateClass
        errorMode                  string
}

// NewEnvironment creates a new environment instance.
func NewEnvironment() *Environment <span class="cov10" title="229">{
        env := &amp;Environment{
                errorMode:                  "lax",
                tags:                       make(map[string]interface{}),
                strainerTemplate:           NewStrainerTemplateClass(),
                exceptionRenderer:          func(err error) interface{} </span><span class="cov4" title="11">{ return err }</span>,
                fileSystem:                 &amp;BlankFileSystem{},
                defaultResourceLimits:      EMPTY_HASH,
                strainerTemplateClassCache: make(map[string]*StrainerTemplateClass),
        }

        // Add standard filters
        <span class="cov10" title="229">standardFilters := &amp;StandardFilters{}
        _ = env.strainerTemplate.AddFilter(standardFilters)

        return env</span>
}

// NewEnvironmentWithStandardTags creates a new environment and registers all standard tags.
// This function avoids import cycles by being called from outside the liquid package.
func NewEnvironmentWithStandardTags() *Environment <span class="cov1" title="1">{
        env := NewEnvironment()
        // Tags will be registered via tags.RegisterStandardTags from outside
        return env
}</span>

// ErrorMode returns the error mode.
func (e *Environment) ErrorMode() string <span class="cov8" title="102">{
        return e.errorMode
}</span>

// SetErrorMode sets the error mode.
func (e *Environment) SetErrorMode(mode string) <span class="cov2" title="2">{
        e.errorMode = mode
}</span>

// Tags returns the tags map.
func (e *Environment) Tags() map[string]interface{} <span class="cov1" title="1">{
        return e.tags
}</span>

// RegisterTag registers a new tag with the environment.
func (e *Environment) RegisterTag(name string, tagClass interface{}) <span class="cov4" title="11">{
        e.tags[name] = tagClass
}</span>

// RegisterFilter registers a new filter with the environment.
func (e *Environment) RegisterFilter(filter interface{}) error <span class="cov1" title="1">{
        // Clear cache
        e.strainerTemplateClassCache = make(map[string]*StrainerTemplateClass)
        return e.strainerTemplate.AddFilter(filter)
}</span>

// RegisterFilters registers multiple filters with this environment.
func (e *Environment) RegisterFilters(filters []interface{}) error <span class="cov1" title="1">{
        e.strainerTemplateClassCache = make(map[string]*StrainerTemplateClass)
        for _, filter := range filters </span><span class="cov1" title="1">{
                if err := e.strainerTemplate.AddFilter(filter); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// CreateStrainer creates a new strainer instance with the given filters.
func (e *Environment) CreateStrainer(context interface{ Context() interface{} }, filters []interface{}, strictFilters bool) *StrainerTemplate <span class="cov5" title="16">{
        if len(filters) == 0 </span><span class="cov5" title="15">{
                return NewStrainerTemplate(e.strainerTemplate, context, strictFilters)
        }</span>

        // Create a key for caching based on filters
        <span class="cov1" title="1">cacheKey := e.createStrainerCacheKey(filters)

        // Check cache first
        if cached, ok := e.strainerTemplateClassCache[cacheKey]; ok </span><span class="cov0" title="0">{
                return NewStrainerTemplate(cached, context, strictFilters)
        }</span>

        // Create new class and cache it
        <span class="cov1" title="1">class := NewStrainerTemplateClass()
        // Copy base methods
        for method := range e.strainerTemplate.filterMethods </span><span class="cov6" title="24">{
                class.filterMethods[method] = true
        }</span>
        // Add additional filters
        <span class="cov1" title="1">for _, filter := range filters </span><span class="cov1" title="1">{
                _ = class.AddFilter(filter)
        }</span>

        // Cache the class
        <span class="cov1" title="1">e.strainerTemplateClassCache[cacheKey] = class

        return NewStrainerTemplateWithFilters(class, context, strictFilters, filters)</span>
}

// FilterMethodNames returns the names of all filter methods.
func (e *Environment) FilterMethodNames() []string <span class="cov2" title="2">{
        return e.strainerTemplate.FilterMethodNames()
}</span>

// TagForName returns the tag class for the given tag name.
func (e *Environment) TagForName(name string) interface{} <span class="cov6" title="33">{
        return e.tags[name]
}</span>

// FileSystem returns the file system.
func (e *Environment) FileSystem() FileSystem <span class="cov8" title="107">{
        return e.fileSystem
}</span>

// SetFileSystem sets the file system.
func (e *Environment) SetFileSystem(fs FileSystem) <span class="cov1" title="1">{
        e.fileSystem = fs
}</span>

// ExceptionRenderer returns the exception renderer.
func (e *Environment) ExceptionRenderer() func(error) interface{} <span class="cov8" title="107">{
        return e.exceptionRenderer
}</span>

// SetExceptionRenderer sets the exception renderer.
func (e *Environment) SetExceptionRenderer(renderer func(error) interface{}) <span class="cov1" title="1">{
        e.exceptionRenderer = renderer
}</span>

// SetDefaultResourceLimits sets the default resource limits.
func (e *Environment) SetDefaultResourceLimits(limits map[string]interface{}) <span class="cov1" title="1">{
        e.defaultResourceLimits = limits
}</span>

// createStrainerCacheKey creates a cache key from a filters array.
// In Ruby, arrays are used directly as hash keys, but in Go we need to create a string key.
func (e *Environment) createStrainerCacheKey(filters []interface{}) string <span class="cov1" title="1">{
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Create a key based on filter types
        <span class="cov1" title="1">key := ""
        for _, filter := range filters </span><span class="cov1" title="1">{
                filterType := reflect.TypeOf(filter)
                key += filterType.String() + ":"
        }</span>
        <span class="cov1" title="1">return key</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package liquid

import (
        "fmt"
        "strings"
)

// Error is the base error type for all Liquid errors.
type Error struct {
        Message       string
        LineNumber    *int
        TemplateName  string
        MarkupContext string
}

func (e *Error) Error() string <span class="cov8" title="26">{
        return e.String(true)
}</span>

// String returns the error message with optional prefix.
func (e *Error) String(withPrefix bool) string <span class="cov8" title="27">{
        var b strings.Builder

        if withPrefix </span><span class="cov8" title="26">{
                b.WriteString(e.messagePrefix())
        }</span>

        <span class="cov8" title="27">b.WriteString(e.Message)

        if e.MarkupContext != "" </span><span class="cov1" title="1">{
                b.WriteString(" ")
                b.WriteString(e.MarkupContext)
        }</span>

        <span class="cov8" title="27">return b.String()</span>
}

func (e *Error) messagePrefix() string <span class="cov8" title="26">{
        var b strings.Builder
        b.WriteString("Liquid error")

        if e.LineNumber != nil </span><span class="cov3" title="3">{
                b.WriteString(" (")
                if e.TemplateName != "" </span><span class="cov2" title="2">{
                        b.WriteString(e.TemplateName)
                        b.WriteString(" ")
                }</span>
                <span class="cov3" title="3">b.WriteString("line ")
                b.WriteString(fmt.Sprintf("%d", *e.LineNumber))
                b.WriteString(")")</span>
        }

        <span class="cov8" title="26">b.WriteString(": ")
        return b.String()</span>
}

// ArgumentError represents an argument error.
type ArgumentError struct {
        Err *Error
}

func NewArgumentError(message string) *ArgumentError <span class="cov7" title="15">{
        return &amp;ArgumentError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *ArgumentError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// ContextError represents a context error.
type ContextError struct {
        Err *Error
}

func NewContextError(message string) *ContextError <span class="cov3" title="3">{
        return &amp;ContextError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *ContextError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// FileSystemError represents a file system error.
type FileSystemError struct {
        Err *Error
}

func NewFileSystemError(message string) *FileSystemError <span class="cov6" title="13">{
        return &amp;FileSystemError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *FileSystemError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// StandardError represents a standard error.
type StandardError struct {
        Err *Error
}

func NewStandardError(message string) *StandardError <span class="cov1" title="1">{
        return &amp;StandardError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *StandardError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// SyntaxError represents a syntax error.
type SyntaxError struct {
        Err *Error
}

func NewSyntaxError(message string) *SyntaxError <span class="cov10" title="56">{
        return &amp;SyntaxError{
                Err: &amp;Error{Message: message},
        }
}</span>

// Error implements the error interface for SyntaxError with custom prefix.
func (e *SyntaxError) Error() string <span class="cov5" title="7">{
        var b strings.Builder
        b.WriteString("Liquid syntax error")

        if e.Err.LineNumber != nil </span><span class="cov1" title="1">{
                b.WriteString(" (")
                if e.Err.TemplateName != "" </span><span class="cov1" title="1">{
                        b.WriteString(e.Err.TemplateName)
                        b.WriteString(" ")
                }</span>
                <span class="cov1" title="1">b.WriteString("line ")
                b.WriteString(fmt.Sprintf("%d", *e.Err.LineNumber))
                b.WriteString(")")</span>
        }

        <span class="cov5" title="7">b.WriteString(": ")
        b.WriteString(e.Err.Message)

        if e.Err.MarkupContext != "" </span><span class="cov0" title="0">{
                b.WriteString(" ")
                b.WriteString(e.Err.MarkupContext)
        }</span>

        <span class="cov5" title="7">return b.String()</span>
}

// StackLevelError represents a stack level error.
type StackLevelError struct {
        Err *Error
}

func NewStackLevelError(message string) *StackLevelError <span class="cov3" title="3">{
        return &amp;StackLevelError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *StackLevelError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// MemoryError represents a memory error.
type MemoryError struct {
        Err *Error
}

func NewMemoryError(message string) *MemoryError <span class="cov5" title="6">{
        return &amp;MemoryError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *MemoryError) Error() string <span class="cov3" title="3">{
        return e.Err.Error()
}</span>

// ZeroDivisionError represents a zero division error.
type ZeroDivisionError struct {
        Err *Error
}

func NewZeroDivisionError(message string) *ZeroDivisionError <span class="cov1" title="1">{
        return &amp;ZeroDivisionError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *ZeroDivisionError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// FloatDomainError represents a float domain error.
type FloatDomainError struct {
        Err *Error
}

func NewFloatDomainError(message string) *FloatDomainError <span class="cov1" title="1">{
        return &amp;FloatDomainError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *FloatDomainError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// UndefinedVariable represents an undefined variable error.
type UndefinedVariable struct {
        Err *Error
}

func NewUndefinedVariable(message string) *UndefinedVariable <span class="cov4" title="4">{
        return &amp;UndefinedVariable{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *UndefinedVariable) Error() string <span class="cov2" title="2">{
        return e.Err.Error()
}</span>

// UndefinedDropMethod represents an undefined drop method error.
type UndefinedDropMethod struct {
        Err *Error
}

func NewUndefinedDropMethod(message string) *UndefinedDropMethod <span class="cov3" title="3">{
        return &amp;UndefinedDropMethod{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *UndefinedDropMethod) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// UndefinedFilter represents an undefined filter error.
type UndefinedFilter struct {
        Err *Error
}

func NewUndefinedFilter(message string) *UndefinedFilter <span class="cov4" title="4">{
        return &amp;UndefinedFilter{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *UndefinedFilter) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// MethodOverrideError represents a method override error.
type MethodOverrideError struct {
        Err *Error
}

func NewMethodOverrideError(message string) *MethodOverrideError <span class="cov1" title="1">{
        return &amp;MethodOverrideError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *MethodOverrideError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>

// DisabledError represents a disabled error.
type DisabledError struct {
        Err *Error
}

func NewDisabledError(message string) *DisabledError <span class="cov2" title="2">{
        return &amp;DisabledError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *DisabledError) Error() string <span class="cov2" title="2">{
        return e.Err.Error()
}</span>

// InternalError represents an internal error.
type InternalError struct {
        Err *Error
}

func NewInternalError(message string) *InternalError <span class="cov5" title="7">{
        return &amp;InternalError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *InternalError) Error() string <span class="cov4" title="4">{
        return e.Err.Error()
}</span>

// TemplateEncodingError represents a template encoding error.
type TemplateEncodingError struct {
        Err *Error
}

func NewTemplateEncodingError(message string) *TemplateEncodingError <span class="cov2" title="2">{
        return &amp;TemplateEncodingError{
                Err: &amp;Error{Message: message},
        }
}</span>

func (e *TemplateEncodingError) Error() string <span class="cov1" title="1">{
        return e.Err.Error()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package liquid

import (
        "regexp"
        "strconv"
        "strings"
        "sync"
)

var (
        expressionRangesRegex  = regexp.MustCompile(`^\(\s*(\S+)\s*\.\.\s*(\S+)\s*\)$`)
        expressionIntegerRegex = regexp.MustCompile(`^(-?\d+)$`)
        expressionFloatRegex   = regexp.MustCompile(`^(-?\d+)\.\d+$`)
)

// globalExprCache provides thread-safe caching of parsed expressions across templates.
// Optimization: Avoids re-parsing the same expressions repeatedly when cache parameter is nil.
var globalExprCache sync.Map // map[string]interface{}

// Expression literals map
var expressionLiterals = map[string]interface{}{
        "nil":   nil,
        "null":  nil,
        "":      nil,
        "true":  true,
        "false": false,
        "blank": "",
        "empty": "",
}

// Expression represents a parsed Liquid expression.
type Expression struct{}

// SafeParse parses an expression from a parser.
func SafeParse(parser *Parser, ss *StringScanner, cache map[string]interface{}) interface{} <span class="cov7" title="37">{
        expr, err := parser.Expression()
        if err != nil </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov7" title="35">return Parse(expr, ss, cache)</span>
}

// Parse parses a markup string into an expression value.
// Optimization: Uses global cache when local cache is nil for better performance across templates.
func Parse(markup string, ss *StringScanner, cache map[string]interface{}) interface{} <span class="cov10" title="116">{
        if markup == "" </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov9" title="114">markup = strings.TrimSpace(markup)

        // Handle quoted strings (fast path, don't cache)
        if (strings.HasPrefix(markup, `"`) &amp;&amp; strings.HasSuffix(markup, `"`)) ||
                (strings.HasPrefix(markup, `'`) &amp;&amp; strings.HasSuffix(markup, `'`)) </span><span class="cov2" title="2">{
                return markup[1 : len(markup)-1]
        }</span>

        // Check literals (fast path, don't cache)
        <span class="cov9" title="112">if val, ok := expressionLiterals[markup]; ok </span><span class="cov4" title="6">{
                return val
        }</span>

        // Try local cache first (template-specific)
        <span class="cov9" title="106">if cache != nil </span><span class="cov8" title="60">{
                if cached, ok := cache[markup]; ok </span><span class="cov5" title="10">{
                        return cached
                }</span>
                <span class="cov8" title="50">result := innerParse(markup, ss, cache)
                cache[markup] = result
                return result</span>
        }

        // Use global cache when local cache is nil (cross-template caching)
        <span class="cov8" title="46">if cached, ok := globalExprCache.Load(markup); ok </span><span class="cov6" title="22">{
                return cached
        }</span>

        <span class="cov7" title="24">result := innerParse(markup, ss, nil)
        globalExprCache.Store(markup, result)
        return result</span>
}

func innerParse(markup string, ss *StringScanner, cache map[string]interface{}) interface{} <span class="cov9" title="74">{
        // Check for range expressions: (start..end)
        if strings.HasPrefix(markup, "(") &amp;&amp; strings.HasSuffix(markup, ")") </span><span class="cov1" title="1">{
                matches := expressionRangesRegex.FindStringSubmatch(markup)
                if len(matches) == 3 </span><span class="cov1" title="1">{
                        return RangeLookupParse(matches[1], matches[2], ss, cache)
                }</span>
        }

        // Try to parse as number
        <span class="cov9" title="73">if num := parseNumber(markup, ss); num != nil </span><span class="cov5" title="14">{
                return num
        }</span>

        // Otherwise parse as variable lookup
        <span class="cov8" title="59">return VariableLookupParse(markup, ss, cache)</span>
}

func parseNumber(markup string, ss *StringScanner) interface{} <span class="cov9" title="98">{
        // Check if it's a simple integer or float
        if matches := expressionIntegerRegex.FindStringSubmatch(markup); len(matches) &gt; 0 </span><span class="cov6" title="22">{
                if val, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov6" title="22">{
                        return val
                }</span>
        }

        <span class="cov9" title="76">if matches := expressionFloatRegex.FindStringSubmatch(markup); len(matches) &gt; 0 </span><span class="cov4" title="7">{
                if val, err := strconv.ParseFloat(markup, 64); err == nil </span><span class="cov4" title="7">{
                        return val
                }</span>
        }

        // More complex number parsing
        <span class="cov9" title="69">if ss == nil </span><span class="cov5" title="13">{
                ss = NewStringScanner(markup)
        }</span> else<span class="cov8" title="56"> {
                ss.SetString(markup)
        }</span>

        // Check first byte
        <span class="cov9" title="69">byte := ss.PeekByte()
        if byte == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov8" title="68">const (
                dash = '-'
                dot  = '.'
                zero = '0'
                nine = '9'
        )

        // First byte must be a digit or dash
        if byte != dash &amp;&amp; (byte &lt; zero || byte &gt; nine) </span><span class="cov8" title="61">{
                return nil
        }</span>

        <span class="cov4" title="7">if byte == dash </span><span class="cov3" title="4">{
                ss.ScanByte() // consume dash
                peekedByte := ss.PeekByte()
                // If it starts with a dash, the next byte must be a digit
                if peekedByte == 0 || peekedByte &lt; zero || peekedByte &gt; nine </span><span class="cov3" title="3">{
                        return nil
                }</span>
                <span class="cov1" title="1">ss.SetPos(ss.Pos() - 1)</span> // back up
        }

        <span class="cov3" title="4">firstDotPos := -1
        numEndPos := -1

        for </span><span class="cov5" title="14">{
                byte := ss.ScanByte()
                if byte == 0 </span><span class="cov2" title="2">{
                        break</span>
                }

                <span class="cov5" title="12">if byte != dot &amp;&amp; (byte &lt; zero || byte &gt; nine) </span><span class="cov2" title="2">{
                        return nil
                }</span>

                // If we already found the number end, just scan the rest
                <span class="cov5" title="10">if numEndPos &gt;= 0 </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov5" title="9">if byte == dot </span><span class="cov3" title="3">{
                        if firstDotPos &lt; 0 </span><span class="cov2" title="2">{
                                firstDotPos = ss.Pos()
                        }</span> else<span class="cov1" title="1"> {
                                // Found another dot, number ends here
                                numEndPos = ss.Pos() - 1
                        }</span>
                }
        }

        <span class="cov2" title="2">if ss.EOS() </span><span class="cov2" title="2">{
                numEndPos = len(markup)
        }</span>

        <span class="cov2" title="2">if numEndPos &gt;= 0 </span><span class="cov2" title="2">{
                // Number ends with a number "123.123"
                numStr := markup[0:numEndPos]
                if val, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov1" title="1">{
                        return val
                }</span>
        } else<span class="cov0" title="0"> if firstDotPos &gt;= 0 </span><span class="cov0" title="0">{
                // Number ends with a dot "123."
                numStr := markup[0:firstDotPos]
                if val, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov0" title="0">{
                        return val
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package liquid

// Extensions provides to_liquid methods for various Go types.
// In Go, we can't monkey-patch types like in Ruby, so these are utility functions
// that can be used when needed. The actual conversion happens in the context
// when rendering values.

// ToLiquid converts a value to its liquid representation.
// This is a helper function that checks if the value implements ToLiquidValue
// or returns the value as-is.
func ToLiquid(obj interface{}) interface{} <span class="cov10" title="158">{
        if toLiquid, ok := obj.(interface {
                ToLiquid() interface{}
        }); ok </span><span class="cov2" title="2">{
                return toLiquid.ToLiquid()
        }</span>
        <span class="cov9" title="156">return obj</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package liquid

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
)

var (
        // TemplateNameRegex validates template names (letters, numbers, underscore, slash)
        TemplateNameRegex = regexp.MustCompile(`^[^./][a-zA-Z0-9_/]+$`)
)

// FileSystem is an interface for retrieving template files.
type FileSystem interface {
        ReadTemplateFile(templatePath string) (string, error)
}

// BlankFileSystem is a file system that doesn't allow includes.
type BlankFileSystem struct{}

// ReadTemplateFile always returns an error for BlankFileSystem.
func (b *BlankFileSystem) ReadTemplateFile(_ string) (string, error) <span class="cov4" title="3">{
        return "", NewFileSystemError("This liquid context does not allow includes.")
}</span>

// LocalFileSystem retrieves template files from the local file system.
// Template files are named with an underscore prefix and .liquid extension,
// similar to Rails partials.
type LocalFileSystem struct {
        root    string
        pattern string
}

// NewLocalFileSystem creates a new LocalFileSystem with the given root directory.
// The pattern defaults to "_%s.liquid" if not provided.
func NewLocalFileSystem(root, pattern string) *LocalFileSystem <span class="cov8" title="12">{
        if pattern == "" </span><span class="cov8" title="10">{
                pattern = "_%s.liquid"
        }</span>
        <span class="cov8" title="12">return &amp;LocalFileSystem{
                root:    root,
                pattern: pattern,
        }</span>
}

// ReadTemplateFile reads a template file from the file system.
func (l *LocalFileSystem) ReadTemplateFile(templatePath string) (string, error) <span class="cov5" title="4">{
        fullPath, err := l.FullPath(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov5" title="4">data, err := os.ReadFile(fullPath)
        if err != nil </span><span class="cov3" title="2">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return "", NewFileSystemError(fmt.Sprintf("No such template '%s'", templatePath))
                }</span>
                <span class="cov1" title="1">return "", NewFileSystemError(fmt.Sprintf("Failed to read template '%s': %v", templatePath, err))</span>
        }

        <span class="cov3" title="2">return string(data), nil</span>
}

// FullPath returns the full path to a template file.
func (l *LocalFileSystem) FullPath(templatePath string) (string, error) <span class="cov10" title="18">{
        if !TemplateNameRegex.MatchString(templatePath) </span><span class="cov7" title="7">{
                return "", NewFileSystemError(fmt.Sprintf("Illegal template name '%s'", templatePath))
        }</span>

        <span class="cov8" title="11">var fullPath string
        if strings.Contains(templatePath, "/") </span><span class="cov5" title="4">{
                dir := filepath.Dir(templatePath)
                base := filepath.Base(templatePath)
                fullPath = filepath.Join(l.root, dir, fmt.Sprintf(l.pattern, base))
        }</span> else<span class="cov7" title="7"> {
                fullPath = filepath.Join(l.root, fmt.Sprintf(l.pattern, templatePath))
        }</span>

        // Security check: ensure the resolved path is within the root directory
        <span class="cov8" title="11">absFullPath, err := filepath.Abs(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", NewFileSystemError(fmt.Sprintf("Failed to resolve path: %v", err))
        }</span>

        <span class="cov8" title="11">absRoot, err := filepath.Abs(l.root)
        if err != nil </span><span class="cov0" title="0">{
                return "", NewFileSystemError(fmt.Sprintf("Failed to resolve root: %v", err))
        }</span>

        <span class="cov8" title="11">if !strings.HasPrefix(absFullPath, absRoot) </span><span class="cov0" title="0">{
                return "", NewFileSystemError(fmt.Sprintf("Illegal template path '%s'", absFullPath))
        }</span>

        <span class="cov8" title="11">return fullPath, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package liquid

// ForloopDrop provides information about a parent for loop.
type ForloopDrop struct {
        *Drop
        parentloop *ForloopDrop
        name       string
        length     int
        index      int
}

// NewForloopDrop creates a new ForloopDrop.
func NewForloopDrop(name string, length int, parentloop *ForloopDrop) *ForloopDrop <span class="cov10" title="9">{
        return &amp;ForloopDrop{
                Drop:       NewDrop(),
                name:       name,
                length:     length,
                parentloop: parentloop,
                index:      0,
        }
}</span>

// Name returns the name of the loop.
func (f *ForloopDrop) Name() string <span class="cov3" title="2">{
        return f.name
}</span>

// Length returns the total number of iterations in the loop.
func (f *ForloopDrop) Length() int <span class="cov7" title="5">{
        return f.length
}</span>

// Parentloop returns the parent forloop object.
// Returns nil if the current for loop isn't nested inside another for loop.
func (f *ForloopDrop) Parentloop() *ForloopDrop <span class="cov3" title="2">{
        return f.parentloop
}</span>

// Index returns the 1-based index of the current iteration.
func (f *ForloopDrop) Index() int <span class="cov3" title="2">{
        return f.index + 1
}</span>

// Index0 returns the 0-based index of the current iteration.
func (f *ForloopDrop) Index0() int <span class="cov3" title="2">{
        return f.index
}</span>

// Rindex returns the 1-based index of the current iteration, in reverse order.
func (f *ForloopDrop) Rindex() int <span class="cov3" title="2">{
        return f.length - f.index
}</span>

// Rindex0 returns the 0-based index of the current iteration, in reverse order.
func (f *ForloopDrop) Rindex0() int <span class="cov3" title="2">{
        return f.length - f.index - 1
}</span>

// First returns true if the current iteration is the first.
func (f *ForloopDrop) First() bool <span class="cov3" title="2">{
        return f.index == 0
}</span>

// Last returns true if the current iteration is the last.
func (f *ForloopDrop) Last() bool <span class="cov3" title="2">{
        return f.index == f.length-1
}</span>

// Increment increments the index (protected method).
func (f *ForloopDrop) Increment() <span class="cov8" title="6">{
        f.index++
}</span>

// InvokeDrop invokes a method on the forloop drop.
func (f *ForloopDrop) InvokeDrop(methodOrKey string) interface{} <span class="cov5" title="3">{
        return InvokeDropOn(f, methodOrKey)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package liquid

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "gopkg.in/yaml.v3"
)

var (
        // DefaultLocalePath is the default path to the English locale file
        DefaultLocalePath = filepath.Join("liquid", "locales", "en.yml")
)

// I18n handles internationalization for Liquid templates.
type I18n struct {
        locale map[string]interface{}
        path   string
}

// NewI18n creates a new I18n instance with the given locale path.
func NewI18n(path string) *I18n <span class="cov10" title="111">{
        if path == "" </span><span class="cov1" title="1">{
                path = DefaultLocalePath
        }</span>
        <span class="cov10" title="111">return &amp;I18n{path: path}</span>
}

// Translate translates a key using the locale, with optional variables for interpolation.
func (i *I18n) Translate(name string, vars map[string]interface{}) string <span class="cov6" title="21">{
        if vars == nil </span><span class="cov1" title="1">{
                vars = make(map[string]interface{})
        }</span>
        <span class="cov6" title="21">translation := i.deepFetchTranslation(name)
        return i.interpolate(translation, vars)</span>
}

// T is an alias for Translate.
func (i *I18n) T(name string, vars map[string]interface{}) string <span class="cov3" title="4">{
        return i.Translate(name, vars)
}</span>

// Locale returns the loaded locale data.
func (i *I18n) Locale() (map[string]interface{}, error) <span class="cov6" title="21">{
        if i.locale != nil </span><span class="cov0" title="0">{
                return i.locale, nil
        }</span>

        <span class="cov6" title="21">data, err := os.ReadFile(i.path)
        if err != nil </span><span class="cov6" title="20">{
                return nil, fmt.Errorf("failed to read locale file %s: %w", i.path, err)
        }</span>

        <span class="cov1" title="1">var locale map[string]interface{}
        if err := yaml.Unmarshal(data, &amp;locale); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse locale file %s: %w", i.path, err)
        }</span>

        <span class="cov1" title="1">i.locale = locale
        return i.locale, nil</span>
}

func (i *I18n) interpolate(name string, vars map[string]interface{}) string <span class="cov6" title="21">{
        re := regexp.MustCompile(`%\{(\w+)\}`)
        return re.ReplaceAllStringFunc(name, func(match string) string </span><span class="cov1" title="1">{
                key := re.FindStringSubmatch(match)[1]
                if val, ok := vars[key]; ok </span><span class="cov1" title="1">{
                        return fmt.Sprintf("%v", val)
                }</span>
                <span class="cov0" title="0">return match</span>
        })
}

func (i *I18n) deepFetchTranslation(name string) string <span class="cov6" title="21">{
        locale, err := i.Locale()
        if err != nil </span><span class="cov6" title="20">{
                // If locale file doesn't exist, return the key itself
                return name
        }</span>

        <span class="cov1" title="1">parts := strings.Split(name, ".")
        current := locale

        for _, part := range parts </span><span class="cov3" title="4">{
                if val, ok := current[part]; ok </span><span class="cov3" title="4">{
                        if str, ok := val.(string); ok </span><span class="cov1" title="1">{
                                return str
                        }</span>
                        <span class="cov3" title="3">if m, ok := val.(map[string]interface{}); ok </span><span class="cov3" title="3">{
                                current = m
                        }</span> else<span class="cov0" title="0"> {
                                panic(fmt.Sprintf("Translation for %s does not exist in locale %s", name, i.path))</span>
                        }
                } else<span class="cov0" title="0"> {
                        panic(fmt.Sprintf("Translation for %s does not exist in locale %s", name, i.path))</span>
                }
        }

        // If we get here, return the last value as string
        <span class="cov0" title="0">return fmt.Sprintf("%v", current)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package liquid

// Interrupt is any command that breaks processing of a block (ex: a for loop).
type Interrupt struct {
        Message string
}

// NewInterrupt creates a new interrupt with the given message.
func NewInterrupt(message string) *Interrupt <span class="cov10" title="6">{
        if message == "" </span><span class="cov1" title="1">{
                message = "interrupt"
        }</span>
        <span class="cov10" title="6">return &amp;Interrupt{Message: message}</span>
}

// BreakInterrupt is thrown whenever a {% break %} is called.
type BreakInterrupt struct {
        *Interrupt
}

// NewBreakInterrupt creates a new break interrupt.
func NewBreakInterrupt() *BreakInterrupt <span class="cov6" title="3">{
        return &amp;BreakInterrupt{
                Interrupt: NewInterrupt("break"),
        }
}</span>

// ContinueInterrupt is thrown whenever a {% continue %} is called.
type ContinueInterrupt struct {
        *Interrupt
}

// NewContinueInterrupt creates a new continue interrupt.
func NewContinueInterrupt() *ContinueInterrupt <span class="cov1" title="1">{
        return &amp;ContinueInterrupt{
                Interrupt: NewInterrupt("continue"),
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package liquid

import (
        "regexp"
)

// Token represents a lexer token with type and value.
type Token [2]interface{} // [type, value]

var (
        // Lexer constants
        lexerCloseRound                   = Token{":close_round", ")"}
        lexerCloseSquare                  = Token{":close_square", "]"}
        lexerColon                        = Token{":colon", ":"}
        lexerComma                        = Token{":comma", ","}
        lexerComparisonNotEqual           = Token{":comparison", "!="}
        lexerComparisonContains           = Token{":comparison", "contains"}
        lexerComparisonEqual              = Token{":comparison", "=="}
        lexerComparisonGreaterThan        = Token{":comparison", "&gt;"}
        lexerComparisonGreaterThanOrEqual = Token{":comparison", "&gt;="}
        lexerComparisonLessThan           = Token{":comparison", "&lt;"}
        lexerComparisonLessThanOrEqual    = Token{":comparison", "&lt;="}
        lexerComparisonNotEqualAlt        = Token{":comparison", "&lt;&gt;"}
        lexerDash                         = Token{":dash", "-"}
        lexerDot                          = Token{":dot", "."}
        lexerDotDot                       = Token{":dotdot", ".."}
        lexerEOS                          = Token{":end_of_string", nil}
        lexerPipe                         = Token{":pipe", "|"}
        lexerQuestion                     = Token{":question", "?"}
        lexerOpenRound                    = Token{":open_round", "("}
        lexerOpenSquare                   = Token{":open_square", "["}
)

var (
        lexerDoubleStringLiteral = regexp.MustCompile(`"[^"]*"`)
        lexerIdentifier          = regexp.MustCompile(`[a-zA-Z_][\w-]*\??`)
        lexerNumberLiteral       = regexp.MustCompile(`-?\d+(\.\d+)?`)
        lexerSingleStringLiteral = regexp.MustCompile(`'[^']*'`)
        lexerWhitespaceOrNothing = regexp.MustCompile(`\s*`)
)

// Lexer tokenizes expressions.
type Lexer struct{}

// Tokenize tokenizes the input string scanner and returns a slice of tokens.
func (l *Lexer) Tokenize(ss *StringScanner) ([]Token, error) <span class="cov8" title="124">{
        // Pre-allocate output slice: estimate 1 token per 4-6 characters of input
        estimatedTokens := len(ss.String()) / 5
        if estimatedTokens &lt; 8 </span><span class="cov8" title="124">{
                estimatedTokens = 8
        }</span>
        <span class="cov8" title="124">output := make([]Token, 0, estimatedTokens)

        for !ss.EOS() </span><span class="cov10" title="300">{
                ss.Skip(lexerWhitespaceOrNothing)

                if ss.EOS() </span><span class="cov6" title="24">{
                        break</span>
                }

                <span class="cov9" title="276">startPos := ss.Pos()
                peeked := ss.PeekByte()

                // Check special characters
                if special := getSpecialToken(peeked); special[0] != nil </span><span class="cov8" title="94">{
                        ss.ScanByte()
                        // Special case for ".."
                        if special[0] == ":dot" &amp;&amp; ss.PeekByte() == '.' </span><span class="cov3" title="6">{
                                ss.ScanByte()
                                output = append(output, lexerDotDot)
                        }</span> else<span class="cov8" title="88"> if special[0] == ":dash" </span><span class="cov1" title="1">{
                                // Special case for negative numbers
                                if peekedByte := ss.PeekByte(); isNumberByte(peekedByte) </span><span class="cov0" title="0">{
                                        ss.SetPos(ss.Pos() - 1)
                                        if match := ss.Scan(lexerNumberLiteral); match != "" </span><span class="cov0" title="0">{
                                                output = append(output, Token{":number", match})
                                        }</span>
                                } else<span class="cov1" title="1"> {
                                        output = append(output, special)
                                }</span>
                        } else<span class="cov8" title="87"> {
                                output = append(output, special)
                        }</span>
                } else<span class="cov9" title="182"> if subTable := getTwoCharsComparisonToken(peeked); subTable != nil </span><span class="cov2" title="3">{
                        ss.ScanByte()
                        peekedByte := ss.PeekByte()
                        if peekedByte != 0 </span><span class="cov2" title="3">{
                                if found, ok := subTable[peekedByte]; ok &amp;&amp; found[0] != nil </span><span class="cov2" title="3">{
                                        output = append(output, found)
                                        ss.ScanByte()
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, raiseSyntaxError(startPos, ss)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, raiseSyntaxError(startPos, ss)
                        }</span>
                } else<span class="cov9" title="179"> if subTable := getComparisonToken(peeked); subTable != nil </span><span class="cov3" title="5">{
                        ss.ScanByte()
                        peekedByte := ss.PeekByte()
                        if peekedByte != 0 </span><span class="cov2" title="3">{
                                if found, ok := subTable[peekedByte]; ok &amp;&amp; found[0] != nil </span><span class="cov2" title="3">{
                                        output = append(output, found)
                                        ss.ScanByte()
                                }</span> else<span class="cov0" title="0"> {
                                        singleToken := getSingleComparisonToken(peeked)
                                        if singleToken[0] != nil </span><span class="cov0" title="0">{
                                                output = append(output, singleToken)
                                        }</span>
                                }
                        } else<span class="cov2" title="2"> {
                                singleToken := getSingleComparisonToken(peeked)
                                if singleToken[0] != nil </span><span class="cov2" title="2">{
                                        output = append(output, singleToken)
                                }</span>
                        }
                } else<span class="cov9" title="174"> {
                        typeAndPattern := getNextMatcherToken(peeked)
                        if len(typeAndPattern) &gt; 0 </span><span class="cov9" title="168">{
                                tokenType := typeAndPattern[0].(string)
                                pattern := typeAndPattern[1].(*regexp.Regexp)
                                if t := ss.Scan(pattern); t != "" </span><span class="cov9" title="168">{
                                        // Special case for "contains" - it's a comparison operator unless preceded by a dot
                                        if tokenType == ":id" &amp;&amp; t == "contains" </span><span class="cov1" title="1">{
                                                isAfterDot := len(output) &gt; 0 &amp;&amp; output[len(output)-1][0] == ":dot"
                                                if !isAfterDot </span><span class="cov1" title="1">{
                                                        output = append(output, lexerComparisonContains)
                                                }</span> else<span class="cov0" title="0"> {
                                                        output = append(output, Token{tokenType, t})
                                                }</span>
                                        } else<span class="cov9" title="167"> {
                                                output = append(output, Token{tokenType, t})
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return nil, raiseSyntaxError(startPos, ss)
                                }</span>
                        } else<span class="cov3" title="6"> {
                                return nil, raiseSyntaxError(startPos, ss)
                        }</span>
                }
        }

        <span class="cov8" title="118">output = append(output, lexerEOS)
        return output, nil</span>
}

// Tokenize is a convenience function that tokenizes a string scanner.
func Tokenize(ss *StringScanner) ([]Token, error) <span class="cov8" title="124">{
        lexer := &amp;Lexer{}
        return lexer.Tokenize(ss)
}</span>

func getSpecialToken(b byte) Token <span class="cov9" title="276">{
        switch b </span>{
        case '|':<span class="cov5" title="15">
                return lexerPipe</span>
        case '.':<span class="cov5" title="20">
                return lexerDot</span>
        case ':':<span class="cov3" title="6">
                return lexerColon</span>
        case ',':<span class="cov3" title="4">
                return lexerComma</span>
        case '[':<span class="cov5" title="18">
                return lexerOpenSquare</span>
        case ']':<span class="cov5" title="16">
                return lexerCloseSquare</span>
        case '(':<span class="cov4" title="7">
                return lexerOpenRound</span>
        case ')':<span class="cov3" title="6">
                return lexerCloseRound</span>
        case '?':<span class="cov1" title="1">
                return lexerQuestion</span>
        case '-':<span class="cov1" title="1">
                return lexerDash</span>
        default:<span class="cov9" title="182">
                return Token{}</span>
        }
}

func getTwoCharsComparisonToken(b byte) map[byte]Token <span class="cov9" title="182">{
        switch b </span>{
        case '=':<span class="cov2" title="2">
                return map[byte]Token{
                        '=': lexerComparisonEqual,
                }</span>
        case '!':<span class="cov1" title="1">
                return map[byte]Token{
                        '=': lexerComparisonNotEqual,
                }</span>
        default:<span class="cov9" title="179">
                return nil</span>
        }
}

func getComparisonToken(b byte) map[byte]Token <span class="cov9" title="179">{
        switch b </span>{
        case '&lt;':<span class="cov2" title="3">
                return map[byte]Token{
                        '=': lexerComparisonLessThanOrEqual,
                        '&gt;': lexerComparisonNotEqualAlt,
                }</span>
        case '&gt;':<span class="cov2" title="2">
                return map[byte]Token{
                        '=': lexerComparisonGreaterThanOrEqual,
                }</span>
        default:<span class="cov9" title="174">
                return nil</span>
        }
}

func getSingleComparisonToken(b byte) Token <span class="cov2" title="2">{
        switch b </span>{
        case '&lt;':<span class="cov1" title="1">
                return lexerComparisonLessThan</span>
        case '&gt;':<span class="cov1" title="1">
                return lexerComparisonGreaterThan</span>
        default:<span class="cov0" title="0">
                return Token{}</span>
        }
}

func getNextMatcherToken(b byte) []interface{} <span class="cov9" title="174">{
        if (b &gt;= 'a' &amp;&amp; b &lt;= 'z') || (b &gt;= 'A' &amp;&amp; b &lt;= 'Z') || b == '_' </span><span class="cov8" title="138">{
                return []interface{}{":id", lexerIdentifier}
        }</span>
        <span class="cov6" title="36">if (b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-' </span><span class="cov6" title="25">{
                return []interface{}{":number", lexerNumberLiteral}
        }</span>
        <span class="cov4" title="11">if b == '\'' </span><span class="cov0" title="0">{
                return []interface{}{":string", lexerSingleStringLiteral}
        }</span>
        <span class="cov4" title="11">if b == '"' </span><span class="cov3" title="5">{
                return []interface{}{":string", lexerDoubleStringLiteral}
        }</span>
        <span class="cov3" title="6">return nil</span>
}

func isNumberByte(b byte) bool <span class="cov1" title="1">{
        return b &gt;= '0' &amp;&amp; b &lt;= '9'
}</span>

func raiseSyntaxError(startPos int, ss *StringScanner) error <span class="cov3" title="6">{
        ss.SetPos(startPos)
        char := ss.Getch()
        return NewSyntaxError("Unexpected character " + char)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package liquid

// ParseContextOptions configures a ParseContext.
type ParseContextOptions struct {
        Environment     *Environment
        Locale          *I18n
        ExpressionCache map[string]interface{}
        TemplateOptions map[string]interface{}
        ErrorMode       string
}

// ParseContext represents the context during template parsing.
type ParseContext struct {
        environment     *Environment
        locale          *I18n
        lineNumber      *int
        stringScanner   *StringScanner
        expressionCache map[string]interface{}
        templateOptions map[string]interface{}
        partialOptions  map[string]interface{}
        errorMode       string
        warnings        []error
        depth           int
        trimWhitespace  bool
        partial         bool
}

// NewParseContext creates a new ParseContext.
func NewParseContext(options ParseContextOptions) *ParseContext <span class="cov9" title="103">{
        env := options.Environment
        if env == nil </span><span class="cov8" title="70">{
                env = NewEnvironment()
        }</span>

        <span class="cov9" title="103">locale := options.Locale
        if locale == nil </span><span class="cov9" title="102">{
                locale = NewI18n("en")
        }</span>

        <span class="cov9" title="103">errorMode := options.ErrorMode
        if errorMode == "" </span><span class="cov9" title="88">{
                errorMode = env.ErrorMode()
        }</span>

        <span class="cov9" title="103">templateOptions := options.TemplateOptions
        if templateOptions == nil </span><span class="cov9" title="74">{
                templateOptions = make(map[string]interface{})
        }</span>

        <span class="cov9" title="103">pc := &amp;ParseContext{
                environment:     env,
                locale:          locale,
                warnings:        []error{},
                errorMode:       errorMode,
                lineNumber:      nil,
                trimWhitespace:  false,
                depth:           0,
                partial:         false,
                stringScanner:   NewStringScanner(""),
                expressionCache: options.ExpressionCache,
                templateOptions: templateOptions,
        }

        if pc.expressionCache == nil </span><span class="cov9" title="103">{
                pc.expressionCache = make(map[string]interface{})
        }</span>

        <span class="cov9" title="103">return pc</span>
}

// Environment returns the environment.
func (pc *ParseContext) Environment() *Environment <span class="cov7" title="31">{
        return pc.environment
}</span>

// Locale returns the locale.
func (pc *ParseContext) Locale() *I18n <span class="cov6" title="16">{
        return pc.locale
}</span>

// Warnings returns the warnings.
func (pc *ParseContext) Warnings() []error <span class="cov7" title="25">{
        return pc.warnings
}</span>

// AddWarning adds a warning.
func (pc *ParseContext) AddWarning(warning error) <span class="cov1" title="1">{
        pc.warnings = append(pc.warnings, warning)
}</span>

// ErrorMode returns the error mode.
func (pc *ParseContext) ErrorMode() string <span class="cov8" title="43">{
        return pc.errorMode
}</span>

// LineNumber returns the line number.
func (pc *ParseContext) LineNumber() *int <span class="cov10" title="125">{
        return pc.lineNumber
}</span>

// SetLineNumber sets the line number.
func (pc *ParseContext) SetLineNumber(ln *int) <span class="cov10" title="125">{
        pc.lineNumber = ln
}</span>

// TrimWhitespace returns whether to trim whitespace.
func (pc *ParseContext) TrimWhitespace() bool <span class="cov7" title="28">{
        return pc.trimWhitespace
}</span>

// SetTrimWhitespace sets whether to trim whitespace.
func (pc *ParseContext) SetTrimWhitespace(tw bool) <span class="cov7" title="30">{
        pc.trimWhitespace = tw
}</span>

// Depth returns the depth.
func (pc *ParseContext) Depth() int <span class="cov5" title="11">{
        return pc.depth
}</span>

// IncrementDepth increments the depth.
func (pc *ParseContext) IncrementDepth() <span class="cov9" title="108">{
        pc.depth++
}</span>

// DecrementDepth decrements the depth.
func (pc *ParseContext) DecrementDepth() <span class="cov4" title="8">{
        pc.depth--
}</span>

// Partial returns whether this is a partial parse.
func (pc *ParseContext) Partial() bool <span class="cov2" title="2">{
        return pc.partial
}</span>

// SetPartial sets whether this is a partial parse.
func (pc *ParseContext) SetPartial(partial bool) <span class="cov4" title="8">{
        pc.partial = partial
        if partial </span><span class="cov4" title="6">{
                pc.partialOptions = pc.computePartialOptions()
                // Update error mode from partial options
                if mode, ok := pc.partialOptions["error_mode"].(string); ok </span><span class="cov0" title="0">{
                        pc.errorMode = mode
                }</span> else<span class="cov4" title="6"> {
                        pc.errorMode = pc.environment.ErrorMode()
                }</span>
        } else<span class="cov2" title="2"> {
                pc.partialOptions = nil
                pc.errorMode = pc.environment.ErrorMode()
        }</span>
}

func (pc *ParseContext) computePartialOptions() map[string]interface{} <span class="cov4" title="6">{
        dontPass := pc.templateOptions["include_options_blacklist"]
        if dontPass == true </span><span class="cov1" title="1">{
                return map[string]interface{}{
                        "locale": pc.locale,
                }
        }</span>
        <span class="cov4" title="5">if blacklist, ok := dontPass.([]string); ok </span><span class="cov1" title="1">{
                result := make(map[string]interface{})
                for k, v := range pc.templateOptions </span><span class="cov3" title="3">{
                        shouldInclude := true
                        for _, blacklisted := range blacklist </span><span class="cov3" title="3">{
                                if k == blacklisted </span><span class="cov1" title="1">{
                                        shouldInclude = false
                                        break</span>
                                }
                        }
                        <span class="cov3" title="3">if shouldInclude </span><span class="cov2" title="2">{
                                result[k] = v
                        }</span>
                }
                <span class="cov1" title="1">return result</span>
        }
        <span class="cov3" title="4">return pc.templateOptions</span>
}

// GetOption gets an option value.
func (pc *ParseContext) GetOption(key string) interface{} <span class="cov4" title="7">{
        if pc.partial &amp;&amp; pc.partialOptions != nil </span><span class="cov4" title="5">{
                return pc.partialOptions[key]
        }</span>
        <span class="cov2" title="2">return pc.templateOptions[key]</span>
}

// NewBlockBody creates a new BlockBody.
func (pc *ParseContext) NewBlockBody() *BlockBody <span class="cov7" title="41">{
        return NewBlockBody()
}</span>

// NewParser creates a new Parser with the shared StringScanner.
func (pc *ParseContext) NewParser(input string) *Parser <span class="cov8" title="46">{
        pc.stringScanner.SetString(input)
        // Create parser from scanner (it will tokenize the scanner's string)
        return NewParser(pc.stringScanner)
}</span>

// NewTokenizer creates a new Tokenizer with the shared StringScanner.
func (pc *ParseContext) NewTokenizer(source string, lineNumbers bool, startLineNumber *int, forLiquidTag bool) *Tokenizer <span class="cov8" title="58">{
        return NewTokenizer(source, pc.stringScanner, lineNumbers, startLineNumber, forLiquidTag)
}</span>

// SafeParseExpression safely parses an expression.
// In strict/rigid mode, errors are propagated. In lax mode, errors return nil.
func (pc *ParseContext) SafeParseExpression(parser *Parser) interface{} <span class="cov8" title="47">{
        // In strict/rigid mode, we need to propagate errors
        if pc.errorMode == "strict" || pc.errorMode == "rigid" </span><span class="cov5" title="12">{
                expr, err := parser.Expression()
                if err != nil </span><span class="cov2" title="2">{
                        // Don't add markup context here - let ParserSwitching handle it
                        panic(err)</span>
                }
                <span class="cov5" title="10">return Parse(expr, pc.stringScanner, pc.expressionCache)</span>
        }
        // In lax mode, swallow errors
        <span class="cov7" title="35">return SafeParse(parser, pc.stringScanner, pc.expressionCache)</span>
}

// ParseExpression parses an expression.
func (pc *ParseContext) ParseExpression(markup string) interface{} <span class="cov5" title="14">{
        return Parse(markup, pc.stringScanner, pc.expressionCache)
}</span>

// ParseExpressionSafe parses an expression with safe flag.
func (pc *ParseContext) ParseExpressionSafe(markup string, safe bool) interface{} <span class="cov3" title="3">{
        if !safe &amp;&amp; pc.errorMode == "rigid" </span><span class="cov1" title="1">{
                panic(NewInternalError("unsafe parse_expression cannot be used in rigid mode"))</span>
        }
        <span class="cov2" title="2">return Parse(markup, pc.stringScanner, pc.expressionCache)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package liquid

import "reflect"

// ParseTreeVisitorCallback is a function type for visitor callbacks.
type ParseTreeVisitorCallback func(node interface{}, context interface{}) (interface{}, interface{})

// ParseTreeVisitor visits nodes in a parse tree.
type ParseTreeVisitor struct {
        node      interface{}
        callbacks map[reflect.Type]ParseTreeVisitorCallback
}

// NewParseTreeVisitor creates a new ParseTreeVisitor.
func NewParseTreeVisitor(node interface{}, callbacks map[reflect.Type]ParseTreeVisitorCallback) *ParseTreeVisitor <span class="cov10" title="21">{
        if callbacks == nil </span><span class="cov7" title="10">{
                callbacks = make(map[reflect.Type]ParseTreeVisitorCallback)
        }</span>
        <span class="cov10" title="21">return &amp;ParseTreeVisitor{
                node:      node,
                callbacks: callbacks,
        }</span>
}

// For creates a ParseTreeVisitor for a node, using node-specific visitor if available.
func ForParseTreeVisitor(node interface{}, callbacks map[reflect.Type]ParseTreeVisitorCallback) *ParseTreeVisitor <span class="cov8" title="12">{
        nodeType := reflect.TypeOf(node)
        if nodeType == nil </span><span class="cov1" title="1">{
                return NewParseTreeVisitor(node, callbacks)
        }</span>

        // Check for node-specific ParseTreeVisitor type
        // In Ruby: if defined?(node.class::ParseTreeVisitor)
        // In Go, we check if the node type has a method that returns a ParseTreeVisitor constructor
        <span class="cov8" title="11">nodeValue := reflect.ValueOf(node)
        if nodeValue.IsValid() </span><span class="cov8" title="11">{
                // Check if there's a method that can create a node-specific visitor
                // Some node types might have a ParseTreeVisitorType method or similar
                // For now, we'll use the default visitor, but check for node-specific implementations
                // by looking for a method that returns *ParseTreeVisitor
                parseTreeVisitorMethod := nodeValue.MethodByName("ParseTreeVisitor")
                if parseTreeVisitorMethod.IsValid() </span><span class="cov1" title="1">{
                        results := parseTreeVisitorMethod.Call([]reflect.Value{reflect.ValueOf(callbacks)})
                        if len(results) &gt; 0 </span><span class="cov1" title="1">{
                                if ptv, ok := results[0].Interface().(*ParseTreeVisitor); ok </span><span class="cov1" title="1">{
                                        return ptv
                                }</span>
                        }
                }
        }

        // Use default visitor
        <span class="cov7" title="10">return NewParseTreeVisitor(node, callbacks)</span>
}

// AddCallbackFor adds a callback for specific node types.
func (ptv *ParseTreeVisitor) AddCallbackFor(types []interface{}, callback ParseTreeVisitorCallback) *ParseTreeVisitor <span class="cov5" title="4">{
        for _, t := range types </span><span class="cov5" title="5">{
                typ := reflect.TypeOf(t)
                if typ != nil </span><span class="cov5" title="4">{
                        ptv.callbacks[typ] = callback
                }</span>
        }
        <span class="cov5" title="4">return ptv</span>
}

// Visit visits the parse tree and returns results.
func (ptv *ParseTreeVisitor) Visit(context interface{}) []interface{} <span class="cov8" title="14">{
        children := ptv.children()
        result := make([]interface{}, 0, len(children))

        for _, child := range children </span><span class="cov7" title="9">{
                childType := reflect.TypeOf(child)
                callback, ok := ptv.callbacks[childType]
                if !ok </span><span class="cov4" title="3">{
                        // Default callback: return node as-is
                        callback = func(node interface{}, ctx interface{}) (interface{}, interface{}) </span><span class="cov4" title="3">{
                                return node, ctx
                        }</span>
                }

                <span class="cov7" title="9">item, newContext := callback(child, context)
                childVisitor := ForParseTreeVisitor(child, ptv.callbacks)
                childResults := childVisitor.Visit(newContext)

                result = append(result, []interface{}{item, childResults})</span>
        }

        <span class="cov8" title="14">return result</span>
}

func (ptv *ParseTreeVisitor) children() []interface{} <span class="cov9" title="16">{
        // Check if node has Nodelist method
        nodeValue := reflect.ValueOf(ptv.node)
        if !nodeValue.IsValid() </span><span class="cov0" title="0">{
                return EMPTY_ARRAY
        }</span>

        <span class="cov9" title="16">nodelistMethod := nodeValue.MethodByName("Nodelist")
        if nodelistMethod.IsValid() </span><span class="cov6" title="6">{
                result := nodelistMethod.Call(nil)
                if len(result) &gt; 0 </span><span class="cov6" title="6">{
                        if nodelist, ok := result[0].Interface().([]interface{}); ok </span><span class="cov6" title="6">{
                                return nodelist
                        }</span>
                }
        }

        <span class="cov7" title="10">return EMPTY_ARRAY</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package liquid

import (
        "fmt"
        "strings"
)

// Parser parses expressions from tokens.
type Parser struct {
        tokens []Token
        p      int // pointer to current location
}

// NewParser creates a new parser from a string scanner or string.
func NewParser(input interface{}) *Parser <span class="cov8" title="109">{
        var ss *StringScanner
        switch v := input.(type) </span>{
        case *StringScanner:<span class="cov7" title="47">
                ss = v</span>
        case string:<span class="cov7" title="61">
                ss = NewStringScanner(v)</span>
        default:<span class="cov1" title="1">
                ss = NewStringScanner(fmt.Sprintf("%v", v))</span>
        }

        <span class="cov8" title="109">tokens, err := Tokenize(ss)
        if err != nil </span><span class="cov3" title="6">{
                // If tokenization fails, create parser with empty tokens
                tokens = []Token{lexerEOS}
        }</span>

        <span class="cov8" title="109">return &amp;Parser{
                tokens: tokens,
                p:      0,
        }</span>
}

// Jump sets the parser position to the given point.
func (p *Parser) Jump(point int) <span class="cov2" title="2">{
        p.p = point
}</span>

// Consume consumes a token of the given type (or any type if nil).
func (p *Parser) Consume(tokenType interface{}) (string, error) <span class="cov9" title="261">{
        if p.p &gt;= len(p.tokens) </span><span class="cov0" title="0">{
                return "", NewSyntaxError("Unexpected end of expression")
        }</span>

        <span class="cov9" title="261">token := p.tokens[p.p]
        if tokenType != nil </span><span class="cov9" title="261">{
                expectedType := tokenType.(string)
                if token[0] != expectedType </span><span class="cov3" title="4">{
                        // Format error message: remove colon prefix from token types for user-friendly message
                        expectedStr := expectedType
                        if len(expectedStr) &gt; 0 &amp;&amp; expectedStr[0] == ':' </span><span class="cov3" title="4">{
                                expectedStr = expectedStr[1:]
                        }</span>
                        <span class="cov3" title="4">foundStr := fmt.Sprintf("%v", token[0])
                        if len(foundStr) &gt; 0 &amp;&amp; foundStr[0] == ':' </span><span class="cov3" title="4">{
                                foundStr = foundStr[1:]
                        }</span>
                        <span class="cov3" title="4">return "", NewSyntaxError(fmt.Sprintf("Expected %s but found %s", expectedStr, foundStr))</span>
                }
        }

        <span class="cov9" title="257">p.p++
        if token[1] == nil </span><span class="cov7" title="55">{
                return "", nil
        }</span>
        <span class="cov9" title="202">return fmt.Sprintf("%v", token[1]), nil</span>
}

// ConsumeOptional consumes a token if it matches the type, returns false otherwise.
func (p *Parser) ConsumeOptional(tokenType string) (string, bool) <span class="cov8" title="92">{
        if p.p &gt;= len(p.tokens) </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov8" title="92">token := p.tokens[p.p]
        if token[0] != tokenType </span><span class="cov7" title="72">{
                return "", false
        }</span>

        <span class="cov5" title="20">p.p++
        if token[1] == nil </span><span class="cov0" title="0">{
                return "", true
        }</span>
        <span class="cov5" title="20">return fmt.Sprintf("%v", token[1]), true</span>
}

// ID checks if the next token is an identifier with the given name.
func (p *Parser) ID(str string) (string, bool) <span class="cov2" title="3">{
        if p.p &gt;= len(p.tokens) </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov2" title="3">token := p.tokens[p.p]
        if token[0] != ":id" </span><span class="cov1" title="1">{
                return "", false
        }</span>

        <span class="cov2" title="2">tokenValue := fmt.Sprintf("%v", token[1])
        if tokenValue != str </span><span class="cov1" title="1">{
                return "", false
        }</span>

        <span class="cov1" title="1">p.p++
        return tokenValue, true</span>
}

// Look checks if a token of the given type is at the current position (or ahead).
func (p *Parser) Look(tokenType string, ahead int) bool <span class="cov10" title="301">{
        pos := p.p + ahead
        if pos &gt;= len(p.tokens) </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="300">return p.tokens[pos][0] == tokenType</span>
}

// Expression parses an expression.
func (p *Parser) Expression() (string, error) <span class="cov8" title="126">{
        if p.p &gt;= len(p.tokens) </span><span class="cov0" title="0">{
                return "", NewSyntaxError("Unexpected end of expression")
        }</span>

        <span class="cov8" title="126">token := p.tokens[p.p]
        tokenType := fmt.Sprintf("%v", token[0])

        switch tokenType </span>{
        case ":id":<span class="cov7" title="81">
                str, err := p.Consume(":id")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov7" title="81">lookups, err := p.VariableLookups()
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>
                <span class="cov7" title="80">return str + lookups, nil</span>
        case ":open_square":<span class="cov3" title="6">
                str, err := p.Consume(":open_square")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="6">expr, err := p.Expression()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="6">str += expr
                closeSquare, err := p.Consume(":close_square")
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>
                <span class="cov3" title="5">str += closeSquare
                lookups, err := p.VariableLookups()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="5">return str + lookups, nil</span>
        case ":string", ":number":<span class="cov6" title="25">
                return p.Consume(tokenType)</span>
        case ":open_round":<span class="cov3" title="6">
                _, err := p.Consume(":open_round")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="6">first, err := p.Expression()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="6">_, err = p.Consume(":dotdot")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="6">last, err := p.Expression()
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>
                <span class="cov3" title="5">_, err = p.Consume(":close_round")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="5">return fmt.Sprintf("(%s..%s)", first, last), nil</span>
        default:<span class="cov4" title="8">
                return "", NewSyntaxError(fmt.Sprintf("%v is not a valid expression", token))</span>
        }
}

// Argument parses an argument (possibly a keyword argument).
func (p *Parser) Argument() (string, error) <span class="cov4" title="9">{
        var b strings.Builder

        // Check for keyword argument (identifier: expression)
        if p.Look(":id", 0) &amp;&amp; p.Look(":colon", 1) </span><span class="cov1" title="1">{
                id, _ := p.Consume(":id")
                colon, _ := p.Consume(":colon")
                b.WriteString(id)
                b.WriteString(colon)
                b.WriteString(" ")
        }</span>

        <span class="cov4" title="9">expr, err := p.Expression()
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov4" title="8">b.WriteString(expr)
        return b.String(), nil</span>
}

// VariableLookups parses variable lookups (dots and brackets).
func (p *Parser) VariableLookups() (string, error) <span class="cov8" title="86">{
        var b strings.Builder

        for </span><span class="cov8" title="107">{
                if p.Look(":open_square", 0) </span><span class="cov4" title="10">{
                        open, err := p.Consume(":open_square")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov4" title="10">b.WriteString(open)
                        expr, err := p.Expression()
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov4" title="10">b.WriteString(expr)
                        closeSquare, err := p.Consume(":close_square")
                        if err != nil </span><span class="cov1" title="1">{
                                return "", err
                        }</span>
                        <span class="cov4" title="9">b.WriteString(closeSquare)</span>
                } else<span class="cov8" title="97"> if p.Look(":dot", 0) </span><span class="cov4" title="12">{
                        dot, err := p.Consume(":dot")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov4" title="12">b.WriteString(dot)
                        id, err := p.Consume(":id")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov4" title="12">b.WriteString(id)</span>
                } else<span class="cov8" title="85"> {
                        break</span>
                }
        }

        <span class="cov8" title="85">return b.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package liquid

import "strings"

// ParserSwitching provides methods for switching between different parsing modes.
// This is typically embedded in types that need parsing functionality.
type ParserSwitching struct {
        parseContext interface {
                ErrorMode() string
                AddWarning(error)
        }
        lineNumber    *int
        markupContext func(string) string
}

// ParseWithSelectedParser parses markup using the parser selected by error mode.
func (p *ParserSwitching) ParseWithSelectedParser(markup string, strictParse, laxParse, rigidParse func(string) error) error <span class="cov5" title="7">{
        errorMode := p.parseContext.ErrorMode()

        switch errorMode </span>{
        case "rigid":<span class="cov1" title="1">
                return p.rigidParseWithErrorContext(markup, rigidParse)</span>
        case "strict":<span class="cov2" title="2">
                return p.strictParseWithErrorContext(markup, strictParse)</span>
        case "lax":<span class="cov1" title="1">
                return laxParse(markup)</span>
        case "warn":<span class="cov2" title="2">
                err := p.rigidParseWithErrorContext(markup, rigidParse)
                if err != nil </span><span class="cov2" title="2">{
                        if syntaxErr, ok := err.(*SyntaxError); ok </span><span class="cov1" title="1">{
                                p.parseContext.AddWarning(syntaxErr)
                                return laxParse(markup)
                        }</span>
                        <span class="cov1" title="1">return err</span>
                }
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov1" title="1">
                return laxParse(markup)</span>
        }
}

// StrictParseWithErrorModeFallback is deprecated. Use ParseWithSelectedParser instead.
func (p *ParserSwitching) StrictParseWithErrorModeFallback(markup string, strictParse, laxParse, rigidParse func(string) error) error <span class="cov10" title="60">{
        if p.parseContext.ErrorMode() == "rigid" </span><span class="cov5" title="7">{
                return p.rigidParseWithErrorContext(markup, rigidParse)
        }</span>

        <span class="cov9" title="53">err := p.strictParseWithErrorContext(markup, strictParse)
        if err != nil </span><span class="cov4" title="4">{
                if syntaxErr, ok := err.(*SyntaxError); ok </span><span class="cov3" title="3">{
                        errorMode := p.parseContext.ErrorMode()
                        switch errorMode </span>{
                        case "rigid", "strict":<span class="cov1" title="1">
                                return err</span>
                        case "warn":<span class="cov1" title="1">
                                p.parseContext.AddWarning(syntaxErr)</span>
                        }
                        <span class="cov2" title="2">return laxParse(markup)</span>
                }
                <span class="cov1" title="1">return err</span>
        }
        <span class="cov9" title="49">return nil</span>
}

// RigidMode returns true if error mode is rigid.
func (p *ParserSwitching) RigidMode() bool <span class="cov2" title="2">{
        return p.parseContext.ErrorMode() == "rigid"
}</span>

func (p *ParserSwitching) rigidParseWithErrorContext(markup string, rigidParse func(string) error) error <span class="cov6" title="10">{
        err := rigidParse(markup)
        if err != nil </span><span class="cov2" title="2">{
                if syntaxErr, ok := err.(*SyntaxError); ok </span><span class="cov1" title="1">{
                        if p.lineNumber != nil </span><span class="cov0" title="0">{
                                syntaxErr.Err.LineNumber = p.lineNumber
                        }</span>
                        <span class="cov1" title="1">if p.markupContext != nil </span><span class="cov0" title="0">{
                                syntaxErr.Err.MarkupContext = p.markupContext(markup)
                        }</span>
                        <span class="cov1" title="1">return syntaxErr</span>
                }
                <span class="cov1" title="1">return err</span>
        }
        <span class="cov5" title="8">return nil</span>
}

func (p *ParserSwitching) strictParseWithErrorContext(markup string, strictParse func(string) error) error <span class="cov9" title="55">{
        err := strictParse(markup)
        if err != nil </span><span class="cov4" title="5">{
                if syntaxErr, ok := err.(*SyntaxError); ok </span><span class="cov4" title="4">{
                        if p.lineNumber != nil </span><span class="cov1" title="1">{
                                syntaxErr.Err.LineNumber = p.lineNumber
                        }</span>
                        <span class="cov4" title="4">if p.markupContext != nil </span><span class="cov1" title="1">{
                                syntaxErr.Err.MarkupContext = p.markupContext(markup)
                        }</span>
                        <span class="cov4" title="4">return syntaxErr</span>
                }
                <span class="cov1" title="1">return err</span>
        }
        <span class="cov9" title="50">return nil</span>
}

// MarkupContext returns a context string for markup.
func MarkupContext(markup string) string <span class="cov3" title="3">{
        return "in \"" + strings.TrimSpace(markup) + "\""
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package liquid

// PartialCache provides caching for partial templates.
type PartialCache struct{}

// Load loads a partial template from cache or file system.
func (pc *PartialCache) Load(templateName string, context interface {
        Registers() *Registers
}, parseContext ParseContextInterface) (interface{}, error) <span class="cov10" title="3">{
        registers := context.Registers()
        cachedPartials := registers.Get("cached_partials")

        var cache map[string]interface{}
        if cp, ok := cachedPartials.(map[string]interface{}); ok </span><span class="cov10" title="3">{
                cache = cp
        }</span> else<span class="cov0" title="0"> {
                cache = make(map[string]interface{})
                registers.Set("cached_partials", cache)
        }</span>

        // Create cache key
        <span class="cov10" title="3">errorMode := "lax" // Default
        if env := parseContext.Environment(); env != nil </span><span class="cov10" title="3">{
                errorMode = env.ErrorMode()
        }</span>
        <span class="cov10" title="3">cacheKey := templateName + ":" + errorMode

        // Check cache
        if cached, ok := cache[cacheKey]; ok </span><span class="cov0" title="0">{
                return cached, nil
        }</span>

        // Load from file system
        <span class="cov10" title="3">fileSystem := registers.Get("file_system")
        var fs FileSystem
        if f, ok := fileSystem.(FileSystem); ok </span><span class="cov10" title="3">{
                fs = f
        }</span> else<span class="cov0" title="0"> {
                fs = &amp;BlankFileSystem{}
        }</span>

        <span class="cov10" title="3">source, err := fs.ReadTemplateFile(templateName)
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        // Set partial flag
        <span class="cov1" title="1">if pc, ok := parseContext.(*ParseContext); ok </span><span class="cov1" title="1">{
                pc.SetPartial(true)
                defer pc.SetPartial(false)
        }</span>

        // Get template factory
        <span class="cov1" title="1">templateFactory := registers.Get("template_factory")
        var tf *TemplateFactory
        if t, ok := templateFactory.(*TemplateFactory); ok </span><span class="cov1" title="1">{
                tf = t
        }</span> else<span class="cov0" title="0"> {
                tf = NewTemplateFactory()
        }</span>

        // Get template instance
        <span class="cov1" title="1">template := tf.For(templateName)
        var tmpl *Template
        if t, ok := template.(*Template); ok </span><span class="cov1" title="1">{
                tmpl = t
        }</span> else<span class="cov0" title="0"> {
                return nil, NewFileSystemError("template factory returned invalid template")
        }</span>

        // Parse the template
        <span class="cov1" title="1">parseOptions := &amp;TemplateOptions{}
        if pc, ok := parseContext.(*ParseContext); ok </span><span class="cov1" title="1">{
                parseOptions.Environment = pc.Environment()
        }</span>
        <span class="cov1" title="1">err = tmpl.Parse(source, parseOptions)
        if err != nil </span><span class="cov0" title="0">{
                // Set template name on error if available
                if liquidErr, ok := err.(*Error); ok </span><span class="cov0" title="0">{
                        if tmpl.Name() == "" </span><span class="cov0" title="0">{
                                liquidErr.TemplateName = templateName
                        }</span> else<span class="cov0" title="0"> {
                                liquidErr.TemplateName = tmpl.Name()
                        }</span>
                }
                <span class="cov0" title="0">return nil, err</span>
        }

        // Set name if not already set
        <span class="cov1" title="1">if tmpl.Name() == "" </span><span class="cov1" title="1">{
                tmpl.SetName(templateName)
        }</span>

        // Cache the partial
        <span class="cov1" title="1">cache[cacheKey] = tmpl

        return tmpl, nil</span>
}

// LoadPartial is a convenience function to load a partial.
func LoadPartial(templateName string, context interface {
        Registers() *Registers
}, parseContext ParseContextInterface) (interface{}, error) <span class="cov1" title="1">{
        pc := &amp;PartialCache{}
        return pc.Load(templateName, context, parseContext)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package liquid

import (
        "time"
)

// Profiler enables support for profiling template rendering to help track down performance issues.
//
// To enable profiling, pass Profile: true option to Template.Parse.
// After Template.Render is called, the template object makes available an instance of this
// class via the Template.Profiler() method.
//
// This object contains all profiling information, containing information on what tags were rendered,
// where in the templates these tags live, and how long each tag took to render.
//
// This is a tree structure that keeps track of tags and rendering times
// inside of {% include %} tags.
//
// Profiler also exposes the total time of the template's render in Profiler.TotalRenderTime().
//
// All render times are in seconds. There is a small performance hit when profiling is enabled.
type Profiler struct {
        currentChildren *[]*Timing
        rootChildren    []*Timing
        totalTime       float64
}

// Timing represents a single timing node in the profiler tree.
type Timing struct {
        lineNumber   *int
        selfTime     *float64
        code         string
        templateName string
        children     []*Timing
        totalTime    float64
}

// NewProfiler creates a new Profiler instance.
func NewProfiler() *Profiler <span class="cov8" title="11">{
        return &amp;Profiler{
                rootChildren:    []*Timing{},
                currentChildren: nil,
                totalTime:       0.0,
        }
}</span>

// Profile profiles a template render.
// Nested renders are done from a tag that already has a timing node.
func (p *Profiler) Profile(templateName string, fn func()) <span class="cov7" title="8">{
        if p.currentChildren != nil </span><span class="cov0" title="0">{
                // Already profiling, just execute
                fn()
                return
        }</span>

        <span class="cov7" title="8">renderIdx := len(p.rootChildren)
        p.currentChildren = &amp;p.rootChildren
        defer func() </span><span class="cov7" title="8">{
                p.currentChildren = nil
                if renderIdx &lt; len(p.rootChildren) </span><span class="cov7" title="8">{
                        if timing := p.rootChildren[renderIdx]; timing != nil </span><span class="cov7" title="8">{
                                p.totalTime += timing.totalTime
                        }</span>
                }
        }()

        // Profile the entire template render as a node
        <span class="cov7" title="8">p.ProfileNode(templateName, "", nil, fn)</span>
}

// ProfileNode profiles a single node (tag or variable).
func (p *Profiler) ProfileNode(templateName, code string, lineNumber *int, fn func()) <span class="cov10" title="17">{
        timing := &amp;Timing{
                code:         code,
                templateName: templateName,
                lineNumber:   lineNumber,
                children:     []*Timing{},
        }

        // Store pointer to parent children slice for appending
        parentChildrenRef := p.currentChildren
        if parentChildrenRef == nil </span><span class="cov3" title="2">{
                parentChildrenRef = &amp;p.rootChildren
        }</span>

        <span class="cov10" title="17">startTime := time.Now()
        p.currentChildren = &amp;timing.children
        defer func() </span><span class="cov10" title="17">{
                timing.totalTime = time.Since(startTime).Seconds()
                *parentChildrenRef = append(*parentChildrenRef, timing)
                p.currentChildren = parentChildrenRef
        }</span>()

        <span class="cov10" title="17">fn()</span>
}

// Children returns the profiler children.
// If there's only one child, return its children instead (to skip the root wrapper).
func (p *Profiler) Children() []*Timing <span class="cov8" title="12">{
        children := p.rootChildren
        if len(children) == 1 &amp;&amp; children[0] != nil </span><span class="cov8" title="11">{
                return children[0].children
        }</span>
        <span class="cov1" title="1">return children</span>
}

// Length returns the number of children.
func (p *Profiler) Length() int <span class="cov7" title="7">{
        return len(p.Children())
}</span>

// At returns the child at the given index.
func (p *Profiler) At(idx int) *Timing <span class="cov6" title="5">{
        children := p.Children()
        if idx &lt; 0 || idx &gt;= len(children) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov6" title="5">return children[idx]</span>
}

// TotalTime returns the total render time in seconds.
func (p *Profiler) TotalTime() float64 <span class="cov5" title="4">{
        return p.totalTime
}</span>

// TotalRenderTime returns the total render time (alias for TotalTime).
func (p *Profiler) TotalRenderTime() float64 <span class="cov1" title="1">{
        return p.totalTime
}</span>

// Code returns the code for this timing node.
func (t *Timing) Code() string <span class="cov1" title="1">{
        return t.code
}</span>

// TemplateName returns the template name for this timing node.
func (t *Timing) TemplateName() string <span class="cov3" title="2">{
        return t.templateName
}</span>

// Partial returns the template name (alias for TemplateName).
func (t *Timing) Partial() string <span class="cov1" title="1">{
        return t.templateName
}</span>

// LineNumber returns the line number for this timing node.
func (t *Timing) LineNumber() *int <span class="cov3" title="2">{
        return t.lineNumber
}</span>

// Children returns the children of this timing node.
func (t *Timing) Children() []*Timing <span class="cov1" title="1">{
        return t.children
}</span>

// TotalTime returns the total time for this timing node in seconds.
func (t *Timing) TotalTime() float64 <span class="cov3" title="2">{
        return t.totalTime
}</span>

// RenderTime returns the render time (alias for TotalTime).
func (t *Timing) RenderTime() float64 <span class="cov1" title="1">{
        return t.totalTime
}</span>

// SelfTime returns the self time (total time minus children time).
func (t *Timing) SelfTime() float64 <span class="cov1" title="1">{
        if t.selfTime != nil </span><span class="cov0" title="0">{
                return *t.selfTime
        }</span>

        <span class="cov1" title="1">totalChildrenTime := 0.0
        for _, child := range t.children </span><span class="cov1" title="1">{
                totalChildrenTime += child.totalTime
        }</span>

        <span class="cov1" title="1">selfTime := t.totalTime - totalChildrenTime
        t.selfTime = &amp;selfTime
        return selfTime</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package liquid

import (
        "fmt"
        "strconv"
)

// RangeLookup represents a range lookup expression (start..end).
type RangeLookup struct {
        startObj interface{}
        endObj   interface{}
}

// StartObj returns the start object.
func (rl *RangeLookup) StartObj() interface{} <span class="cov3" title="2">{
        return rl.startObj
}</span>

// EndObj returns the end object.
func (rl *RangeLookup) EndObj() interface{} <span class="cov3" title="2">{
        return rl.endObj
}</span>

// Range represents a simple integer range.
type Range struct {
        Start int
        End   int
}

// String returns the string representation of the range (e.g., "1..5").
func (r *Range) String() string <span class="cov3" title="2">{
        return fmt.Sprintf("%d..%d", r.Start, r.End)
}</span>

// RangeLookupParse parses start and end markups into a RangeLookup or range.
func RangeLookupParse(startMarkup, endMarkup string, ss *StringScanner, cache map[string]interface{}) interface{} <span class="cov5" title="4">{
        startObj := Parse(startMarkup, ss, cache)
        endObj := Parse(endMarkup, ss, cache)

        // Check if either is an evaluable expression (has Evaluate method)
        // For now, we'll check if they're VariableLookup instances
        if _, ok := startObj.(*VariableLookup); ok </span><span class="cov0" title="0">{
                return NewRangeLookup(startObj, endObj)
        }</span>
        <span class="cov5" title="4">if _, ok := endObj.(*VariableLookup); ok </span><span class="cov0" title="0">{
                return NewRangeLookup(startObj, endObj)
        }</span>

        // Both are primitives, convert to integers and create range
        <span class="cov5" title="4">startInt := toInteger(startObj)
        endInt := toInteger(endObj)

        // Create a simple range representation
        // In Go, we'll use a struct to represent ranges
        return &amp;Range{
                Start: startInt,
                End:   endInt,
        }</span>
}

// NewRangeLookup creates a new RangeLookup.
func NewRangeLookup(startObj, endObj interface{}) *RangeLookup <span class="cov1" title="1">{
        return &amp;RangeLookup{
                startObj: startObj,
                endObj:   endObj,
        }
}</span>

func toInteger(input interface{}) int <span class="cov10" title="15">{
        switch v := input.(type) </span>{
        case int:<span class="cov8" title="9">
                return v</span>
        case int64:<span class="cov1" title="1">
                return int(v)</span>
        case float64:<span class="cov1" title="1">
                return int(v)</span>
        case string:<span class="cov4" title="3">
                // Try to parse as integer
                if val, err := strconv.Atoi(v); err == nil </span><span class="cov1" title="1">{
                        return val
                }</span>
                <span class="cov3" title="2">return 0</span>
        case nil:<span class="cov1" title="1">
                return 0</span>
        default:<span class="cov0" title="0">
                // Try ToInteger utility
                if val, err := ToInteger(input); err == nil </span><span class="cov0" title="0">{
                        return val
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package liquid

// Registers provides a registry for template-level data.
// It supports both static (immutable) and dynamic (mutable) values.
type Registers struct {
        static  map[string]interface{}
        changes map[string]interface{}
}

// NewRegisters creates a new Registers instance.
func NewRegisters(registers interface{}) *Registers <span class="cov8" title="120">{
        var static map[string]interface{}

        if r, ok := registers.(*Registers); ok </span><span class="cov2" title="2">{
                static = r.static
        }</span> else<span class="cov8" title="118"> if m, ok := registers.(map[string]interface{}); ok </span><span class="cov5" title="25">{
                static = m
        }</span> else<span class="cov8" title="93"> {
                static = make(map[string]interface{})
        }</span>

        <span class="cov8" title="120">return &amp;Registers{
                static:  static,
                changes: make(map[string]interface{}),
        }</span>
}

// Set sets a value in the registers (creates a change).
func (r *Registers) Set(key string, value interface{}) <span class="cov10" title="332">{
        r.changes[key] = value
}</span>

// Get gets a value from the registers (checks changes first, then static).
func (r *Registers) Get(key string) interface{} <span class="cov9" title="330">{
        if val, ok := r.changes[key]; ok </span><span class="cov4" title="9">{
                return val
        }</span>
        <span class="cov9" title="321">return r.static[key]</span>
}

// Delete deletes a key from changes.
func (r *Registers) Delete(key string) <span class="cov1" title="1">{
        delete(r.changes, key)
}</span>

// Fetch gets a value with a default or block.
func (r *Registers) Fetch(key string, defaultValue interface{}) interface{} <span class="cov2" title="2">{
        if val, ok := r.changes[key]; ok </span><span class="cov1" title="1">{
                return val
        }</span>
        <span class="cov1" title="1">if val, ok := r.static[key]; ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov1" title="1">return defaultValue</span>
}

// HasKey returns true if the key exists in either changes or static.
func (r *Registers) HasKey(key string) bool <span class="cov2" title="3">{
        _, hasChange := r.changes[key]
        _, hasStatic := r.static[key]
        return hasChange || hasStatic
}</span>

// Static returns the static registers map.
func (r *Registers) Static() map[string]interface{} <span class="cov1" title="1">{
        return r.static
}</span>

// Changes returns the changes map.
func (r *Registers) Changes() map[string]interface{} <span class="cov1" title="1">{
        return r.changes
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package liquid

// ResourceLimits tracks and enforces resource limits during template rendering.
type ResourceLimits struct {
        renderLengthLimit *int
        renderScoreLimit  *int
        assignScoreLimit  *int
        lastCaptureLength *int
        renderScore       int
        assignScore       int
        reachedLimit      bool
}

// ResourceLimitsConfig configures resource limits.
type ResourceLimitsConfig struct {
        RenderLengthLimit *int
        RenderScoreLimit  *int
        AssignScoreLimit  *int
}

// NewResourceLimits creates a new ResourceLimits instance.
func NewResourceLimits(config ResourceLimitsConfig) *ResourceLimits <span class="cov9" title="132">{
        rl := &amp;ResourceLimits{
                renderLengthLimit: config.RenderLengthLimit,
                renderScoreLimit:  config.RenderScoreLimit,
                assignScoreLimit:  config.AssignScoreLimit,
        }
        rl.Reset()
        return rl
}</span>

// IncrementRenderScore increments the render score.
func (rl *ResourceLimits) IncrementRenderScore(amount int) <span class="cov7" title="42">{
        rl.renderScore += amount
        if rl.renderScoreLimit != nil &amp;&amp; rl.renderScore &gt; *rl.renderScoreLimit </span><span class="cov1" title="1">{
                rl.raiseLimitsReached()
        }</span>
}

// IncrementAssignScore increments the assign score.
func (rl *ResourceLimits) IncrementAssignScore(amount int) <span class="cov4" title="6">{
        rl.assignScore += amount
        if rl.assignScoreLimit != nil &amp;&amp; rl.assignScore &gt; *rl.assignScoreLimit </span><span class="cov1" title="1">{
                rl.raiseLimitsReached()
        }</span>
}

// IncrementWriteScore updates either render_length or assign_score based on whether writes are captured.
func (rl *ResourceLimits) IncrementWriteScore(output string) <span class="cov7" title="51">{
        if rl.lastCaptureLength != nil </span><span class="cov2" title="3">{
                captured := len([]byte(output))
                increment := captured - *rl.lastCaptureLength
                rl.lastCaptureLength = &amp;captured
                rl.IncrementAssignScore(increment)
        }</span> else<span class="cov7" title="48"> if rl.renderLengthLimit != nil &amp;&amp; len([]byte(output)) &gt; *rl.renderLengthLimit </span><span class="cov2" title="2">{
                rl.raiseLimitsReached()
        }</span>
}

func (rl *ResourceLimits) raiseLimitsReached() <span class="cov3" title="4">{
        rl.reachedLimit = true
        panic(NewMemoryError("Memory limits exceeded"))</span>
}

// Reached returns true if limits have been reached.
func (rl *ResourceLimits) Reached() bool <span class="cov6" title="28">{
        return rl.reachedLimit
}</span>

// Reset resets all scores and flags.
func (rl *ResourceLimits) Reset() <span class="cov10" title="161">{
        rl.reachedLimit = false
        rl.lastCaptureLength = nil
        rl.renderScore = 0
        rl.assignScore = 0
}</span>

// WithCapture executes a function with capture tracking.
func (rl *ResourceLimits) WithCapture(fn func()) <span class="cov2" title="3">{
        oldCaptureLength := rl.lastCaptureLength
        defer func() </span><span class="cov2" title="3">{
                rl.lastCaptureLength = oldCaptureLength
        }</span>()

        <span class="cov2" title="3">zero := 0
        rl.lastCaptureLength = &amp;zero
        fn()</span>
}

// RenderScore returns the current render score.
func (rl *ResourceLimits) RenderScore() int <span class="cov6" title="28">{
        return rl.renderScore
}</span>

// AssignScore returns the current assign score.
func (rl *ResourceLimits) AssignScore() int <span class="cov6" title="29">{
        return rl.assignScore
}</span>

// RenderLengthLimit returns the render length limit.
func (rl *ResourceLimits) RenderLengthLimit() *int <span class="cov1" title="1">{
        return rl.renderLengthLimit
}</span>

// AssignScoreLimit returns the assign score limit.
func (rl *ResourceLimits) AssignScoreLimit() *int <span class="cov1" title="1">{
        return rl.assignScoreLimit
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package liquid

// SnippetDrop represents a snippet drop.
type SnippetDrop struct {
        *Drop
        body     string
        name     string
        filename string
}

// NewSnippetDrop creates a new SnippetDrop.
func NewSnippetDrop(body string, name string, filename string) *SnippetDrop <span class="cov10" title="4">{
        return &amp;SnippetDrop{
                Drop:     NewDrop(),
                body:     body,
                name:     name,
                filename: filename,
        }
}</span>

// Body returns the body of the snippet.
func (s *SnippetDrop) Body() string <span class="cov5" title="2">{
        return s.body
}</span>

// Name returns the name of the snippet.
func (s *SnippetDrop) Name() string <span class="cov5" title="2">{
        return s.name
}</span>

// Filename returns the filename of the snippet.
func (s *SnippetDrop) Filename() string <span class="cov1" title="1">{
        return s.filename
}</span>

// ToPartial returns the body as a partial.
func (s *SnippetDrop) ToPartial() string <span class="cov1" title="1">{
        return s.body
}</span>

// String returns the string representation.
func (s *SnippetDrop) String() string <span class="cov1" title="1">{
        return "SnippetDrop"
}</span>

// InvokeDrop invokes a method on the snippet drop.
func (s *SnippetDrop) InvokeDrop(methodOrKey string) interface{} <span class="cov5" title="2">{
        return InvokeDropOn(s, methodOrKey)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package liquid

import (
        "encoding/base64"
        "html"
        "net/url"
        "regexp"
        "strings"
)

// StandardFilters provides standard filter implementations.
// This is a struct with methods that can be used as filters.
type StandardFilters struct{}

// Size returns the size of a string or array.
func (sf *StandardFilters) Size(input interface{}) interface{} <span class="cov8" title="9">{
        if input == nil </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov8" title="8">switch v := input.(type) </span>{
        case string:<span class="cov4" title="3">
                return len(v)</span>
        case []interface{}:<span class="cov4" title="3">
                return len(v)</span>
        case map[string]interface{}:<span class="cov3" title="2">
                return len(v)</span>
        default:<span class="cov0" title="0">
                // Try to get size via reflection or return 0
                return 0</span>
        }
}

// Downcase converts a string to all lowercase characters.
func (sf *StandardFilters) Downcase(input interface{}) string <span class="cov6" title="5">{
        return strings.ToLower(ToS(input, nil))
}</span>

// Upcase converts a string to all uppercase characters.
func (sf *StandardFilters) Upcase(input interface{}) string <span class="cov6" title="4">{
        return strings.ToUpper(ToS(input, nil))
}</span>

// Capitalize capitalizes the first word in a string and downcases the remaining characters.
func (sf *StandardFilters) Capitalize(input interface{}) string <span class="cov8" title="8">{
        s := ToS(input, nil)
        if len(s) == 0 </span><span class="cov1" title="1">{
                return s
        }</span>
        <span class="cov8" title="7">return strings.ToUpper(s[:1]) + strings.ToLower(s[1:])</span>
}

// Escape escapes special characters in HTML.
func (sf *StandardFilters) Escape(input interface{}) string <span class="cov6" title="5">{
        if input == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov6" title="4">return html.EscapeString(ToS(input, nil))</span>
}

// H is an alias for Escape.
func (sf *StandardFilters) H(input interface{}) string <span class="cov1" title="1">{
        return sf.Escape(input)
}</span>

// EscapeOnce escapes a string without changing characters that have already been escaped.
func (sf *StandardFilters) EscapeOnce(input interface{}) string <span class="cov1" title="1">{
        s := ToS(input, nil)
        // Simple implementation - just escape
        return html.EscapeString(s)
}</span>

// URLEncode converts URL-unsafe characters to percent-encoded equivalent.
func (sf *StandardFilters) URLEncode(input interface{}) string <span class="cov3" title="2">{
        if input == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov1" title="1">return url.QueryEscape(ToS(input, nil))</span>
}

// URLDecode decodes percent-encoded characters.
func (sf *StandardFilters) URLDecode(input interface{}) (string, error) <span class="cov4" title="3">{
        if input == nil </span><span class="cov1" title="1">{
                return "", nil
        }</span>
        <span class="cov3" title="2">decoded, err := url.QueryUnescape(ToS(input, nil))
        if err != nil </span><span class="cov1" title="1">{
                return "", NewArgumentError("invalid URL encoding")
        }</span>
        <span class="cov1" title="1">return decoded, nil</span>
}

// Base64Encode encodes a string to Base64 format.
func (sf *StandardFilters) Base64Encode(input interface{}) string <span class="cov3" title="2">{
        return base64.StdEncoding.EncodeToString([]byte(ToS(input, nil)))
}</span>

// Base64Decode decodes a string in Base64 format.
func (sf *StandardFilters) Base64Decode(input interface{}) (string, error) <span class="cov3" title="2">{
        s := ToS(input, nil)
        decoded, err := base64.StdEncoding.DecodeString(s)
        if err != nil </span><span class="cov1" title="1">{
                return "", NewArgumentError("invalid base64 provided to base64_decode")
        }</span>
        <span class="cov1" title="1">return string(decoded), nil</span>
}

// Base64URLSafeEncode encodes a string to URL-safe Base64 format.
func (sf *StandardFilters) Base64URLSafeEncode(input interface{}) string <span class="cov3" title="2">{
        return base64.URLEncoding.EncodeToString([]byte(ToS(input, nil)))
}</span>

// Base64URLSafeDecode decodes a string in URL-safe Base64 format.
func (sf *StandardFilters) Base64URLSafeDecode(input interface{}) (string, error) <span class="cov3" title="2">{
        s := ToS(input, nil)
        decoded, err := base64.URLEncoding.DecodeString(s)
        if err != nil </span><span class="cov1" title="1">{
                return "", NewArgumentError("invalid base64 provided to base64_url_safe_decode")
        }</span>
        <span class="cov1" title="1">return string(decoded), nil</span>
}

// Slice returns a substring or series of array items.
func (sf *StandardFilters) Slice(input interface{}, offset interface{}, length interface{}) interface{} <span class="cov9" title="11">{
        offsetInt, _ := ToInteger(offset)
        lengthInt := 1
        if length != nil </span><span class="cov9" title="10">{
                lengthInt, _ = ToInteger(length)
        }</span>

        <span class="cov9" title="11">switch v := input.(type) </span>{
        case []interface{}:<span class="cov6" title="4">
                if offsetInt &lt; 0 || offsetInt &gt;= len(v) </span><span class="cov3" title="2">{
                        return []interface{}{}
                }</span>
                <span class="cov3" title="2">end := offsetInt + lengthInt
                if end &gt; len(v) </span><span class="cov1" title="1">{
                        end = len(v)
                }</span>
                <span class="cov3" title="2">return v[offsetInt:end]</span>
        case string:<span class="cov7" title="6">
                if offsetInt &lt; 0 || offsetInt &gt;= len(v) </span><span class="cov3" title="2">{
                        return ""
                }</span>
                <span class="cov6" title="4">end := offsetInt + lengthInt
                if end &gt; len(v) </span><span class="cov1" title="1">{
                        end = len(v)
                }</span>
                <span class="cov6" title="4">return v[offsetInt:end]</span>
        default:<span class="cov1" title="1">
                return ""</span>
        }
}

// Truncate truncates a string down to a given number of characters.
func (sf *StandardFilters) Truncate(input interface{}, length interface{}, truncateString interface{}) string <span class="cov8" title="7">{
        if input == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov7" title="6">inputStr := ToS(input, nil)
        lengthInt, _ := ToInteger(length)
        if lengthInt &lt;= 0 </span><span class="cov3" title="2">{
                lengthInt = 50
        }</span>

        <span class="cov7" title="6">truncateStr := "..."
        if truncateString != nil </span><span class="cov3" title="2">{
                truncateStr = ToS(truncateString, nil)
        }</span>

        <span class="cov7" title="6">if len(inputStr) &lt;= lengthInt </span><span class="cov3" title="2">{
                return inputStr
        }</span>

        <span class="cov6" title="4">l := lengthInt - len(truncateStr)
        if l &lt; 0 </span><span class="cov1" title="1">{
                l = 0
        }</span>

        <span class="cov6" title="4">return inputStr[:l] + truncateStr</span>
}

// TruncateWords truncates a string down to a given number of words.
func (sf *StandardFilters) TruncateWords(input interface{}, words interface{}, truncateString interface{}) string <span class="cov7" title="6">{
        if input == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov6" title="5">inputStr := ToS(input, nil)
        wordsInt, _ := ToInteger(words)
        if wordsInt &lt;= 0 </span><span class="cov1" title="1">{
                wordsInt = 15
        }</span>

        <span class="cov6" title="5">truncateStr := "..."
        if truncateString != nil </span><span class="cov1" title="1">{
                truncateStr = ToS(truncateString, nil)
        }</span>

        <span class="cov6" title="5">wordList := strings.Fields(inputStr)
        if len(wordList) &lt;= wordsInt </span><span class="cov4" title="3">{
                return inputStr
        }</span>

        <span class="cov3" title="2">result := strings.Join(wordList[:wordsInt], " ")
        return result + truncateStr</span>
}

// Split splits a string into an array of substrings based on a separator.
func (sf *StandardFilters) Split(input interface{}, pattern interface{}) []interface{} <span class="cov1" title="1">{
        inputStr := ToS(input, nil)
        patternStr := ToS(pattern, nil)
        parts := strings.Split(inputStr, patternStr)
        result := make([]interface{}, len(parts))
        for i, part := range parts </span><span class="cov4" title="3">{
                result[i] = part
        }</span>
        <span class="cov1" title="1">return result</span>
}

// Strip strips whitespace from both ends of a string.
func (sf *StandardFilters) Strip(input interface{}) string <span class="cov1" title="1">{
        return strings.TrimSpace(ToS(input, nil))
}</span>

// Lstrip strips whitespace from the left end of a string.
func (sf *StandardFilters) Lstrip(input interface{}) string <span class="cov1" title="1">{
        return strings.TrimLeft(ToS(input, nil), " \t\n\r")
}</span>

// Rstrip strips whitespace from the right end of a string.
func (sf *StandardFilters) Rstrip(input interface{}) string <span class="cov1" title="1">{
        return strings.TrimRight(ToS(input, nil), " \t\n\r")
}</span>

// StripHTML strips HTML tags from a string.
func (sf *StandardFilters) StripHTML(input interface{}) string <span class="cov8" title="7">{
        s := ToS(input, nil)

        // First remove script/style/comment blocks
        stripHTMLBlocks := regexp.MustCompile(`(?s)&lt;script.*?&lt;/script&gt;|&lt;!--.*?--&gt;|&lt;style.*?&lt;/style&gt;`)
        result := stripHTMLBlocks.ReplaceAllString(s, "")

        // Then remove all HTML tags
        stripHTMLTags := regexp.MustCompile(`&lt;.*?&gt;`)
        result = stripHTMLTags.ReplaceAllString(result, "")

        return result
}</span>

// First returns the first element of an array.
func (sf *StandardFilters) First(input interface{}) interface{} <span class="cov6" title="4">{
        if arr, ok := input.([]interface{}); ok &amp;&amp; len(arr) &gt; 0 </span><span class="cov1" title="1">{
                return arr[0]
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// Last returns the last element of an array.
func (sf *StandardFilters) Last(input interface{}) interface{} <span class="cov6" title="4">{
        if arr, ok := input.([]interface{}); ok &amp;&amp; len(arr) &gt; 0 </span><span class="cov1" title="1">{
                return arr[len(arr)-1]
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// Join joins array elements with a separator.
func (sf *StandardFilters) Join(input interface{}, separator interface{}) string <span class="cov7" title="6">{
        sep := ", "
        if separator != nil </span><span class="cov6" title="5">{
                sep = ToS(separator, nil)
        }</span>

        <span class="cov7" title="6">if arr, ok := input.([]interface{}); ok </span><span class="cov6" title="5">{
                parts := make([]string, len(arr))
                for i, item := range arr </span><span class="cov10" title="12">{
                        parts[i] = ToS(item, nil)
                }</span>
                <span class="cov6" title="5">return strings.Join(parts, sep)</span>
        }
        <span class="cov1" title="1">return ToS(input, nil)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package liquid

import (
        "fmt"
        "reflect"
        "strings"
)

// StrainerTemplate is the computed class for the filters system.
// New filters are mixed into the strainer class which is then instantiated for each liquid template render run.
type StrainerTemplate struct {
        context         interface{ Context() interface{} }
        filterMethods   map[string]bool
        filterInstances map[string]interface{}
        strictFilters   bool
}

// StrainerTemplateClass represents a strainer template class that can have filters added.
type StrainerTemplateClass struct {
        filterMethods map[string]bool
}

// NewStrainerTemplateClass creates a new strainer template class.
func NewStrainerTemplateClass() *StrainerTemplateClass <span class="cov6" title="237">{
        return &amp;StrainerTemplateClass{
                filterMethods: make(map[string]bool),
        }
}</span>

// AddFilter adds a filter module to the strainer template class.
func (stc *StrainerTemplateClass) AddFilter(filter interface{}) error <span class="cov6" title="239">{
        // Get all methods from the filter
        filterType := reflect.TypeOf(filter)
        if filterType.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return fmt.Errorf("filter must be a pointer to a struct")
        }</span>

        // Get methods from the filter
        <span class="cov6" title="239">for i := 0; i &lt; filterType.NumMethod(); i++ </span><span class="cov10" title="5736">{
                method := filterType.Method(i)
                // Only include exported methods
                if method.PkgPath == "" </span><span class="cov10" title="5736">{
                        stc.filterMethods[method.Name] = true
                }</span>
        }

        <span class="cov6" title="239">return nil</span>
}

// Invokable checks if a method name is invokable.
func (stc *StrainerTemplateClass) Invokable(method string) bool <span class="cov1" title="2">{
        return stc.filterMethods[method]
}</span>

// FilterMethodNames returns all filter method names.
func (stc *StrainerTemplateClass) FilterMethodNames() []string <span class="cov2" title="3">{
        names := make([]string, 0, len(stc.filterMethods))
        for name := range stc.filterMethods </span><span class="cov5" title="72">{
                names = append(names, name)
        }</span>
        <span class="cov2" title="3">return names</span>
}

// NewStrainerTemplate creates a new strainer template instance.
func NewStrainerTemplate(class *StrainerTemplateClass, context interface{ Context() interface{} }, strictFilters bool) *StrainerTemplate <span class="cov4" title="22">{
        st := &amp;StrainerTemplate{
                context:         context,
                filterMethods:   class.filterMethods,
                strictFilters:   strictFilters,
                filterInstances: make(map[string]interface{}),
        }

        // Always add StandardFilters as a base filter
        sf := &amp;StandardFilters{}
        st.filterInstances["*liquid.StandardFilters"] = sf

        return st
}</span>

// NewStrainerTemplateWithFilters creates a new strainer template instance with additional filters.
func NewStrainerTemplateWithFilters(class *StrainerTemplateClass, context interface{ Context() interface{} }, strictFilters bool, filters []interface{}) *StrainerTemplate <span class="cov1" title="1">{
        st := NewStrainerTemplate(class, context, strictFilters)

        // Add additional filter instances
        for _, filter := range filters </span><span class="cov1" title="1">{
                filterType := reflect.TypeOf(filter)
                if filterType.Kind() == reflect.Ptr </span><span class="cov1" title="1">{
                        st.filterInstances[filterType.String()] = filter
                }</span>
        }

        <span class="cov1" title="1">return st</span>
}

// Invoke invokes a filter method.
func (st *StrainerTemplate) Invoke(method string, args ...interface{}) (interface{}, error) <span class="cov4" title="27">{
        // Check if method is invokable (try both lowercase and capitalized)
        methodInvokable := st.filterMethods[method]
        if !methodInvokable &amp;&amp; len(method) &gt; 0 </span><span class="cov4" title="20">{
                // Try capitalized version (Go method names are capitalized)
                capitalizedMethod := strings.ToUpper(method[:1]) + method[1:]
                methodInvokable = st.filterMethods[capitalizedMethod]
                if methodInvokable </span><span class="cov3" title="8">{
                        // Use capitalized version for lookup
                        method = capitalizedMethod
                }</span>
        }
        <span class="cov4" title="27">if !methodInvokable </span><span class="cov3" title="12">{
                if st.strictFilters </span><span class="cov2" title="3">{
                        return nil, NewUndefinedFilter("undefined filter " + method)
                }</span>
                // In non-strict mode, return first arg
                <span class="cov3" title="9">if len(args) &gt; 0 </span><span class="cov3" title="8">{
                        return args[0], nil
                }</span>
                <span class="cov1" title="1">return nil, nil</span>
        }

        // Method is invokable - use reflection to find and call it on filter instances
        // Try each filter instance until we find one with the method
        <span class="cov3" title="15">for _, filterInstance := range st.filterInstances </span><span class="cov3" title="15">{
                filterValue := reflect.ValueOf(filterInstance)

                // Look for the method - try both original case and capitalized version
                // Go method names are capitalized, but Liquid filter names are lowercase
                methodValue := filterValue.MethodByName(method)
                if !methodValue.IsValid() &amp;&amp; len(method) &gt; 0 </span><span class="cov0" title="0">{
                        // Try capitalized version (first letter uppercase)
                        capitalizedMethod := strings.ToUpper(method[:1]) + method[1:]
                        methodValue = filterValue.MethodByName(capitalizedMethod)
                }</span>
                <span class="cov3" title="15">if !methodValue.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if method signature matches (first arg is input, rest are filter args)
                <span class="cov3" title="15">methodType := methodValue.Type()
                if methodType.NumIn() &lt; 1 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Prepare arguments
                <span class="cov3" title="15">callArgs := make([]reflect.Value, 0, len(args)+1)
                // First arg is the input (from args[0])
                if len(args) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="15">callArgs = append(callArgs, reflect.ValueOf(args[0]))

                // Remaining args are filter arguments
                expectedArgs := methodType.NumIn() - 1
                if len(args)-1 &lt; expectedArgs </span><span class="cov0" title="0">{
                        // Not enough args, skip this filter
                        continue</span>
                }

                // Add filter arguments
                <span class="cov3" title="15">for i := 1; i &lt;= expectedArgs &amp;&amp; i &lt; len(args); i++ </span><span class="cov2" title="3">{
                        callArgs = append(callArgs, reflect.ValueOf(args[i]))
                }</span>

                // Call the method
                <span class="cov3" title="15">results := methodValue.Call(callArgs)
                if len(results) &gt; 0 </span><span class="cov3" title="14">{
                        return results[0].Interface(), nil
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }

        // Method not found in any filter - this shouldn't happen if filterMethods is correct
        // but handle gracefully
        <span class="cov0" title="0">if len(args) &gt; 0 </span><span class="cov0" title="0">{
                return args[0], nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package liquid

import (
        "regexp"
)

// StringScanner provides a scanner interface similar to Ruby's StringScanner.
type StringScanner struct {
        source string
        pos    int
}

// NewStringScanner creates a new StringScanner.
func NewStringScanner(source string) *StringScanner <span class="cov8" title="343">{
        return &amp;StringScanner{
                source: source,
                pos:    0,
        }
}</span>

// String returns the source string.
func (s *StringScanner) String() string <span class="cov7" title="126">{
        return s.source
}</span>

// SetString sets the source string and resets position.
func (s *StringScanner) SetString(str string) <span class="cov7" title="171">{
        s.source = str
        s.pos = 0
}</span>

// Pos returns the current position.
func (s *StringScanner) Pos() int <span class="cov8" title="439">{
        return s.pos
}</span>

// SetPos sets the current position.
func (s *StringScanner) SetPos(pos int) <span class="cov5" title="35">{
        s.pos = pos
}</span>

// EOS returns true if we're at the end of the string.
func (s *StringScanner) EOS() bool <span class="cov10" title="991">{
        return s.pos &gt;= len(s.source)
}</span>

// PeekByte returns the byte at the current position without advancing.
func (s *StringScanner) PeekByte() byte <span class="cov9" title="535">{
        if s.pos &gt;= len(s.source) </span><span class="cov3" title="6">{
                return 0
        }</span>
        <span class="cov9" title="529">return s.source[s.pos]</span>
}

// ScanByte advances and returns the byte at the current position.
func (s *StringScanner) ScanByte() byte <span class="cov9" title="508">{
        if s.pos &gt;= len(s.source) </span><span class="cov2" title="3">{
                return 0
        }</span>
        <span class="cov9" title="505">b := s.source[s.pos]
        s.pos++
        return b</span>
}

// Scan scans for the given pattern and advances position if matched.
func (s *StringScanner) Scan(pattern *regexp.Regexp) string <span class="cov7" title="169">{
        if s.pos &gt;= len(s.source) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov7" title="169">rest := s.source[s.pos:]
        loc := pattern.FindStringIndex(rest)
        if loc == nil || loc[0] != 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov7" title="169">match := rest[loc[0]:loc[1]]
        s.pos += loc[1]
        return match</span>
}

// Skip skips the given pattern.
func (s *StringScanner) Skip(pattern *regexp.Regexp) int <span class="cov8" title="301">{
        if s.pos &gt;= len(s.source) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="301">rest := s.source[s.pos:]
        loc := pattern.FindStringIndex(rest)
        if loc == nil || loc[0] != 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="301">s.pos += loc[1]
        return loc[1]</span>
}

// SkipUntil skips until the pattern is found.
func (s *StringScanner) SkipUntil(pattern *regexp.Regexp) int <span class="cov6" title="71">{
        if s.pos &gt;= len(s.source) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov6" title="71">rest := s.source[s.pos:]
        loc := pattern.FindStringIndex(rest)
        if loc == nil </span><span class="cov4" title="18">{
                s.pos = len(s.source)
                return 0
        }</span>
        <span class="cov6" title="53">s.pos += loc[1]
        return loc[1]</span>
}

// Rest returns the rest of the string from current position.
func (s *StringScanner) Rest() string <span class="cov5" title="42">{
        if s.pos &gt;= len(s.source) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov5" title="42">return s.source[s.pos:]</span>
}

// Terminate sets position to end of string.
func (s *StringScanner) Terminate() <span class="cov4" title="18">{
        s.pos = len(s.source)
}</span>

// Getch gets the next character (handles UTF-8).
func (s *StringScanner) Getch() string <span class="cov3" title="7">{
        if s.pos &gt;= len(s.source) </span><span class="cov0" title="0">{
                return ""
        }</span>
        // Get the next rune
        <span class="cov3" title="7">r, size := runeAt(s.source, s.pos)
        s.pos += size
        return string(r)</span>
}

// Byteslice returns a slice of bytes from start to end.
func (s *StringScanner) Byteslice(start, length int) string <span class="cov6" title="80">{
        if start &lt; 0 || start &gt;= len(s.source) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov6" title="80">end := start + length
        if end &gt; len(s.source) </span><span class="cov0" title="0">{
                end = len(s.source)
        }</span>
        <span class="cov6" title="80">return s.source[start:end]</span>
}

func runeAt(s string, pos int) (rune, int) <span class="cov3" title="7">{
        if pos &gt;= len(s) </span><span class="cov0" title="0">{
                return 0, 0
        }</span>
        <span class="cov3" title="7">return []rune(s[pos:])[0], len([]byte(string([]rune(s[pos:])[0])))</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package liquid

// TablerowloopDrop provides information about a parent tablerow loop.
type TablerowloopDrop struct {
        *Drop
        length int
        row    int
        col    int
        cols   int
        index  int
}

// NewTablerowloopDrop creates a new TablerowloopDrop.
func NewTablerowloopDrop(length int, cols int) *TablerowloopDrop <span class="cov8" title="11">{
        return &amp;TablerowloopDrop{
                Drop:   NewDrop(),
                length: length,
                row:    1,
                col:    1,
                cols:   cols,
                index:  0,
        }
}</span>

// Length returns the total number of iterations in the loop.
func (t *TablerowloopDrop) Length() int <span class="cov3" title="2">{
        return t.length
}</span>

// Col returns the 1-based index of the current column.
func (t *TablerowloopDrop) Col() int <span class="cov5" title="4">{
        return t.col
}</span>

// Row returns the 1-based index of current row.
func (t *TablerowloopDrop) Row() int <span class="cov5" title="4">{
        return t.row
}</span>

// Index returns the 1-based index of the current iteration.
func (t *TablerowloopDrop) Index() int <span class="cov4" title="3">{
        return t.index + 1
}</span>

// Index0 returns the 0-based index of the current iteration.
func (t *TablerowloopDrop) Index0() int <span class="cov3" title="2">{
        return t.index
}</span>

// Col0 returns the 0-based index of the current column.
func (t *TablerowloopDrop) Col0() int <span class="cov3" title="2">{
        return t.col - 1
}</span>

// Rindex returns the 1-based index of the current iteration, in reverse order.
func (t *TablerowloopDrop) Rindex() int <span class="cov3" title="2">{
        return t.length - t.index
}</span>

// Rindex0 returns the 0-based index of the current iteration, in reverse order.
func (t *TablerowloopDrop) Rindex0() int <span class="cov3" title="2">{
        return t.length - t.index - 1
}</span>

// First returns true if the current iteration is the first.
func (t *TablerowloopDrop) First() bool <span class="cov3" title="2">{
        return t.index == 0
}</span>

// Last returns true if the current iteration is the last.
func (t *TablerowloopDrop) Last() bool <span class="cov3" title="2">{
        return t.index == t.length-1
}</span>

// ColFirst returns true if the current column is the first in the row.
func (t *TablerowloopDrop) ColFirst() bool <span class="cov3" title="2">{
        return t.col == 1
}</span>

// ColLast returns true if the current column is the last in the row.
func (t *TablerowloopDrop) ColLast() bool <span class="cov4" title="3">{
        return t.col == t.cols
}</span>

// Cols returns the number of columns.
func (t *TablerowloopDrop) Cols() int <span class="cov3" title="2">{
        return t.cols
}</span>

// Increment increments the index and updates row/col.
func (t *TablerowloopDrop) Increment() <span class="cov10" title="20">{
        t.index++

        if t.col == t.cols </span><span class="cov5" title="4">{
                t.col = 1
                t.row++
        }</span> else<span class="cov9" title="16"> {
                t.col++
        }</span>
}

// InvokeDrop invokes a method on the tablerowloop drop.
func (t *TablerowloopDrop) InvokeDrop(methodOrKey string) interface{} <span class="cov4" title="3">{
        return InvokeDropOn(t, methodOrKey)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package liquid

import (
        "fmt"
        "strings"
)

// TagContext interface for tag rendering context
type TagContext interface {
        TagDisabled(tagName string) bool
        WithDisabledTags(tags []string, fn func())
        HandleError(err error, lineNumber *int) string
        ParseContext() ParseContextInterface
        Evaluate(expr interface{}) interface{}
        FindVariable(key string, raiseOnNotFound bool) interface{}
        Invoke(method string, obj interface{}, args ...interface{}) interface{}
        ApplyGlobalFilter(obj interface{}) interface{}
        Interrupt() bool
        PushInterrupt(interrupt interface{})
        ResourceLimits() *ResourceLimits
        Registers() *Registers
        Context() interface{}
}

// Tag represents a Liquid tag.
type Tag struct {
        tagName      string
        markup       string
        parseContext ParseContextInterface
        lineNumber   *int
        nodelist     []interface{} // For block tags
}

// NewTag creates a new tag instance.
func NewTag(tagName, markup string, parseContext ParseContextInterface) *Tag <span class="cov10" title="52">{
        lineNum := parseContext.LineNumber()
        return &amp;Tag{
                tagName:      tagName,
                markup:       markup,
                parseContext: parseContext,
                lineNumber:   lineNum,
                nodelist:     []interface{}{},
        }
}</span>

// ParseTag parses a tag from tokenizer.
func ParseTag(tagName, markup string, tokenizer *Tokenizer, parseContext ParseContextInterface) (*Tag, error) <span class="cov1" title="1">{
        tag := NewTag(tagName, markup, parseContext)
        err := tag.Parse(tokenizer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return tag, nil</span>
}

// TagName returns the tag name.
func (t *Tag) TagName() string <span class="cov6" title="11">{
        return t.tagName
}</span>

// Markup returns the tag markup.
func (t *Tag) Markup() string <span class="cov1" title="1">{
        return t.markup
}</span>

// LineNumber returns the line number.
func (t *Tag) LineNumber() *int <span class="cov3" title="3">{
        return t.lineNumber
}</span>

// ParseContext returns the parse context.
func (t *Tag) ParseContext() ParseContextInterface <span class="cov6" title="13">{
        return t.parseContext
}</span>

// Raw returns the raw tag representation.
func (t *Tag) Raw() string <span class="cov2" title="2">{
        return fmt.Sprintf("%s %s", t.tagName, t.markup)
}</span>

// Name returns the tag name (for backwards compatibility).
func (t *Tag) Name() string <span class="cov1" title="1">{
        return strings.ToLower(t.tagName)
}</span>

// Parse parses the tag (can be overridden by subclasses).
func (t *Tag) Parse(tokenizer *Tokenizer) error <span class="cov6" title="13">{
        // Default implementation does nothing
        return nil
}</span>

// Render renders the tag (returns empty string by default).
func (t *Tag) Render(context TagContext) string <span class="cov5" title="7">{
        return ""
}</span>

// RenderToOutputBuffer renders the tag to the output buffer.
// Note: Due to Go's method dispatch with embedded pointers, this method cannot
// automatically call overridden Render() methods in subtypes. Tags that override
// Render() must be handled specially in the rendering code.
func (t *Tag) RenderToOutputBuffer(context TagContext, output *string) <span class="cov5" title="6">{
        renderResult := t.Render(context)
        if renderResult != "" </span><span class="cov0" title="0">{
                *output += renderResult
        }</span>
}

// Blank returns true if the tag is blank (produces no output).
func (t *Tag) Blank() bool <span class="cov7" title="17">{
        return false
}</span>

// Nodelist returns the nodelist (for block tags).
func (t *Tag) Nodelist() []interface{} <span class="cov5" title="6">{
        return t.nodelist
}</span>

// SetNodelist sets the nodelist.
func (t *Tag) SetNodelist(nodelist []interface{}) <span class="cov4" title="4">{
        t.nodelist = nodelist
}</span>

// SafeParseExpression safely parses an expression.
func (t *Tag) SafeParseExpression(parser *Parser) interface{} <span class="cov1" title="1">{
        return t.parseContext.SafeParseExpression(parser)
}</span>

// ParseExpression parses an expression.
func (t *Tag) ParseExpression(markup string, safe bool) interface{} <span class="cov2" title="2">{
        return t.parseContext.ParseExpression(markup)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package tag

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// Disableable provides functionality for tags that can be disabled.
// Tags that embed this struct will check if they're disabled before rendering.
type Disableable struct{}

// RenderToOutputBuffer wraps tag rendering to check if the tag is disabled.
// If disabled, it outputs an error message. Otherwise, it calls the render function.
func (d *Disableable) RenderToOutputBuffer(
        tagName string,
        context liquid.TagContext,
        lineNumber *int,
        parseContext liquid.ParseContextInterface,
        output *string,
        renderFn func(),
) <span class="cov10" title="12">{
        disabled := context.TagDisabled(tagName)
        if disabled </span><span class="cov8" title="9">{
                errorMsg := d.disabledError(tagName, context, lineNumber, parseContext)
                *output += errorMsg
                return
        }</span>
        <span class="cov4" title="3">renderFn()</span>
}

// disabledError creates a DisabledError and returns the error message string.
func (d *Disableable) disabledError(
        tagName string,
        context liquid.TagContext,
        lineNumber *int,
        parseContext liquid.ParseContextInterface,
) string <span class="cov8" title="9">{
        // Get locale from parse context
        var locale *liquid.I18n
        if pc, ok := parseContext.(*liquid.ParseContext); ok </span><span class="cov8" title="9">{
                locale = pc.Locale()
        }</span> else<span class="cov0" title="0"> {
                // Fallback: create default locale if parse context doesn't have one
                locale = liquid.NewI18n("")
        }</span>

        // Translate error message with panic recovery
        <span class="cov8" title="9">var errorText string
        func() </span><span class="cov8" title="9">{
                defer func() </span><span class="cov8" title="9">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                // If translation panics, use fallback
                                errorText = "usage is not allowed in this context"
                        }</span>
                }()
                <span class="cov8" title="9">errorText = locale.T("errors.disabled.tag", nil)
                if errorText == "errors.disabled.tag" </span><span class="cov8" title="9">{
                        // Fallback if translation not found (key returned as-is)
                        errorText = "usage is not allowed in this context"
                }</span>
        }()

        // Create error message: "{tag_name} {error_text}"
        <span class="cov8" title="9">errorMsg := tagName + " " + errorText

        // Create DisabledError
        err := liquid.NewDisabledError(errorMsg)
        if err.Err.LineNumber == nil </span><span class="cov8" title="9">{
                err.Err.LineNumber = lineNumber
        }</span>

        // Handle error through context
        <span class="cov8" title="9">return context.HandleError(err, lineNumber)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package tag

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// Disabler provides functionality for tags that disable other tags.
// Tags that embed this struct will disable specified tags during rendering.
type Disabler struct{}

// RenderToOutputBuffer wraps tag rendering to disable specified tags during rendering.
// It calls context.WithDisabledTags with the provided disabled tags list.
func (d *Disabler) RenderToOutputBuffer(
        disabledTags []string,
        context liquid.TagContext,
        output *string,
        renderFn func(),
) <span class="cov10" title="2">{
        context.WithDisabledTags(disabledTags, func() </span><span class="cov10" title="2">{
                renderFn()
        }</span>)
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package tags

import (
        "regexp"

        "github.com/Notifuse/liquidgo/liquid"
)

// assignSyntax matches: variable_name = value
// VariableSignature matches a single character, so we need to match multiple
var assignSyntax = regexp.MustCompile(`([\w\-\.\[\]]+)\s*=\s*(.*)\s*`)

// AssignTag represents an assign tag that creates a new variable.
type AssignTag struct {
        *liquid.Tag
        to   string
        from *liquid.Variable
}

// NewAssignTag creates a new AssignTag.
func NewAssignTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*AssignTag, error) <span class="cov10" title="19">{
        matches := assignSyntax.FindStringSubmatch(markup)
        if len(matches) &lt; 3 </span><span class="cov1" title="1">{
                // Get locale from parse context if it's a ParseContext struct
                var locale *liquid.I18n
                if pc, ok := parseContext.(*liquid.ParseContext); ok </span><span class="cov1" title="1">{
                        locale = pc.Locale()
                        msg := locale.Translate("errors.syntax.assign", map[string]interface{}{})
                        return nil, liquid.NewSyntaxError(msg)
                }</span>
                <span class="cov0" title="0">return nil, liquid.NewSyntaxError("Liquid syntax error: assign")</span>
        }

        <span class="cov9" title="18">return &amp;AssignTag{
                Tag:  liquid.NewTag(tagName, markup, parseContext),
                to:   matches[1],
                from: liquid.NewVariable(matches[2], parseContext),
        }, nil</span>
}

// To returns the variable name being assigned to.
func (a *AssignTag) To() string <span class="cov6" title="7">{
        return a.to
}</span>

// From returns the variable being assigned from.
func (a *AssignTag) From() *liquid.Variable <span class="cov1" title="1">{
        return a.from
}</span>

// RenderToOutputBuffer renders the assign tag.
func (a *AssignTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov8" title="10">{
        val := a.from.Render(context)

        // Set in the last scope (outermost scope, matching Ruby's context.scopes.last[@to] = val)
        ctx := context.Context().(*liquid.Context)
        ctx.SetLast(a.to, val)

        // Increment assign score
        rl := context.ResourceLimits()
        if rl != nil </span><span class="cov8" title="10">{
                score := assignScoreOf(val)
                rl.IncrementAssignScore(score)
        }</span>
}

// assignScoreOf calculates the assign score for resource limits.
func assignScoreOf(val interface{}) int <span class="cov9" title="18">{
        switch v := val.(type) </span>{
        case string:<span class="cov9" title="15">
                return len([]byte(v))</span>
        case []interface{}:<span class="cov3" title="2">
                sum := 1
                for _, child := range v </span><span class="cov6" title="6">{
                        sum += assignScoreOf(child)
                }</span>
                <span class="cov3" title="2">return sum</span>
        case map[string]interface{}:<span class="cov1" title="1">
                sum := 1
                for key, entryValue := range v </span><span class="cov1" title="1">{
                        sum += assignScoreOf(key)
                        sum += assignScoreOf(entryValue)
                }</span>
                <span class="cov1" title="1">return sum</span>
        default:<span class="cov0" title="0">
                return 1</span>
        }
}

// Blank returns true since assign tags are blank.
func (a *AssignTag) Blank() bool <span class="cov1" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package tags

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// BreakTag represents a break tag that stops a for loop from iterating.
type BreakTag struct {
        *liquid.Tag
}

// NewBreakTag creates a new BreakTag.
func NewBreakTag(tagName, markup string, parseContext liquid.ParseContextInterface) *BreakTag <span class="cov10" title="3">{
        return &amp;BreakTag{
                Tag: liquid.NewTag(tagName, markup, parseContext),
        }
}</span>

// RenderToOutputBuffer renders the break tag by pushing a break interrupt.
func (b *BreakTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov6" title="2">{
        interrupt := liquid.NewBreakInterrupt()
        context.PushInterrupt(interrupt)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        // captureSyntax matches variable names, including quoted strings
        // Matches: var, 'var', "var", this-thing, etc.
        // Capture group 1: the variable name (with or without quotes)
        captureSyntax = regexp.MustCompile(`^("(?:"|[^"])*"|'[^']*'|[\w\-\.\[\]]+)$`)
)

// CaptureTag represents a capture block tag that captures rendered content into a variable.
type CaptureTag struct {
        *liquid.Block
        to string
}

// NewCaptureTag creates a new CaptureTag.
func NewCaptureTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*CaptureTag, error) <span class="cov10" title="9">{
        // Trim whitespace from markup
        markup = strings.TrimSpace(markup)

        // Parse variable name from markup
        matches := captureSyntax.FindStringSubmatch(markup)
        if len(matches) == 0 </span><span class="cov1" title="1">{
                var locale *liquid.I18n
                if pc, ok := parseContext.(*liquid.ParseContext); ok </span><span class="cov1" title="1">{
                        locale = pc.Locale()
                        msg := locale.Translate("errors.syntax.capture", map[string]interface{}{})
                        return nil, liquid.NewSyntaxError(msg)
                }</span>
                <span class="cov0" title="0">return nil, liquid.NewSyntaxError("Liquid syntax error: capture")</span>
        }

        <span class="cov9" title="8">block := liquid.NewBlock(tagName, markup, parseContext)

        // Extract variable name, stripping quotes if present
        varName := matches[1]
        // Strip surrounding quotes if present (both single and double)
        if len(varName) &gt;= 2 </span><span class="cov9" title="8">{
                if (varName[0] == '"' &amp;&amp; varName[len(varName)-1] == '"') ||
                        (varName[0] == '\'' &amp;&amp; varName[len(varName)-1] == '\'') </span><span class="cov5" title="3">{
                        varName = varName[1 : len(varName)-1]
                }</span>
        }

        <span class="cov9" title="8">return &amp;CaptureTag{
                Block: block,
                to:    varName,
        }, nil</span>
}

// To returns the variable name to capture to.
func (c *CaptureTag) To() string <span class="cov7" title="5">{
        return c.to
}</span>

// RenderToOutputBuffer renders the capture tag.
// Following Ruby implementation: always uses resource_limits.with_capture,
// renders the block body, and assigns to context.scopes.last
func (c *CaptureTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov3" title="2">{
        ctx := context.Context().(*liquid.Context)
        rl := context.ResourceLimits()

        // Use WithCapture to track resource limits during capture (like Ruby: context.resource_limits.with_capture)
        // Ruby always calls with_capture, so we do too (resource_limits should always exist)
        if rl != nil </span><span class="cov1" title="1">{
                rl.WithCapture(func() </span><span class="cov1" title="1">{
                        captureOutput := c.Render(context)
                        // Increment write score with captured output (like Ruby: increment_write_score is called in block_body)
                        // This will increment assign_score by the byte difference since lastCaptureLength is set
                        rl.IncrementWriteScore(captureOutput)
                        // Set in the last scope (outermost scope, matching Ruby's context.scopes.last[@to] = capture_output)
                        ctx.SetLast(c.to, captureOutput)
                }</span>)
        } else<span class="cov1" title="1"> {
                // Fallback if resource_limits is nil (shouldn't happen in normal usage)
                captureOutput := c.Render(context)
                ctx.SetLast(c.to, captureOutput)
        }</span>

        // Ruby returns output unchanged (doesn't modify it)
        // In Go, we don't modify output, so this is correct
}

// Blank returns true since capture tags are blank (they don't output).
func (c *CaptureTag) Blank() bool <span class="cov1" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        // caseSyntax matches: variable
        caseSyntax = regexp.MustCompile(`^(` + liquid.QuotedFragment.String() + `)$`)
        // whenSyntax matches: value [or value2] or value1, value2, value3
        whenSyntax = regexp.MustCompile(`(` + liquid.QuotedFragment.String() + `)(?:(?:\s+or\s+|\s*,\s*)(` + liquid.QuotedFragment.String() + `.*))?`)
)

// CaseBlock represents a case condition block (when or else).
type CaseBlock interface {
        Evaluate(context liquid.ConditionContext) (bool, error)
        Attachment() interface{}
        Attach(attachment interface{})
        IsElse() bool
}

// caseCondition wraps Condition to implement CaseBlock.
type caseCondition struct {
        *liquid.Condition
}

func (c *caseCondition) IsElse() bool <span class="cov7" title="13">{
        return false
}</span>

// caseElseCondition wraps ElseCondition to implement CaseBlock.
type caseElseCondition struct {
        *liquid.ElseCondition
}

func (c *caseElseCondition) IsElse() bool <span class="cov4" title="4">{
        return true
}</span>

// CaseTag represents a case block tag with when and else blocks.
type CaseTag struct {
        *liquid.Block
        left   interface{} // Expression to compare
        blocks []CaseBlock
}

// NewCaseTag creates a new CaseTag.
func NewCaseTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*CaseTag, error) <span class="cov9" title="23">{
        block := liquid.NewBlock(tagName, markup, parseContext)

        tag := &amp;CaseTag{
                Block:  block,
                blocks: []CaseBlock{},
        }

        // Parse markup to get left expression
        err := tag.parseMarkup(markup, parseContext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="22">return tag, nil</span>
}

// parseMarkup parses the case tag markup.
func (c *CaseTag) parseMarkup(markup string, parseContext liquid.ParseContextInterface) error <span class="cov9" title="23">{
        matches := caseSyntax.FindStringSubmatch(markup)
        if len(matches) == 0 </span><span class="cov1" title="1">{
                return liquid.NewSyntaxError("invalid case tag syntax")
        }</span>

        <span class="cov8" title="22">c.left = parseContext.ParseExpression(matches[1])
        return nil</span>
}

// Left returns the left expression.
func (c *CaseTag) Left() interface{} <span class="cov1" title="1">{
        return c.left
}</span>

// Blocks returns the condition blocks.
func (c *CaseTag) Blocks() []CaseBlock <span class="cov5" title="5">{
        return c.blocks
}</span>

// Nodelist returns the nodelist from all blocks.
func (c *CaseTag) Nodelist() []interface{} <span class="cov1" title="1">{
        nodelist := []interface{}{}
        for _, block := range c.blocks </span><span class="cov1" title="1">{
                if attachment, ok := block.Attachment().(*liquid.BlockBody); ok </span><span class="cov1" title="1">{
                        nodelist = append(nodelist, attachment.Nodelist()...)
                }</span>
        }
        <span class="cov1" title="1">return nodelist</span>
}

// UnknownTag handles when and else tags.
func (c *CaseTag) UnknownTag(tagName, markup string, tokenizer *liquid.Tokenizer) error <span class="cov9" title="23">{
        switch tagName </span>{
        case "when":<span class="cov7" title="15">
                return c.recordWhenCondition(markup)</span>
        case "else":<span class="cov5" title="6">
                return c.recordElseCondition(markup)</span>
        default:<span class="cov2" title="2">
                return c.Block.UnknownTag(tagName, markup, tokenizer)</span>
        }
}

// Parse parses the case block with support for when and else.
func (c *CaseTag) Parse(tokenizer *liquid.Tokenizer) error <span class="cov6" title="10">{
        // Ruby: body = case_body = new_body; body = @blocks.last.attachment while parse_body(body, tokens)
        // We start with a dummy body, but when we encounter when/else, we create a new body for that block
        var currentBody *liquid.BlockBody

        for </span><span class="cov9" title="27">{
                // If we don't have a current body yet, create one (for the first when block)
                if currentBody == nil </span><span class="cov6" title="10">{
                        currentBody = liquid.NewBlockBody()
                }</span>

                <span class="cov9" title="27">currentBlockCount := len(c.blocks)

                shouldContinue, err := c.parseBodyForBlock(tokenizer, currentBody)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If a new block was created (when/else), continue parsing with its body
                <span class="cov9" title="27">if len(c.blocks) &gt; currentBlockCount </span><span class="cov8" title="17">{
                        // Get the last block's attachment
                        if len(c.blocks) &gt; 0 </span><span class="cov8" title="17">{
                                if attachment, ok := c.blocks[len(c.blocks)-1].Attachment().(*liquid.BlockBody); ok </span><span class="cov8" title="17">{
                                        currentBody = attachment
                                        continue</span>
                                }
                        }
                }

                // If shouldContinue is false, we found endcase, so stop
                <span class="cov6" title="10">if !shouldContinue </span><span class="cov6" title="10">{
                        break</span>
                }
        }

        // Remove blank strings if block is blank
        <span class="cov6" title="10">if c.Blank() </span><span class="cov6" title="10">{
                for _, block := range c.blocks </span><span class="cov8" title="17">{
                        if attachment, ok := block.Attachment().(*liquid.BlockBody); ok </span><span class="cov8" title="17">{
                                attachment.RemoveBlankStrings()
                        }</span>
                }
        }

        <span class="cov6" title="10">return nil</span>
}

// parseBodyForBlock parses the body for a specific block.
func (c *CaseTag) parseBodyForBlock(tokenizer *liquid.Tokenizer, body *liquid.BlockBody) (bool, error) <span class="cov10" title="33">{
        parseContext := c.ParseContext()
        if parseContext.Depth() &gt;= 100 </span><span class="cov2" title="2">{
                return false, liquid.NewStackLevelError("Nesting too deep")
        }</span>

        <span class="cov9" title="31">parseContext.IncrementDepth()
        defer parseContext.DecrementDepth()

        foundEndTag := false
        unknownTagHandler := func(endTagName, endTagMarkup string) bool </span><span class="cov9" title="31">{
                if endTagName == c.BlockDelimiter() </span><span class="cov7" title="11">{
                        foundEndTag = true
                        return false // Stop parsing - found endcase
                }</span>
                <span class="cov8" title="20">if endTagName == "" </span><span class="cov0" title="0">{
                        return false // Tag never closed
                }</span>

                // Handle when and else
                <span class="cov8" title="20">if endTagName == "when" || endTagName == "else" </span><span class="cov8" title="19">{
                        err := c.UnknownTag(endTagName, endTagMarkup, tokenizer)
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="19">return false</span> // Stop parsing current block
                }

                // Unknown tag - let block handle it
                <span class="cov1" title="1">return c.UnknownTag(endTagName, endTagMarkup, tokenizer) == nil</span>
        }

        <span class="cov9" title="31">err := body.Parse(tokenizer, parseContext, unknownTagHandler)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Return true if we should continue (didn't find endcase)
        <span class="cov9" title="31">return !foundEndTag, nil</span>
}

// recordWhenCondition records a when condition.
func (c *CaseTag) recordWhenCondition(markup string) error <span class="cov8" title="18">{
        // Parse when conditions (can have multiple values separated by "or" or comma)
        // Ruby: parse_lax_when creates one body and multiple conditions attached to it
        body := liquid.NewBlockBody()

        remainingMarkup := strings.TrimSpace(markup)
        for remainingMarkup != "" </span><span class="cov8" title="19">{
                matches := whenSyntax.FindStringSubmatch(remainingMarkup)
                if len(matches) == 0 </span><span class="cov0" title="0">{
                        return liquid.NewSyntaxError("invalid when condition syntax")
                }</span>

                // Parse the value expression
                <span class="cov8" title="19">valueExpr := c.Block.ParseContext().ParseExpression(matches[1])

                // Create condition: left == value
                condition := liquid.NewCondition(c.left, "==", valueExpr)
                condition.Attach(body)

                // Wrap in caseCondition to implement CaseBlock
                caseCond := &amp;caseCondition{Condition: condition}

                // Add to blocks
                c.blocks = append(c.blocks, caseCond)

                // Get remaining markup
                if len(matches) &gt; 2 &amp;&amp; matches[2] != "" </span><span class="cov2" title="2">{
                        remainingMarkup = strings.TrimSpace(matches[2])
                }</span> else<span class="cov8" title="17"> {
                        remainingMarkup = ""
                }</span>
        }

        <span class="cov8" title="18">return nil</span>
}

// recordElseCondition records an else condition.
func (c *CaseTag) recordElseCondition(markup string) error <span class="cov6" title="8">{
        if strings.TrimSpace(markup) != "" </span><span class="cov1" title="1">{
                return liquid.NewSyntaxError("else tag should not have markup")
        }</span>

        <span class="cov6" title="7">block := liquid.NewElseCondition()
        body := liquid.NewBlockBody()
        block.Attach(body)

        // Wrap in caseElseCondition to implement CaseBlock
        caseElse := &amp;caseElseCondition{ElseCondition: block}
        c.blocks = append(c.blocks, caseElse)

        return nil</span>
}

// RenderToOutputBuffer renders the case tag.
func (c *CaseTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov7" title="11">{
        ctx := context.Context().(*liquid.Context)
        executeElseBlock := true

        for _, block := range c.blocks </span><span class="cov8" title="17">{
                if block.IsElse() </span><span class="cov4" title="4">{
                        if executeElseBlock </span><span class="cov4" title="4">{
                                if attachment, ok := block.Attachment().(*liquid.BlockBody); ok </span><span class="cov4" title="4">{
                                        attachment.RenderToOutputBuffer(context, output)
                                }</span>
                        }
                        <span class="cov4" title="4">continue</span>
                }

                <span class="cov7" title="13">result, err := block.Evaluate(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        errorMsg := context.HandleError(err, nil)
                        *output += errorMsg
                        return
                }</span>

                <span class="cov7" title="13">resultVal := liquid.ToLiquidValue(result)
                if resultVal != nil &amp;&amp; resultVal != false &amp;&amp; resultVal != "" </span><span class="cov4" title="4">{
                        if attachment, ok := block.Attachment().(*liquid.BlockBody); ok </span><span class="cov4" title="4">{
                                attachment.RenderToOutputBuffer(context, output)
                        }</span>
                        <span class="cov4" title="4">return</span>
                }
        }
}

// Blank returns true if all blocks are blank.
func (c *CaseTag) Blank() bool <span class="cov6" title="10">{
        return c.Block.Blank()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        commentLiquidTagToken      = regexp.MustCompile(`^\s*(\w+)\s*(.*?)$`)
        commentFullToken           = regexp.MustCompile(`^{%-?(\s*)(\w+)(\s*)(.*?)-?%}$`)
        commentWhitespaceOrNothing = regexp.MustCompile(`^\s*$`)
)

// CommentTag represents a comment block tag that prevents content from being rendered.
type CommentTag struct {
        *liquid.Block
}

// NewCommentTag creates a new CommentTag.
func NewCommentTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*CommentTag, error) <span class="cov8" title="14">{
        block := liquid.NewBlock(tagName, markup, parseContext)
        return &amp;CommentTag{
                Block: block,
        }, nil
}</span>

// RenderToOutputBuffer renders the comment tag (does nothing - comments don't render).
func (c *CommentTag) RenderToOutputBuffer(context liquid.TagContext, output *string) {<span class="cov3" title="3">
        // Comments don't render anything
}</span>

// UnknownTag handles unknown tags (comments ignore all tags except endcomment).
func (c *CommentTag) UnknownTag(tagName, markup string, tokenizer *liquid.Tokenizer) error <span class="cov1" title="1">{
        // Comments ignore unknown tags
        return nil
}</span>

// Blank returns true since comment tags are blank.
func (c *CommentTag) Blank() bool <span class="cov4" title="4">{
        return true
}</span>

// Parse parses the comment block with special handling for nested comments and raw tags.
func (c *CommentTag) Parse(tokenizer *liquid.Tokenizer) error <span class="cov7" title="10">{
        parseContext := c.ParseContext()

        // Check depth (blockMaxDepth is 100, defined in liquid/block.go)
        if parseContext.Depth() &gt;= 100 </span><span class="cov1" title="1">{
                return liquid.NewStackLevelError("Nesting too deep")
        }</span>

        <span class="cov6" title="9">parseContext.IncrementDepth()
        defer parseContext.DecrementDepth()

        commentTagDepth := 1

        for </span><span class="cov10" title="29">{
                token := tokenizer.Shift()
                if token == "" </span><span class="cov1" title="1">{
                        break</span>
                }

                // Extract tag name from token
                <span class="cov9" title="28">var tagName string
                if tokenizer.ForLiquidTag() </span><span class="cov1" title="1">{
                        if token == "" || commentWhitespaceOrNothing.MatchString(token) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="1">matches := commentLiquidTagToken.FindStringSubmatch(token)
                        if len(matches) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov1" title="1">tagName = matches[1]</span>
                } else<span class="cov9" title="27"> {
                        if !strings.HasPrefix(token, "{%") </span><span class="cov7" title="13">{
                                continue</span>
                        }

                        <span class="cov8" title="14">matches := commentFullToken.FindStringSubmatch(token)
                        if len(matches) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="14">tagName = matches[2]</span>
                }

                <span class="cov8" title="15">switch tagName </span>{
                case "raw":<span class="cov1" title="1">
                        err := c.parseRawTagBody(tokenizer)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case "comment":<span class="cov3" title="3">
                        commentTagDepth++</span>
                case "endcomment":<span class="cov7" title="11">
                        commentTagDepth--
                        if commentTagDepth == 0 </span><span class="cov6" title="8">{
                                // Handle whitespace trimming
                                if !tokenizer.ForLiquidTag() &amp;&amp; len(token) &gt;= 3 </span><span class="cov6" title="7">{
                                        if token[len(token)-3] == '-' </span><span class="cov1" title="1">{
                                                parseContext.SetTrimWhitespace(true)
                                        }</span>
                                }
                                <span class="cov6" title="8">return nil</span>
                        }
                }
        }

        // Tag never closed
        <span class="cov1" title="1">return c.RaiseTagNeverClosed()</span>
}

// parseRawTagBody parses the body of a raw tag within a comment.
func (c *CommentTag) parseRawTagBody(tokenizer *liquid.Tokenizer) error <span class="cov4" title="4">{
        for </span><span class="cov6" title="7">{
                token := tokenizer.Shift()
                if token == "" </span><span class="cov1" title="1">{
                        break</span>
                }

                // Check for endraw
                <span class="cov5" title="6">if strings.HasPrefix(token, "{%") &amp;&amp; strings.HasSuffix(token, "%}") </span><span class="cov4" title="4">{
                        tokenContent := strings.TrimPrefix(token, "{%")
                        tokenContent = strings.TrimSuffix(tokenContent, "%}")
                        tokenContent = strings.TrimSpace(tokenContent)

                        if tokenContent == "endraw" || strings.HasPrefix(tokenContent, "endraw ") </span><span class="cov3" title="3">{
                                return nil
                        }</span>
                }
        }

        <span class="cov1" title="1">return liquid.NewSyntaxError("tag raw was never closed")</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package tags

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// ContinueTag represents a continue tag that causes a for loop to skip to the next iteration.
type ContinueTag struct {
        *liquid.Tag
}

// NewContinueTag creates a new ContinueTag.
func NewContinueTag(tagName, markup string, parseContext liquid.ParseContextInterface) *ContinueTag <span class="cov10" title="3">{
        return &amp;ContinueTag{
                Tag: liquid.NewTag(tagName, markup, parseContext),
        }
}</span>

// RenderToOutputBuffer renders the continue tag by pushing a continue interrupt.
func (c *ContinueTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov6" title="2">{
        interrupt := liquid.NewContinueInterrupt()
        context.PushInterrupt(interrupt)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        cycleSimpleSyntax   = regexp.MustCompile(`^` + liquid.QuotedFragment.String())
        cycleNamedSyntax    = regexp.MustCompile(`^(` + liquid.QuotedFragment.String() + `)\s*\:\s*(.*)`)
        cycleUnnamedPattern = regexp.MustCompile(`\w+:0x[0-9a-fA-F]{8}`)
)

// CycleTag represents a cycle tag that loops through a group of strings.
type CycleTag struct {
        *liquid.Tag
        variables []interface{}
        name      interface{}
        isNamed   bool
}

// NewCycleTag creates a new CycleTag.
func NewCycleTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*CycleTag, error) <span class="cov7" title="9">{
        ct := &amp;CycleTag{
                Tag: liquid.NewTag(tagName, markup, parseContext),
        }

        // Parse markup
        err := ct.parseMarkup(markup, parseContext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="8">return ct, nil</span>
}

// Variables returns the cycle variables.
func (c *CycleTag) Variables() []interface{} <span class="cov5" title="4">{
        return c.variables
}</span>

// Named returns true if this is a named cycle.
func (c *CycleTag) Named() bool <span class="cov3" title="2">{
        return c.isNamed
}</span>

// RenderToOutputBuffer renders the cycle tag.
func (c *CycleTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov5" title="5">{
        ctx := context.Context().(*liquid.Context)
        registers := ctx.Registers()

        // Get or initialize cycle register
        cycleReg := registers.Get("cycle")
        var cycleMap map[string]interface{}
        if cycleReg == nil </span><span class="cov3" title="2">{
                cycleMap = make(map[string]interface{})
                registers.Set("cycle", cycleMap)
        }</span> else<span class="cov4" title="3"> {
                cycleMap = cycleReg.(map[string]interface{})
        }</span>

        // Evaluate cycle name/key
        <span class="cov5" title="5">key := liquid.ToS(context.Evaluate(c.name), nil)

        // Get current iteration
        iteration, ok := cycleMap[key]
        if !ok </span><span class="cov3" title="2">{
                iteration = 0
        }</span>
        <span class="cov5" title="5">iter := 0
        switch v := iteration.(type) </span>{
        case int:<span class="cov5" title="5">
                iter = v</span>
        case float64:<span class="cov0" title="0">
                iter = int(v)</span>
        }

        // Get value at current iteration
        <span class="cov5" title="5">if iter &gt;= len(c.variables) </span><span class="cov0" title="0">{
                iter = 0
        }</span>
        <span class="cov5" title="5">val := context.Evaluate(c.variables[iter])

        // Convert to string
        var valStr string
        if arr, ok := val.([]interface{}); ok </span><span class="cov0" title="0">{
                // Join array
                parts := make([]string, len(arr))
                for i, item := range arr </span><span class="cov0" title="0">{
                        parts[i] = liquid.ToS(item, nil)
                }</span>
                <span class="cov0" title="0">valStr = strings.Join(parts, "")</span>
        } else<span class="cov5" title="5"> {
                valStr = liquid.ToS(val, nil)
        }</span>
        <span class="cov5" title="5">*output += valStr

        // Increment iteration
        iter++
        if iter &gt;= len(c.variables) </span><span class="cov1" title="1">{
                iter = 0
        }</span>
        <span class="cov5" title="5">cycleMap[key] = iter</span>
}

func (c *CycleTag) parseMarkup(markup string, parseContext liquid.ParseContextInterface) error <span class="cov7" title="9">{
        // Try named syntax first
        if matches := cycleNamedSyntax.FindStringSubmatch(markup); len(matches) &gt;= 3 </span><span class="cov3" title="2">{
                c.name = parseContext.ParseExpression(matches[1])
                c.isNamed = true
                c.variables = c.variablesFromString(matches[2], parseContext)
                return nil
        }</span>

        // Try simple syntax
        <span class="cov6" title="7">if cycleSimpleSyntax.MatchString(markup) </span><span class="cov6" title="6">{
                c.variables = c.variablesFromString(markup, parseContext)
                // Generate name from variables
                c.name = liquid.ToS(c.variables, nil)
                c.isNamed = !cycleUnnamedPattern.MatchString(c.name.(string))
                return nil
        }</span>

        // Syntax error
        <span class="cov1" title="1">var locale *liquid.I18n
        if pc, ok := parseContext.(*liquid.ParseContext); ok </span><span class="cov1" title="1">{
                locale = pc.Locale()
                msg := locale.Translate("errors.syntax.cycle", map[string]interface{}{})
                return liquid.NewSyntaxError(msg)
        }</span>
        <span class="cov0" title="0">return liquid.NewSyntaxError("Liquid syntax error: cycle")</span>
}

func (c *CycleTag) variablesFromString(markup string, parseContext liquid.ParseContextInterface) []interface{} <span class="cov7" title="8">{
        parts := strings.Split(markup, ",")
        variables := make([]interface{}, 0, len(parts))

        for _, part := range parts </span><span class="cov10" title="21">{
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov1" title="1">{
                        continue</span>
                }

                // Match quoted fragment - FindStringSubmatch returns full match and submatches
                <span class="cov9" title="20">matches := liquid.QuotedFragment.FindStringSubmatch(part)
                if len(matches) &gt; 0 </span><span class="cov9" title="20">{
                        // Use the first match (full match) or first submatch if available
                        matchStr := part
                        if len(matches) &gt; 1 &amp;&amp; matches[1] != "" </span><span class="cov0" title="0">{
                                matchStr = matches[1]
                        }</span> else<span class="cov9" title="20"> if matches[0] != "" </span><span class="cov9" title="20">{
                                matchStr = matches[0]
                        }</span>
                        <span class="cov9" title="20">expr := parseContext.ParseExpression(matchStr)
                        variables = append(variables, expr)</span>
                } else<span class="cov0" title="0"> {
                        // If no match, parse the part as-is
                        expr := parseContext.ParseExpression(part)
                        variables = append(variables, expr)
                }</span>
        }

        <span class="cov7" title="8">return variables</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package tags

import (
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

// DecrementTag represents a decrement tag that creates a counter variable.
type DecrementTag struct {
        *liquid.Tag
        variableName string
}

// NewDecrementTag creates a new DecrementTag.
func NewDecrementTag(tagName, markup string, parseContext liquid.ParseContextInterface) *DecrementTag <span class="cov6" title="3">{
        return &amp;DecrementTag{
                Tag:          liquid.NewTag(tagName, markup, parseContext),
                variableName: strings.TrimSpace(markup),
        }
}</span>

// VariableName returns the variable name.
func (d *DecrementTag) VariableName() string <span class="cov1" title="1">{
        return d.variableName
}</span>

// RenderToOutputBuffer renders the decrement tag.
func (d *DecrementTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov10" title="7">{
        // Get counter environment (first environment)
        ctx := context.Context().(*liquid.Context)
        environments := ctx.Scopes()
        if len(environments) == 0 </span><span class="cov0" title="0">{
                environments = []map[string]interface{}{make(map[string]interface{})}
        }</span>

        <span class="cov10" title="7">counterEnv := environments[0]
        value, ok := counterEnv[d.variableName]
        if !ok </span><span class="cov4" title="2">{
                value = 0
        }</span>

        // Convert to int
        <span class="cov10" title="7">var intValue int
        switch v := value.(type) </span>{
        case int:<span class="cov10" title="7">
                intValue = v</span>
        case float64:<span class="cov0" title="0">
                intValue = int(v)</span>
        default:<span class="cov0" title="0">
                intValue = 0</span>
        }

        // Decrement first, then output
        <span class="cov10" title="7">intValue--
        counterEnv[d.variableName] = intValue
        *output += liquid.ToS(intValue, nil)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        docNoUnexpectedArgs         = regexp.MustCompile(`^\s*$`)
        docFullTokenPossiblyInvalid = regexp.MustCompile(`^{%-?(\s*)(\w+)(\s*)(.*?)-?%}$`)
)

// DocTag represents a doc block tag that stores documentation without rendering it.
type DocTag struct {
        *liquid.Block
        body string
}

// NewDocTag creates a new DocTag.
func NewDocTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*DocTag, error) <span class="cov10" title="9">{
        // Validate markup is empty
        if !docNoUnexpectedArgs.MatchString(markup) </span><span class="cov1" title="1">{
                var locale *liquid.I18n
                if pc, ok := parseContext.(*liquid.ParseContext); ok </span><span class="cov1" title="1">{
                        locale = pc.Locale()
                        msg := locale.Translate("errors.syntax.block_tag_unexpected_args", map[string]interface{}{"tag": tagName})
                        return nil, liquid.NewSyntaxError(msg)
                }</span>
                <span class="cov0" title="0">return nil, liquid.NewSyntaxError("Liquid syntax error: block tag unexpected args")</span>
        }

        <span class="cov9" title="8">block := liquid.NewBlock(tagName, markup, parseContext)
        return &amp;DocTag{
                Block: block,
                body:  "",
        }, nil</span>
}

// RenderToOutputBuffer renders the doc tag (does nothing - docs don't render).
func (d *DocTag) RenderToOutputBuffer(context liquid.TagContext, output *string) {<span class="cov3" title="2">
        // Docs don't render anything
}</span>

// Blank returns true if body is empty.
func (d *DocTag) Blank() bool <span class="cov5" title="3">{
        return d.body == ""
}</span>

// Nodelist returns the nodelist (just the body as a string).
func (d *DocTag) Nodelist() []interface{} <span class="cov5" title="3">{
        return []interface{}{d.body}
}</span>

// Parse parses the doc block body.
func (d *DocTag) Parse(tokenizer *liquid.Tokenizer) error <span class="cov7" title="5">{
        d.body = ""
        blockDelimiter := d.BlockDelimiter()
        tagName := d.TagName()

        for </span><span class="cov10" title="9">{
                token := tokenizer.Shift()
                if token == "" </span><span class="cov0" title="0">{
                        break</span>
                }

                // Extract tag name from token
                <span class="cov10" title="9">var foundTagName string
                var leadingWhitespace string

                if strings.HasPrefix(token, "{%") </span><span class="cov7" title="5">{
                        matches := docFullTokenPossiblyInvalid.FindStringSubmatch(token)
                        if len(matches) &gt; 0 </span><span class="cov7" title="5">{
                                leadingWhitespace = matches[1]
                                foundTagName = matches[2]
                        }</span>
                }

                // Raise error if nested doc tag found
                <span class="cov10" title="9">if foundTagName == tagName </span><span class="cov1" title="1">{
                        var locale *liquid.I18n
                        if pc, ok := d.ParseContext().(*liquid.ParseContext); ok </span><span class="cov1" title="1">{
                                locale = pc.Locale()
                                msg := locale.Translate("errors.syntax.doc_invalid_nested", map[string]interface{}{})
                                return liquid.NewSyntaxError(msg)
                        }</span>
                        <span class="cov0" title="0">return liquid.NewSyntaxError("Liquid syntax error: doc invalid nested")</span>
                }

                <span class="cov9" title="8">if foundTagName == blockDelimiter </span><span class="cov6" title="4">{
                        // Handle whitespace trimming
                        if len(token) &gt;= 3 &amp;&amp; token[len(token)-3] == '-' </span><span class="cov0" title="0">{
                                d.ParseContext().SetTrimWhitespace(true)
                        }</span>
                        // Include leading whitespace in body if present
                        <span class="cov6" title="4">if leadingWhitespace != "" </span><span class="cov6" title="4">{
                                d.body += leadingWhitespace
                        }</span>
                        <span class="cov6" title="4">return nil</span>
                }

                <span class="cov6" title="4">if token != "" </span><span class="cov6" title="4">{
                        d.body += token
                }</span>
        }

        // Tag never closed
        <span class="cov0" title="0">return d.RaiseTagNeverClosed()</span>
}

// RaiseTagNeverClosed raises an error for a tag that was never closed.
func (d *DocTag) RaiseTagNeverClosed() error <span class="cov1" title="1">{
        return liquid.NewSyntaxError("tag " + d.BlockName() + " was never closed")
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package tags

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// EchoTag represents an echo tag that outputs an expression.
type EchoTag struct {
        *liquid.Tag
        variable *liquid.Variable
}

// NewEchoTag creates a new EchoTag.
func NewEchoTag(tagName, markup string, parseContext liquid.ParseContextInterface) *EchoTag <span class="cov10" title="2">{
        return &amp;EchoTag{
                Tag:      liquid.NewTag(tagName, markup, parseContext),
                variable: liquid.NewVariable(markup, parseContext),
        }
}</span>

// RenderToOutputBuffer renders the echo tag by rendering the variable.
func (e *EchoTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov1" title="1">{
        // Render the variable and append to output
        val := e.variable.Render(context)
        *output += liquid.ToS(val, nil)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        // forSyntax matches: variable in collection [reversed]
        // VariableSegment is a single character pattern, so we use + after it
        // QuotedFragment already has +, so we don't add another
        forSyntax = regexp.MustCompile(`^(` + liquid.VariableSegment.String() + `+)\s+in\s+(` + liquid.QuotedFragment.String() + `)\s*(reversed)?`)
)

// ForTag represents a for loop tag.
type ForTag struct {
        *liquid.Block
        variableName   string
        collectionName interface{} // Expression
        limit          interface{} // Expression or nil
        from           interface{} // Expression, :continue, or nil
        reversed       bool
        name           string // "#{variable_name}-#{collection_name}"
        forBlock       *liquid.BlockBody
        elseBlock      *liquid.BlockBody
}

// NewForTag creates a new ForTag.
func NewForTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*ForTag, error) <span class="cov10" title="37">{
        block := liquid.NewBlock(tagName, markup, parseContext)

        tag := &amp;ForTag{
                Block:     block,
                from:      nil,
                limit:     nil,
                reversed:  false,
                forBlock:  liquid.NewBlockBody(),
                elseBlock: nil,
        }

        // Parse markup
        err := tag.parseMarkup(markup, parseContext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="36">return tag, nil</span>
}

// parseMarkup parses the for tag markup.
func (f *ForTag) parseMarkup(markup string, parseContext liquid.ParseContextInterface) error <span class="cov10" title="37">{
        matches := forSyntax.FindStringSubmatch(markup)
        if len(matches) == 0 </span><span class="cov1" title="1">{
                return liquid.NewSyntaxError("invalid for tag syntax")
        }</span>

        <span class="cov9" title="36">f.variableName = matches[1]
        collectionNameStr := matches[2]
        if len(matches) &gt; 3 &amp;&amp; matches[3] == "reversed" </span><span class="cov1" title="1">{
                f.reversed = true
        }</span>

        // Parse collection name as expression
        <span class="cov9" title="36">f.collectionName = parseContext.ParseExpression(collectionNameStr)
        f.name = f.variableName + "-" + collectionNameStr

        // Parse attributes (limit, offset)
        attributeMatches := liquid.TagAttributes.FindAllStringSubmatch(markup, -1)
        for _, match := range attributeMatches </span><span class="cov7" title="13">{
                if len(match) &gt;= 3 </span><span class="cov7" title="13">{
                        key := strings.TrimSpace(match[1])
                        value := strings.TrimSpace(match[2])
                        // Remove quotes if present
                        if len(value) &gt; 0 &amp;&amp; (value[0] == '"' || value[0] == '\'') </span><span class="cov1" title="1">{
                                value = value[1 : len(value)-1]
                        }</span>
                        <span class="cov7" title="13">err := f.setAttribute(key, value, parseContext)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov9" title="36">return nil</span>
}

// setAttribute sets an attribute (limit or offset).
func (f *ForTag) setAttribute(key, expr string, parseContext liquid.ParseContextInterface) error <span class="cov7" title="13">{
        switch key </span>{
        case "offset":<span class="cov5" title="6">
                if expr == "continue" </span><span class="cov2" title="2">{
                        f.from = "continue" // Special marker
                }</span> else<span class="cov4" title="4"> {
                        f.from = parseContext.ParseExpression(expr)
                }</span>
        case "limit":<span class="cov5" title="7">
                f.limit = parseContext.ParseExpression(expr)</span>
        }
        <span class="cov7" title="13">return nil</span>
}

// Nodelist returns the nodelist (for_block and optional else_block).
func (f *ForTag) Nodelist() []interface{} <span class="cov2" title="2">{
        if f.elseBlock != nil </span><span class="cov1" title="1">{
                return []interface{}{f.forBlock, f.elseBlock}
        }</span>
        <span class="cov1" title="1">return []interface{}{f.forBlock}</span>
}

// UnknownTag handles else tags.
func (f *ForTag) UnknownTag(tagName, markup string, tokenizer *liquid.Tokenizer) error <span class="cov5" title="6">{
        if tagName == "else" </span><span class="cov4" title="4">{
                f.elseBlock = liquid.NewBlockBody()
                return nil
        }</span>
        <span class="cov2" title="2">return f.Block.UnknownTag(tagName, markup, tokenizer)</span>
}

// Parse parses the for block.
func (f *ForTag) Parse(tokenizer *liquid.Tokenizer) error <span class="cov7" title="13">{
        // Parse for block body
        shouldContinue, err := f.parseBody(tokenizer, f.forBlock)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If we didn't find endfor, parse else block
        <span class="cov7" title="13">if shouldContinue &amp;&amp; f.elseBlock != nil </span><span class="cov2" title="2">{
                _, err = f.parseBody(tokenizer, f.elseBlock)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Remove blank strings if block is blank
        <span class="cov7" title="13">if f.Blank() </span><span class="cov7" title="13">{
                if f.elseBlock != nil </span><span class="cov2" title="2">{
                        f.elseBlock.RemoveBlankStrings()
                }</span>
                <span class="cov7" title="13">f.forBlock.RemoveBlankStrings()</span>
        }

        <span class="cov7" title="13">return nil</span>
}

// parseBody parses a block body (for_block or else_block).
// Returns (shouldContinue, error) where shouldContinue is true if we should continue parsing (didn't find endfor).
func (f *ForTag) parseBody(tokenizer *liquid.Tokenizer, body *liquid.BlockBody) (bool, error) <span class="cov8" title="19">{
        parseContext := f.ParseContext()
        if parseContext.Depth() &gt;= 100 </span><span class="cov1" title="1">{
                return false, liquid.NewStackLevelError("Nesting too deep")
        }</span>

        <span class="cov8" title="18">parseContext.IncrementDepth()
        defer parseContext.DecrementDepth()

        foundEndTag := false
        unknownTagHandler := func(endTagName, endTagMarkup string) bool </span><span class="cov8" title="18">{
                if endTagName == f.BlockDelimiter() </span><span class="cov7" title="13">{
                        foundEndTag = true
                        return false // Stop parsing
                }</span>
                <span class="cov5" title="5">if endTagName == "" </span><span class="cov1" title="1">{
                        return false // Tag never closed
                }</span>
                <span class="cov4" title="4">if endTagName == "else" </span><span class="cov3" title="3">{
                        // Handle else - UnknownTag will create elseBlock if needed
                        err := f.UnknownTag(endTagName, endTagMarkup, tokenizer)
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov3" title="3">return false</span> // Stop parsing current block, continue with else block
                }
                // Unknown tag - let block handle it
                <span class="cov1" title="1">return f.UnknownTag(endTagName, endTagMarkup, tokenizer) == nil</span>
        }

        <span class="cov8" title="18">err := body.Parse(tokenizer, parseContext, unknownTagHandler)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Return true if we should continue (didn't find endfor)
        <span class="cov8" title="18">return !foundEndTag, nil</span>
}

// RenderToOutputBuffer renders the for tag.
func (f *ForTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov5" title="5">{
        segment := f.collectionSegment(context)

        if len(segment) == 0 </span><span class="cov1" title="1">{
                f.renderElse(context, output)
        }</span> else<span class="cov4" title="4"> {
                f.renderSegment(context, output, segment)
        }</span>
}

// collectionSegment gets the segment of the collection to iterate over.
func (f *ForTag) collectionSegment(context liquid.TagContext) []interface{} <span class="cov7" title="16">{
        registers := context.Registers()

        // Get or create offsets map
        var offsets map[string]interface{}
        if offsetsVal := registers.Get("for"); offsetsVal != nil </span><span class="cov3" title="3">{
                if m, ok := offsetsVal.(map[string]interface{}); ok </span><span class="cov2" title="2">{
                        offsets = m
                }</span> else<span class="cov1" title="1"> {
                        offsets = make(map[string]interface{})
                        registers.Set("for", offsets)
                }</span>
        } else<span class="cov7" title="13"> {
                offsets = make(map[string]interface{})
                registers.Set("for", offsets)
        }</span>

        // Calculate from (offset)
        <span class="cov7" title="16">var from int
        if f.from == "continue" </span><span class="cov2" title="2">{
                // Get from offsets
                if offsetVal, ok := offsets[f.name]; ok </span><span class="cov2" title="2">{
                        if offsetInt, ok := offsetVal.(int); ok </span><span class="cov1" title="1">{
                                from = offsetInt
                        }</span>
                }
        } else<span class="cov7" title="14"> if f.from != nil </span><span class="cov3" title="3">{
                fromValue := context.Evaluate(f.from)
                if fromValue == nil </span><span class="cov1" title="1">{
                        from = 0
                }</span> else<span class="cov2" title="2"> {
                        var err error
                        from, err = liquid.ToInteger(fromValue)
                        if err != nil </span><span class="cov1" title="1">{
                                from = 0
                        }</span>
                }
        }

        // Evaluate collection
        <span class="cov7" title="16">collection := context.Evaluate(f.collectionName)
        if collection == nil </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        // Convert Range to array if needed
        <span class="cov7" title="15">if r, ok := collection.(*liquid.Range); ok </span><span class="cov1" title="1">{
                // Convert range to array
                arr := []interface{}{}
                for i := r.Start; i &lt;= r.End; i++ </span><span class="cov5" title="5">{
                        arr = append(arr, i)
                }</span>
                <span class="cov1" title="1">collection = arr</span>
        }

        // Calculate to (limit)
        <span class="cov7" title="15">var to *int
        if f.limit != nil </span><span class="cov5" title="5">{
                limitValue := context.Evaluate(f.limit)
                if limitValue != nil </span><span class="cov4" title="4">{
                        limitInt, err := liquid.ToInteger(limitValue)
                        if err == nil </span><span class="cov3" title="3">{
                                toVal := from + limitInt
                                to = &amp;toVal
                        }</span>
                }
        }

        // Slice collection
        <span class="cov7" title="15">segment := liquid.SliceCollection(collection, from, to)

        // Reverse if needed
        if f.reversed </span><span class="cov1" title="1">{
                for i, j := 0, len(segment)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov1" title="1">{
                        segment[i], segment[j] = segment[j], segment[i]
                }</span>
        }

        // Store offset for continue
        <span class="cov7" title="15">offsets[f.name] = from + len(segment)

        return segment</span>
}

// renderSegment renders the segment.
func (f *ForTag) renderSegment(context liquid.TagContext, output *string, segment []interface{}) <span class="cov6" title="10">{
        registers := context.Registers()

        // Get or create for_stack
        var forStack []*liquid.ForloopDrop
        if stackVal := registers.Get("for_stack"); stackVal != nil </span><span class="cov3" title="3">{
                if stack, ok := stackVal.([]*liquid.ForloopDrop); ok </span><span class="cov2" title="2">{
                        forStack = stack
                }</span> else<span class="cov1" title="1"> {
                        forStack = []*liquid.ForloopDrop{}
                        registers.Set("for_stack", forStack)
                }</span>
        } else<span class="cov5" title="7"> {
                forStack = []*liquid.ForloopDrop{}
                registers.Set("for_stack", forStack)
        }</span>

        <span class="cov6" title="10">length := len(segment)

        // Get parent loop (if any)
        var parentLoop *liquid.ForloopDrop
        if len(forStack) &gt; 0 </span><span class="cov1" title="1">{
                parentLoop = forStack[len(forStack)-1]
        }</span>

        // Create forloop drop
        <span class="cov6" title="10">loopVars := liquid.NewForloopDrop(f.name, length, parentLoop)

        // Push to stack
        forStack = append(forStack, loopVars)
        registers.Set("for_stack", forStack)

        // Get underlying Context for Stack
        ctx := context.Context().(*liquid.Context)

        // Create new scope and iterate
        ctx.Stack(make(map[string]interface{}), func() </span><span class="cov6" title="10">{
                // Set forloop in context
                ctx.Set("forloop", loopVars)

                // Iterate over segment
                for _, item := range segment </span><span class="cov9" title="27">{
                        // Set variable
                        ctx.Set(f.variableName, item)

                        // Render for block
                        f.forBlock.RenderToOutputBuffer(context, output)

                        // Increment loop
                        loopVars.Increment()

                        // Handle interrupts
                        if ctx.Interrupt() </span><span class="cov2" title="2">{
                                interrupt := ctx.PopInterrupt()
                                switch interrupt.(type) </span>{
                                case *liquid.BreakInterrupt:<span class="cov1" title="1">
                                        break</span>
                                case *liquid.ContinueInterrupt:<span class="cov1" title="1">
                                        continue</span>
                                }
                        }
                }
        })

        // Pop from stack
        <span class="cov6" title="10">forStack = forStack[:len(forStack)-1]
        registers.Set("for_stack", forStack)</span>
}

// renderElse renders the else block if collection is empty.
func (f *ForTag) renderElse(context liquid.TagContext, output *string) <span class="cov1" title="1">{
        if f.elseBlock != nil </span><span class="cov1" title="1">{
                f.elseBlock.RenderToOutputBuffer(context, output)
        }</span>
}

// VariableName returns the variable name.
func (f *ForTag) VariableName() string <span class="cov1" title="1">{
        return f.variableName
}</span>

// CollectionName returns the collection name expression.
func (f *ForTag) CollectionName() interface{} <span class="cov1" title="1">{
        return f.collectionName
}</span>

// Limit returns the limit expression.
func (f *ForTag) Limit() interface{} <span class="cov2" title="2">{
        return f.limit
}</span>

// From returns the from/offset expression.
func (f *ForTag) From() interface{} <span class="cov1" title="1">{
        return f.from
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package tags

import (
        "regexp"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        ifSyntax = regexp.MustCompile(`(` + liquid.QuotedFragment.String() + `)\s*([=!&lt;&gt;a-z_]+)?\s*(` + liquid.QuotedFragment.String() + `)?`)
)

// ConditionBlock represents a condition with its attachment.
type ConditionBlock interface {
        Evaluate(context liquid.ConditionContext) (bool, error)
        Attachment() interface{}
        Attach(attachment interface{})
}

// IfTag represents an if block tag with support for elsif and else.
type IfTag struct {
        *liquid.Block
        blocks []ConditionBlock
}

// NewIfTag creates a new IfTag.
func NewIfTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*IfTag, error) <span class="cov8" title="31">{
        block := liquid.NewBlock(tagName, markup, parseContext)

        // Parse the initial condition
        condition, err := parseIfCondition(markup, parseContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create attachment for the first block
        <span class="cov8" title="31">attachment := liquid.NewBlockBody()
        condition.Attach(attachment)

        return &amp;IfTag{
                Block:  block,
                blocks: []ConditionBlock{condition},
        }, nil</span>
}

// Blocks returns the condition blocks.
func (i *IfTag) Blocks() []ConditionBlock <span class="cov6" title="13">{
        return i.blocks
}</span>

// Nodelist returns the nodelist from all blocks.
func (i *IfTag) Nodelist() []interface{} <span class="cov1" title="1">{
        nodelist := []interface{}{}
        for _, block := range i.blocks </span><span class="cov1" title="1">{
                if attachment, ok := block.Attachment().(*liquid.BlockBody); ok </span><span class="cov1" title="1">{
                        nodelist = append(nodelist, attachment.Nodelist()...)
                }</span>
        }
        <span class="cov1" title="1">return nodelist</span>
}

// UnknownTag handles elsif and else tags.
func (i *IfTag) UnknownTag(tagName, markup string, tokenizer *liquid.Tokenizer) error <span class="cov4" title="4">{
        if tagName == "elsif" || tagName == "else" </span><span class="cov2" title="2">{
                return i.pushBlock(tagName, markup)
        }</span>
        <span class="cov2" title="2">return i.Block.UnknownTag(tagName, markup, tokenizer)</span>
}

// Parse parses the if block with support for elsif and else.
// Following Ruby: while parse_body(@blocks.last.attachment, tokens); end
func (i *IfTag) Parse(tokenizer *liquid.Tokenizer) error <span class="cov8" title="25">{
        // Parse blocks in sequence - when elsif/else is found, a new block is created
        // and parsing continues with that new block's attachment
        // Ruby: while parse_body(@blocks.last.attachment, tokens); end
        for </span><span class="cov9" title="38">{
                currentBlockCount := len(i.blocks)
                currentBlock := i.blocks[currentBlockCount-1]

                shouldContinue, err := i.parseBodyForBlock(tokenizer, currentBlock)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If a new block was created (elsif/else), continue parsing it
                // The while loop will call parseBodyForBlock again with the new block
                <span class="cov9" title="37">if len(i.blocks) &gt; currentBlockCount </span><span class="cov6" title="13">{
                        continue</span>
                }

                // If shouldContinue is false, we found endif, so stop
                <span class="cov8" title="24">if !shouldContinue </span><span class="cov8" title="24">{
                        break</span>
                }
        }

        // Remove blank strings if block is blank (Ruby: block.attachment.remove_blank_strings if blank?)
        <span class="cov8" title="24">if i.Blank() </span><span class="cov8" title="24">{
                for _, block := range i.blocks </span><span class="cov9" title="37">{
                        if attachment, ok := block.Attachment().(*liquid.BlockBody); ok </span><span class="cov9" title="37">{
                                attachment.RemoveBlankStrings()
                        }</span>
                }
        }

        <span class="cov8" title="24">return nil</span>
}

// parseBodyForBlock parses the body for a specific condition block.
// Returns (shouldContinue, error) where shouldContinue is true if we should continue parsing
// (either more content in this block, or a new elsif/else block was created)
func (i *IfTag) parseBodyForBlock(tokenizer *liquid.Tokenizer, condition ConditionBlock) (bool, error) <span class="cov9" title="45">{
        parseContext := i.ParseContext()
        attachment, ok := condition.Attachment().(*liquid.BlockBody)
        if !ok </span><span class="cov1" title="1">{
                return false, liquid.NewSyntaxError("invalid attachment for condition block")
        }</span>

        // Check depth
        <span class="cov9" title="44">if parseContext.Depth() &gt;= 100 </span><span class="cov1" title="1">{
                return false, liquid.NewStackLevelError("Nesting too deep")
        }</span>

        <span class="cov9" title="43">parseContext.IncrementDepth()
        defer parseContext.DecrementDepth()

        foundEndTag := false
        unknownTagHandler := func(endTagName, endTagMarkup string) bool </span><span class="cov9" title="43">{
                if endTagName == i.BlockDelimiter() </span><span class="cov8" title="25">{
                        foundEndTag = true
                        return false // Stop parsing - found endif
                }</span>

                <span class="cov7" title="18">if endTagName == "" </span><span class="cov1" title="1">{
                        // Tag never closed
                        return false
                }</span>

                // Handle elsif and else (Ruby: unknown_tag handles these)
                <span class="cov7" title="17">if endTagName == "elsif" || endTagName == "else" </span><span class="cov7" title="16">{
                        err := i.pushBlock(endTagName, endTagMarkup)
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        // New block created - Parse() will detect this and continue
                        <span class="cov7" title="16">return false</span> // Stop parsing current block
                }

                // Unknown tag - let block handle it
                <span class="cov1" title="1">err := i.UnknownTag(endTagName, endTagMarkup, tokenizer)
                if err != nil </span><span class="cov1" title="1">{
                        // Raise the error (Ruby: raises SyntaxError immediately)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov9" title="43">err := attachment.Parse(tokenizer, parseContext, unknownTagHandler)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // If we found endif, stop parsing (return false)
        // If we created a new block (elsif/else), parseBodyForBlock returns false
        // but Parse() will detect the new block and continue the loop
        // Otherwise, continue parsing this block (return true)
        <span class="cov9" title="42">return !foundEndTag, nil</span>
}

// pushBlock adds a new condition block (elsif or else).
func (i *IfTag) pushBlock(tagName, markup string) error <span class="cov7" title="20">{
        var condition ConditionBlock

        if tagName == "else" </span><span class="cov6" title="10">{
                condition = liquid.NewElseCondition()
        }</span> else<span class="cov6" title="10"> {
                // Parse elsif condition
                elsifCondition, err := parseIfCondition(markup, i.ParseContext())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="10">condition = elsifCondition</span>
        }

        // Create attachment for the new block
        <span class="cov7" title="20">attachment := liquid.NewBlockBody()
        condition.Attach(attachment)

        i.blocks = append(i.blocks, condition)
        return nil</span>
}

// RenderToOutputBuffer renders the if tag.
func (i *IfTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov7" title="20">{
        // Get the underlying Context which implements ConditionContext
        ctx := context.Context().(*liquid.Context)

        for _, block := range i.blocks </span><span class="cov8" title="26">{
                result, err := block.Evaluate(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle error
                        errorMsg := context.HandleError(err, nil)
                        *output += errorMsg
                        return
                }</span>

                // Convert result to liquid value
                <span class="cov8" title="26">resultVal := liquid.ToLiquidValue(result)

                // Check if condition is true
                if resultVal != nil &amp;&amp; resultVal != false &amp;&amp; resultVal != "" </span><span class="cov6" title="10">{
                        // Render the attachment
                        if attachment, ok := block.Attachment().(*liquid.BlockBody); ok </span><span class="cov5" title="9">{
                                attachment.RenderToOutputBuffer(context, output)
                        }</span>
                        <span class="cov6" title="10">return</span>
                }
        }
}

// Blank returns true if all blocks are blank.
func (i *IfTag) Blank() bool <span class="cov8" title="26">{
        return i.Block.Blank()
}</span>

// parseIfCondition parses a condition from markup.
func parseIfCondition(markup string, parseContext liquid.ParseContextInterface) (*liquid.Condition, error) <span class="cov10" title="54">{
        // For now, use simple parsing - can be enhanced later
        matches := ifSyntax.FindStringSubmatch(markup)
        if len(matches) == 0 </span><span class="cov3" title="3">{
                // Try parsing as a simple expression (no operator)
                expr := parseContext.ParseExpression(markup)
                return liquid.NewCondition(expr, "", nil), nil
        }</span>

        <span class="cov9" title="51">left := parseContext.ParseExpression(matches[1])
        operator := matches[2]
        right := interface{}(nil)
        if len(matches) &gt; 3 &amp;&amp; matches[3] != "" </span><span class="cov3" title="3">{
                right = parseContext.ParseExpression(matches[3])
        }</span>

        <span class="cov9" title="51">return liquid.NewCondition(left, operator, right), nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package tags

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// IfchangedTag represents an ifchanged block tag that only renders when content changes.
type IfchangedTag struct {
        *liquid.Block
}

// NewIfchangedTag creates a new IfchangedTag.
func NewIfchangedTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*IfchangedTag, error) <span class="cov7" title="4">{
        block := liquid.NewBlock(tagName, markup, parseContext)
        return &amp;IfchangedTag{
                Block: block,
        }, nil
}</span>

// RenderToOutputBuffer renders the ifchanged tag.
// Only renders if the block output is different from the last rendered output.
func (i *IfchangedTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov10" title="6">{
        // Render block body to temporary buffer
        blockOutput := ""
        i.Block.RenderToOutputBuffer(context, &amp;blockOutput)

        // Get registers
        registers := context.Registers()

        // Get last output from registers
        var lastOutput string
        if lastVal := registers.Get("ifchanged"); lastVal != nil </span><span class="cov6" title="3">{
                if str, ok := lastVal.(string); ok </span><span class="cov6" title="3">{
                        lastOutput = str
                }</span>
        }

        // Only output if different from last output
        <span class="cov10" title="6">if blockOutput != lastOutput </span><span class="cov7" title="4">{
                registers.Set("ifchanged", blockOutput)
                *output += blockOutput
        }</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        // includeSyntax matches: 'filename' [with|for expression] [as alias] [attributes...]
        // Note: QuotedFragment already has +, so we don't add another
        includeSyntax = regexp.MustCompile(`(` + liquid.QuotedFragment.String() + `)(\s+(?:with|for)\s+(` + liquid.QuotedFragment.String() + `))?(\s+(?:as)\s+(` + liquid.VariableSegment.String() + `+))?`)
)

// IncludeTag represents an include tag that renders a partial template.
// Note: This is deprecated in favor of render tag.
type IncludeTag struct {
        *liquid.Tag
        templateNameExpr interface{}            // Expression
        variableNameExpr interface{}            // Expression or nil
        aliasName        string                 // Alias name or ""
        attributes       map[string]interface{} // Attribute expressions
}

// NewIncludeTag creates a new IncludeTag.
func NewIncludeTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*IncludeTag, error) <span class="cov10" title="20">{
        tag := liquid.NewTag(tagName, markup, parseContext)

        includeTag := &amp;IncludeTag{
                Tag:        tag,
                attributes: make(map[string]interface{}),
        }

        // Parse markup
        err := includeTag.parseMarkup(markup, parseContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="20">return includeTag, nil</span>
}

// parseMarkup parses the include tag markup.
func (i *IncludeTag) parseMarkup(markup string, parseContext liquid.ParseContextInterface) error <span class="cov10" title="20">{
        matches := includeSyntax.FindStringSubmatch(markup)
        if len(matches) == 0 </span><span class="cov0" title="0">{
                return liquid.NewSyntaxError("invalid include tag syntax")
        }</span>

        // Template name
        <span class="cov10" title="20">templateNameStr := matches[1]
        i.templateNameExpr = parseContext.ParseExpression(templateNameStr)

        // Variable name (with/for)
        if len(matches) &gt; 3 &amp;&amp; matches[3] != "" </span><span class="cov6" title="6">{
                i.variableNameExpr = parseContext.ParseExpression(matches[3])
        }</span>

        // Alias name (as)
        <span class="cov10" title="20">if len(matches) &gt; 5 &amp;&amp; matches[5] != "" </span><span class="cov4" title="3">{
                i.aliasName = matches[5]
        }</span>

        // Parse attributes
        <span class="cov10" title="20">attributeMatches := liquid.TagAttributes.FindAllStringSubmatch(markup, -1)
        for _, match := range attributeMatches </span><span class="cov3" title="2">{
                if len(match) &gt;= 3 </span><span class="cov3" title="2">{
                        key := strings.TrimSpace(match[1])
                        value := strings.TrimSpace(match[2])
                        // Remove quotes if present
                        if len(value) &gt; 0 &amp;&amp; (value[0] == '"' || value[0] == '\'') </span><span class="cov1" title="1">{
                                value = value[1 : len(value)-1]
                        }</span>
                        <span class="cov3" title="2">i.attributes[key] = parseContext.ParseExpression(value)</span>
                }
        }

        <span class="cov10" title="20">return nil</span>
}

// Parse parses the include tag (no-op for include).
func (i *IncludeTag) Parse(tokenizer *liquid.Tokenizer) error <span class="cov1" title="1">{
        // Include tag doesn't parse tokens
        return nil
}</span>

// RenderToOutputBuffer renders the include tag.
func (i *IncludeTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov8" title="13">{
        // Evaluate template name
        templateName := context.Evaluate(i.templateNameExpr)
        templateNameStr, ok := templateName.(string)
        if !ok </span><span class="cov3" title="2">{
                var locale *liquid.I18n
                if pc, ok := i.ParseContext().(*liquid.ParseContext); ok </span><span class="cov3" title="2">{
                        locale = pc.Locale()
                }</span>
                <span class="cov3" title="2">var msg string
                if locale != nil </span><span class="cov3" title="2">{
                        msg = locale.T("errors.argument.include", nil)
                }</span> else<span class="cov0" title="0"> {
                        msg = "include tag requires a string template name"
                }</span>
                <span class="cov3" title="2">errorMsg := context.HandleError(liquid.NewArgumentError(msg), nil)
                *output += errorMsg
                return</span>
        }

        // Load partial from cache
        <span class="cov8" title="11">partial, err := liquid.LoadPartial(templateNameStr, context, i.ParseContext())
        if err != nil </span><span class="cov5" title="5">{
                errorMsg := context.HandleError(err, nil)
                *output += errorMsg
                return
        }</span>

        // Get partial as Template
        <span class="cov6" title="6">partialTemplate, ok := partial.(*liquid.Template)
        if !ok </span><span class="cov0" title="0">{
                errorMsg := context.HandleError(liquid.NewFileSystemError("partial is not a template"), nil)
                *output += errorMsg
                return
        }</span>

        // Determine context variable name
        <span class="cov6" title="6">contextVariableName := i.aliasName
        if contextVariableName == "" </span><span class="cov5" title="5">{
                // Use last part of template name (split by '/')
                parts := strings.Split(templateNameStr, "/")
                contextVariableName = parts[len(parts)-1]
        }</span>

        // Get variable value
        <span class="cov6" title="6">var variable interface{}
        if i.variableNameExpr != nil </span><span class="cov3" title="2">{
                variable = context.Evaluate(i.variableNameExpr)
        }</span> else<span class="cov5" title="4"> {
                // Find variable by template name
                if ctx, ok := context.(*liquid.Context); ok </span><span class="cov5" title="4">{
                        variable = ctx.FindVariable(templateNameStr, false)
                }</span>
        }

        // Get context as *Context for state management
        <span class="cov6" title="6">ctx, ok := context.(*liquid.Context)
        if !ok </span><span class="cov0" title="0">{
                errorMsg := context.HandleError(liquid.NewInternalError("context is not a liquid.Context"), nil)
                *output += errorMsg
                return
        }</span>

        // Save old state
        <span class="cov6" title="6">oldTemplateName := ctx.TemplateName()
        oldPartial := ctx.Partial()

        // Set new state
        partialName := partialTemplate.Name()
        if partialName == "" </span><span class="cov0" title="0">{
                partialName = templateNameStr
        }</span>
        <span class="cov6" title="6">ctx.SetTemplateName(partialName)
        ctx.SetPartial(true)

        // Use stack to create isolated scope
        ctx.Stack(make(map[string]interface{}), func() </span><span class="cov6" title="6">{
                // Set attributes
                for key, valueExpr := range i.attributes </span><span class="cov1" title="1">{
                        value := context.Evaluate(valueExpr)
                        ctx.Set(key, value)
                }</span>

                // Render partial with variable
                <span class="cov6" title="6">if arr, ok := variable.([]interface{}); ok </span><span class="cov1" title="1">{
                        // Array: render once for each item
                        for _, varItem := range arr </span><span class="cov4" title="3">{
                                ctx.Set(contextVariableName, varItem)
                                partialTemplate.RenderToOutputBuffer(ctx, output)
                        }</span>
                } else<span class="cov5" title="5"> {
                        // Single value
                        ctx.Set(contextVariableName, variable)
                        partialTemplate.RenderToOutputBuffer(ctx, output)
                }</span>
        })

        // Restore old state
        <span class="cov6" title="6">ctx.SetTemplateName(oldTemplateName)
        ctx.SetPartial(oldPartial)</span>
}

// TemplateNameExpr returns the template name expression.
func (i *IncludeTag) TemplateNameExpr() interface{} <span class="cov1" title="1">{
        return i.templateNameExpr
}</span>

// VariableNameExpr returns the variable name expression.
func (i *IncludeTag) VariableNameExpr() interface{} <span class="cov1" title="1">{
        return i.variableNameExpr
}</span>

// AliasName returns the alias name.
func (i *IncludeTag) AliasName() string <span class="cov1" title="1">{
        return i.aliasName
}</span>

// Attributes returns the attributes map.
func (i *IncludeTag) Attributes() map[string]interface{} <span class="cov1" title="1">{
        return i.attributes
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package tags

import (
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

// IncrementTag represents an increment tag that creates a counter variable.
type IncrementTag struct {
        *liquid.Tag
        variableName string
}

// NewIncrementTag creates a new IncrementTag.
func NewIncrementTag(tagName, markup string, parseContext liquid.ParseContextInterface) *IncrementTag <span class="cov5" title="3">{
        return &amp;IncrementTag{
                Tag:          liquid.NewTag(tagName, markup, parseContext),
                variableName: strings.TrimSpace(markup),
        }
}</span>

// VariableName returns the variable name.
func (i *IncrementTag) VariableName() string <span class="cov1" title="1">{
        return i.variableName
}</span>

// RenderToOutputBuffer renders the increment tag.
func (i *IncrementTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov10" title="8">{
        // Get counter environment (first environment)
        ctx := context.Context().(*liquid.Context)
        environments := ctx.Scopes()
        if len(environments) == 0 </span><span class="cov0" title="0">{
                environments = []map[string]interface{}{make(map[string]interface{})}
        }</span>

        <span class="cov10" title="8">counterEnv := environments[0]
        value, ok := counterEnv[i.variableName]
        if !ok </span><span class="cov4" title="2">{
                value = 0
        }</span>

        // Convert to int
        <span class="cov10" title="8">var intValue int
        switch v := value.(type) </span>{
        case int:<span class="cov10" title="8">
                intValue = v</span>
        case float64:<span class="cov0" title="0">
                intValue = int(v)</span>
        default:<span class="cov0" title="0">
                intValue = 0</span>
        }

        // Output current value, then increment
        <span class="cov10" title="8">*output += liquid.ToS(intValue, nil)
        counterEnv[i.variableName] = intValue + 1</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package tags

import (
        "regexp"

        "github.com/Notifuse/liquidgo/liquid"
)

var inlineCommentNewlinePattern = regexp.MustCompile(`\n\s*[^#\s]`)

// InlineCommentTag represents an inline comment tag.
type InlineCommentTag struct {
        *liquid.Tag
}

// NewInlineCommentTag creates a new InlineCommentTag.
func NewInlineCommentTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*InlineCommentTag, error) <span class="cov10" title="5">{
        // Check if markup has newlines without # on subsequent lines
        if inlineCommentNewlinePattern.MatchString(markup) </span><span class="cov1" title="1">{
                // Get locale from parse context if it's a ParseContext struct
                var locale *liquid.I18n
                if pc, ok := parseContext.(*liquid.ParseContext); ok </span><span class="cov1" title="1">{
                        locale = pc.Locale()
                        msg := locale.Translate("errors.syntax.inline_comment_invalid", map[string]interface{}{})
                        return nil, liquid.NewSyntaxError(msg)
                }</span>
                <span class="cov0" title="0">return nil, liquid.NewSyntaxError("Liquid syntax error: inline comment invalid")</span>
        }

        <span class="cov8" title="4">return &amp;InlineCommentTag{
                Tag: liquid.NewTag(tagName, markup, parseContext),
        }, nil</span>
}

// RenderToOutputBuffer renders nothing for inline comments.
func (i *InlineCommentTag) RenderToOutputBuffer(context liquid.TagContext, output *string) {<span class="cov4" title="2">
        // Do nothing - comments don't render
}</span>

// Blank returns true since comments are blank.
func (i *InlineCommentTag) Blank() bool <span class="cov1" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var rawSyntax = regexp.MustCompile(`^\s*$`)

// RawTag represents a raw tag that outputs Liquid code as text.
type RawTag struct {
        *liquid.Block
        body string
}

// NewRawTag creates a new RawTag.
func NewRawTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*RawTag, error) <span class="cov6" title="4">{
        // Validate markup is empty
        if !rawSyntax.MatchString(markup) </span><span class="cov1" title="1">{
                var locale *liquid.I18n
                if pc, ok := parseContext.(*liquid.ParseContext); ok </span><span class="cov1" title="1">{
                        locale = pc.Locale()
                        msg := locale.Translate("errors.syntax.tag_unexpected_args", map[string]interface{}{"tag": tagName})
                        return nil, liquid.NewSyntaxError(msg)
                }</span>
                <span class="cov0" title="0">return nil, liquid.NewSyntaxError("Liquid syntax error: tag unexpected args")</span>
        }

        <span class="cov5" title="3">block := liquid.NewBlock(tagName, markup, parseContext)
        block.SetBlockDelimiter("endraw")

        return &amp;RawTag{
                Block: block,
                body:  "",
        }, nil</span>
}

// Parse parses the raw tag body.
func (r *RawTag) Parse(tokenizer *liquid.Tokenizer) error <span class="cov5" title="3">{
        r.body = ""
        blockDelimiter := r.BlockDelimiter()

        for </span><span class="cov10" title="10">{
                token := tokenizer.Shift()
                if token == "" </span><span class="cov0" title="0">{
                        // Tag never closed
                        return liquid.NewSyntaxError("Liquid syntax error: " + r.BlockName() + " tag was never closed")
                }</span>

                // Check if this is the end tag
                <span class="cov10" title="10">if strings.HasPrefix(token, "{%") &amp;&amp; strings.HasSuffix(token, "%}") </span><span class="cov5" title="3">{
                        // Extract tag name from token
                        // Token format: {% endraw %} or {%- endraw -%}
                        tokenContent := strings.TrimPrefix(token, "{%")
                        tokenContent = strings.TrimSuffix(tokenContent, "%}")
                        tokenContent = strings.TrimSpace(tokenContent)

                        // Check if it matches the block delimiter
                        if tokenContent == blockDelimiter || strings.HasPrefix(tokenContent, blockDelimiter+" ") </span><span class="cov5" title="3">{
                                // This is the end tag
                                // Check for whitespace control
                                if len(token) &gt; 2 &amp;&amp; token[2] == '-' </span><span class="cov0" title="0">{
                                        // Trim whitespace from body
                                        r.body = strings.TrimRight(r.body, " \t\n\r")
                                }</span>
                                <span class="cov5" title="3">return nil</span>
                        }
                }

                <span class="cov8" title="7">if token != "" </span><span class="cov8" title="7">{
                        r.body += token
                }</span>
        }
}

// RenderToOutputBuffer renders the raw tag.
func (r *RawTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov1" title="1">{
        *output += r.body
}</span>

// Nodelist returns the nodelist (just the body as a string).
func (r *RawTag) Nodelist() []interface{} <span class="cov1" title="1">{
        return []interface{}{r.body}
}</span>

// Blank returns true if body is empty.
func (r *RawTag) Blank() bool <span class="cov3" title="2">{
        return r.body == ""
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package tags

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// TagConstructor is a function type that creates a tag instance.
type TagConstructor func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error)

// RegisterStandardTags registers all standard tags with the environment.
func RegisterStandardTags(env *liquid.Environment) <span class="cov10" title="3">{
        // Simple tags
        env.RegisterTag("assign", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewAssignTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("echo", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewEchoTag(tagName, markup, parseContext), nil
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("increment", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewIncrementTag(tagName, markup, parseContext), nil
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("decrement", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewDecrementTag(tagName, markup, parseContext), nil
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("break", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov6" title="2">{
                return NewBreakTag(tagName, markup, parseContext), nil
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("continue", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov6" title="2">{
                return NewContinueTag(tagName, markup, parseContext), nil
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("cycle", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewCycleTag(tagName, markup, parseContext)
        }</span>))

        // Block tags
        <span class="cov10" title="3">env.RegisterTag("comment", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewCommentTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("doc", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewDocTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("capture", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewCaptureTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("if", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov10" title="3">{
                return NewIfTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("unless", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewUnlessTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("for", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewForTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("ifchanged", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov0" title="0">{
                return NewIfchangedTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("case", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewCaseTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("tablerow", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewTableRowTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("snippet", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov0" title="0">{
                return NewSnippetTag(tagName, markup, parseContext)
        }</span>))

        // Include/render tags
        <span class="cov10" title="3">env.RegisterTag("include", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewIncludeTag(tagName, markup, parseContext)
        }</span>))
        <span class="cov10" title="3">env.RegisterTag("render", TagConstructor(func(tagName, markup string, parseContext liquid.ParseContextInterface) (interface{}, error) </span><span class="cov1" title="1">{
                return NewRenderTag(tagName, markup, parseContext)
        }</span>))
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package tags

import (
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        // renderSyntax matches: 'filename'|variable [with|for expression] [as alias] [attributes...]
        // Note: QuotedFragment and QuotedString already have +, so we don't add another
        renderSyntax = regexp.MustCompile(`(` + liquid.QuotedString.String() + `|` + liquid.VariableSegment.String() + `+)(\s+(with|for)\s+(` + liquid.QuotedFragment.String() + `))?(\s+(?:as)\s+(` + liquid.VariableSegment.String() + `+))?`)
)

// RenderTag represents a render tag that renders a partial template with isolated context.
type RenderTag struct {
        *liquid.Tag
        templateNameExpr interface{}            // Expression
        variableNameExpr interface{}            // Expression or nil
        aliasName        string                 // Alias name or ""
        attributes       map[string]interface{} // Attribute expressions
        isForLoop        bool                   // True if "for" was used instead of "with"
}

// NewRenderTag creates a new RenderTag.
func NewRenderTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*RenderTag, error) <span class="cov10" title="27">{
        tag := liquid.NewTag(tagName, markup, parseContext)

        renderTag := &amp;RenderTag{
                Tag:        tag,
                attributes: make(map[string]interface{}),
                isForLoop:  false,
        }

        // Parse markup
        err := renderTag.parseMarkup(markup, parseContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="27">return renderTag, nil</span>
}

// parseMarkup parses the render tag markup.
func (r *RenderTag) parseMarkup(markup string, parseContext liquid.ParseContextInterface) error <span class="cov10" title="27">{
        matches := renderSyntax.FindStringSubmatch(markup)
        if len(matches) == 0 </span><span class="cov0" title="0">{
                return liquid.NewSyntaxError("invalid render tag syntax")
        }</span>

        // Template name
        <span class="cov10" title="27">templateNameStr := matches[1]
        r.templateNameExpr = parseContext.ParseExpression(templateNameStr)

        // Variable name (with/for)
        if len(matches) &gt; 4 &amp;&amp; matches[4] != "" </span><span class="cov6" title="8">{
                r.variableNameExpr = parseContext.ParseExpression(matches[4])
                // Check if it's "for" (isForLoop) or "with"
                if len(matches) &gt; 3 &amp;&amp; matches[3] == "for" </span><span class="cov5" title="5">{
                        r.isForLoop = true
                }</span>
        }

        // Alias name (as)
        <span class="cov10" title="27">if len(matches) &gt; 6 &amp;&amp; matches[6] != "" </span><span class="cov4" title="3">{
                r.aliasName = matches[6]
        }</span>

        // Parse attributes
        <span class="cov10" title="27">attributeMatches := liquid.TagAttributes.FindAllStringSubmatch(markup, -1)
        for _, match := range attributeMatches </span><span class="cov4" title="3">{
                if len(match) &gt;= 3 </span><span class="cov4" title="3">{
                        key := strings.TrimSpace(match[1])
                        value := strings.TrimSpace(match[2])
                        // Remove quotes if present
                        if len(value) &gt; 0 &amp;&amp; (value[0] == '"' || value[0] == '\'') </span><span class="cov1" title="1">{
                                value = value[1 : len(value)-1]
                        }</span>
                        <span class="cov4" title="3">r.attributes[key] = parseContext.ParseExpression(value)</span>
                }
        }

        <span class="cov10" title="27">return nil</span>
}

// Parse parses the render tag (no-op for render).
func (r *RenderTag) Parse(tokenizer *liquid.Tokenizer) error <span class="cov1" title="1">{
        // Render tag doesn't parse tokens
        return nil
}</span>

// RenderToOutputBuffer renders the render tag.
func (r *RenderTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov9" title="19">{
        // Evaluate template name
        template := context.Evaluate(r.templateNameExpr)

        // Get context as *Context
        ctx, ok := context.(*liquid.Context)
        if !ok </span><span class="cov0" title="0">{
                errorMsg := context.HandleError(liquid.NewInternalError("context is not a liquid.Context"), nil)
                *output += errorMsg
                return
        }</span>

        <span class="cov9" title="19">var partial *liquid.Template
        var templateName string
        var contextVariableName string

        // Check if template responds to to_partial (for template objects)
        if toPartial, ok := template.(interface{ ToPartial() *liquid.Template }); ok </span><span class="cov0" title="0">{
                partial = toPartial.ToPartial()
                if filename, ok := template.(interface{ Filename() string }); ok </span><span class="cov0" title="0">{
                        templateName = filename.Filename()
                }</span>
                <span class="cov0" title="0">if name, ok := template.(interface{ Name() string }); ok </span><span class="cov0" title="0">{
                        contextVariableName = r.aliasName
                        if contextVariableName == "" </span><span class="cov0" title="0">{
                                contextVariableName = name.Name()
                        }</span>
                }
        } else<span class="cov9" title="19"> if templateNameStr, ok := template.(string); ok </span><span class="cov8" title="16">{
                // String template name - load from cache
                partialInterface, err := liquid.LoadPartial(templateNameStr, context, r.ParseContext())
                if err != nil </span><span class="cov7" title="9">{
                        errorMsg := context.HandleError(err, nil)
                        *output += errorMsg
                        return
                }</span>
                <span class="cov6" title="7">var ok bool
                partial, ok = partialInterface.(*liquid.Template)
                if !ok </span><span class="cov0" title="0">{
                        errorMsg := context.HandleError(liquid.NewFileSystemError("partial is not a template"), nil)
                        *output += errorMsg
                        return
                }</span>
                <span class="cov6" title="7">templateName = partial.Name()
                if templateName == "" </span><span class="cov0" title="0">{
                        templateName = templateNameStr
                }</span>
                <span class="cov6" title="7">contextVariableName = r.aliasName
                if contextVariableName == "" </span><span class="cov5" title="6">{
                        // Use last part of template name
                        parts := strings.Split(templateNameStr, "/")
                        contextVariableName = parts[len(parts)-1]
                }</span>
        } else<span class="cov4" title="3"> {
                errorMsg := context.HandleError(liquid.NewArgumentError("render tag requires a string template name or template object"), nil)
                *output += errorMsg
                return
        }</span>

        // Render partial function
        <span class="cov6" title="7">renderPartialFunc := func(varItem interface{}, forloop *liquid.ForloopDrop) </span><span class="cov7" title="9">{
                innerContext := ctx.NewIsolatedSubcontext()
                innerContext.SetTemplateName(templateName)
                innerContext.SetPartial(true)

                // Set forloop if provided
                if forloop != nil </span><span class="cov4" title="3">{
                        innerContext.Set("forloop", forloop)
                }</span>

                // Set attributes
                <span class="cov7" title="9">for key, valueExpr := range r.attributes </span><span class="cov1" title="1">{
                        value := context.Evaluate(valueExpr)
                        innerContext.Set(key, value)
                }</span>

                // Set variable unless nil
                <span class="cov7" title="9">if varItem != nil </span><span class="cov5" title="6">{
                        innerContext.Set(contextVariableName, varItem)
                }</span>

                // Render partial
                <span class="cov7" title="9">partial.RenderToOutputBuffer(innerContext, output)

                // Increment forloop if provided
                if forloop != nil </span><span class="cov4" title="3">{
                        forloop.Increment()
                }</span>
        }

        // Get variable value
        <span class="cov6" title="7">var variable interface{}
        if r.variableNameExpr != nil </span><span class="cov4" title="4">{
                variable = context.Evaluate(r.variableNameExpr)
        }</span>

        // Handle for loop or single render
        <span class="cov6" title="7">if r.isForLoop &amp;&amp; variable != nil </span><span class="cov4" title="3">{
                // Check if variable is iterable (has Each and Count methods)
                if iterable, ok := variable.(interface {
                        Each(func(interface{}))
                        Count() int
                }); ok </span><span class="cov0" title="0">{
                        count := iterable.Count()
                        forloop := liquid.NewForloopDrop(templateName, count, nil)
                        iterable.Each(func(item interface{}) </span><span class="cov0" title="0">{
                                renderPartialFunc(item, forloop)
                        }</span>)
                } else<span class="cov4" title="3"> if arr, ok := variable.([]interface{}); ok </span><span class="cov1" title="1">{
                        // Array fallback
                        forloop := liquid.NewForloopDrop(templateName, len(arr), nil)
                        for _, item := range arr </span><span class="cov4" title="3">{
                                renderPartialFunc(item, forloop)
                        }</span>
                } else<span class="cov2" title="2"> {
                        // Not iterable, render once with variable
                        renderPartialFunc(variable, nil)
                }</span>
        } else<span class="cov4" title="4"> {
                // Single render
                renderPartialFunc(variable, nil)
        }</span>
}

// TemplateNameExpr returns the template name expression.
func (r *RenderTag) TemplateNameExpr() interface{} <span class="cov1" title="1">{
        return r.templateNameExpr
}</span>

// VariableNameExpr returns the variable name expression.
func (r *RenderTag) VariableNameExpr() interface{} <span class="cov2" title="2">{
        return r.variableNameExpr
}</span>

// AliasName returns the alias name.
func (r *RenderTag) AliasName() string <span class="cov1" title="1">{
        return r.aliasName
}</span>

// Attributes returns the attributes map.
func (r *RenderTag) Attributes() map[string]interface{} <span class="cov1" title="1">{
        return r.attributes
}</span>

// IsForLoop returns true if this is a for loop render.
func (r *RenderTag) IsForLoop() bool <span class="cov2" title="2">{
        return r.isForLoop
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package tags

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// SnippetTag represents a snippet block tag that creates an inline snippet.
type SnippetTag struct {
        *liquid.Block
        to string // Variable name to assign snippet to
}

// NewSnippetTag creates a new SnippetTag.
func NewSnippetTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*SnippetTag, error) <span class="cov10" title="5">{
        block := liquid.NewBlock(tagName, markup, parseContext)

        // Parse markup - should be just a variable name
        // Ruby: p.consume(:id)
        // For now, use simple parsing - expect just an identifier
        if markup == "" </span><span class="cov1" title="1">{
                return nil, liquid.NewSyntaxError("snippet tag requires a variable name")
        }</span>

        // Extract variable name (simple for now - can be enhanced with parser later)
        <span class="cov8" title="4">to := markup

        return &amp;SnippetTag{
                Block: block,
                to:    to,
        }, nil</span>
}

// To returns the variable name.
func (s *SnippetTag) To() string <span class="cov1" title="1">{
        return s.to
}</span>

// Blank returns true (snippet tag is always blank).
func (s *SnippetTag) Blank() bool <span class="cov1" title="1">{
        return true
}</span>

// RenderToOutputBuffer renders the snippet tag.
func (s *SnippetTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov4" title="2">{
        ctx := context.Context().(*liquid.Context)

        // Render block body to get snippet content
        bodyOutput := ""
        s.Block.RenderToOutputBuffer(context, &amp;bodyOutput)

        // Get template name
        templateName := ctx.TemplateName()

        // Create snippet drop
        snippetDrop := liquid.NewSnippetDrop(bodyOutput, s.to, templateName)

        // Assign to variable in current scope (last scope)
        // Use Set which sets in the first scope (current/local scope)
        ctx.Set(s.to, snippetDrop)

        // Increment assign score in resource limits
        rl := context.ResourceLimits()
        if rl != nil </span><span class="cov4" title="2">{
                // Calculate assign score (sum of body bytes)
                assignScore := len(bodyOutput)
                rl.IncrementAssignScore(assignScore)
        }</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package tags

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/Notifuse/liquidgo/liquid"
)

var (
        // tableRowSyntax matches: variable in collection [attributes...]
        // Note: QuotedFragment already has +, so we don't add another
        tableRowSyntax    = regexp.MustCompile(`^(\w+)\s+in\s+(` + liquid.QuotedFragment.String() + `)`)
        allowedAttributes = map[string]bool{
                "cols":   true,
                "limit":  true,
                "offset": true,
                "range":  true,
        }
)

// TableRowTag represents a table_row block tag that generates HTML table rows.
type TableRowTag struct {
        *liquid.Block
        variableName   string
        collectionName interface{}            // Expression
        attributes     map[string]interface{} // Attribute expressions
}

// NewTableRowTag creates a new TableRowTag.
func NewTableRowTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*TableRowTag, error) <span class="cov8" title="13">{
        block := liquid.NewBlock(tagName, markup, parseContext)

        tag := &amp;TableRowTag{
                Block:      block,
                attributes: make(map[string]interface{}),
        }

        // Parse markup
        err := tag.parseMarkup(markup, parseContext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="12">return tag, nil</span>
}

// parseMarkup parses the table_row tag markup.
func (t *TableRowTag) parseMarkup(markup string, parseContext liquid.ParseContextInterface) error <span class="cov8" title="13">{
        matches := tableRowSyntax.FindStringSubmatch(markup)
        if len(matches) == 0 </span><span class="cov0" title="0">{
                return liquid.NewSyntaxError("invalid table_row tag syntax")
        }</span>

        <span class="cov8" title="13">t.variableName = matches[1]
        collectionNameStr := matches[2]

        // Parse collection name as expression
        t.collectionName = parseContext.ParseExpression(collectionNameStr)

        // Parse attributes (cols, limit, offset, range)
        attributeMatches := liquid.TagAttributes.FindAllStringSubmatch(markup, -1)
        for _, match := range attributeMatches </span><span class="cov9" title="15">{
                if len(match) &gt;= 3 </span><span class="cov9" title="15">{
                        key := strings.TrimSpace(match[1])
                        value := strings.TrimSpace(match[2])
                        // Remove quotes if present
                        if len(value) &gt; 0 &amp;&amp; (value[0] == '"' || value[0] == '\'') </span><span class="cov0" title="0">{
                                value = value[1 : len(value)-1]
                        }</span>

                        // Validate attribute
                        <span class="cov9" title="15">if !allowedAttributes[key] </span><span class="cov1" title="1">{
                                return liquid.NewSyntaxError(fmt.Sprintf("invalid table_row attribute: %s", key))
                        }</span>

                        <span class="cov8" title="14">t.attributes[key] = parseContext.ParseExpression(value)</span>
                }
        }

        <span class="cov8" title="12">return nil</span>
}

// VariableName returns the variable name.
func (t *TableRowTag) VariableName() string <span class="cov1" title="1">{
        return t.variableName
}</span>

// CollectionName returns the collection name expression.
func (t *TableRowTag) CollectionName() interface{} <span class="cov1" title="1">{
        return t.collectionName
}</span>

// Attributes returns the attributes map.
func (t *TableRowTag) Attributes() map[string]interface{} <span class="cov1" title="1">{
        return t.attributes
}</span>

// RenderToOutputBuffer renders the table_row tag.
func (t *TableRowTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov7" title="8">{
        // Evaluate collection
        collection := context.Evaluate(t.collectionName)
        if collection == nil </span><span class="cov1" title="1">{
                *output += "&lt;tr class=\"row1\"&gt;\n&lt;/tr&gt;\n"
                return
        }</span>

        // Calculate from (offset)
        <span class="cov6" title="7">var from int
        if offsetAttr, ok := t.attributes["offset"]; ok </span><span class="cov3" title="2">{
                offsetValue := context.Evaluate(offsetAttr)
                if offsetValue != nil </span><span class="cov1" title="1">{
                        offsetInt, err := liquid.ToInteger(offsetValue)
                        if err != nil </span><span class="cov0" title="0">{
                                errorMsg := context.HandleError(liquid.NewArgumentError("invalid integer"), nil)
                                *output += errorMsg
                                return
                        }</span>
                        <span class="cov1" title="1">from = offsetInt</span>
                }
        }

        // Calculate to (limit)
        <span class="cov6" title="7">var to *int
        if limitAttr, ok := t.attributes["limit"]; ok </span><span class="cov3" title="2">{
                limitValue := context.Evaluate(limitAttr)
                if limitValue != nil </span><span class="cov3" title="2">{
                        limitInt, err := liquid.ToInteger(limitValue)
                        if err != nil </span><span class="cov0" title="0">{
                                errorMsg := context.HandleError(liquid.NewArgumentError("invalid integer"), nil)
                                *output += errorMsg
                                return
                        }</span>
                        <span class="cov3" title="2">toVal := from + limitInt
                        to = &amp;toVal</span>
                }
        }

        // Slice collection
        <span class="cov6" title="7">segment := liquid.SliceCollection(collection, from, to)
        length := len(segment)

        // Calculate cols
        var cols int
        if colsAttr, ok := t.attributes["cols"]; ok </span><span class="cov6" title="7">{
                colsValue := context.Evaluate(colsAttr)
                if colsValue != nil </span><span class="cov6" title="7">{
                        colsInt, err := liquid.ToInteger(colsValue)
                        if err != nil </span><span class="cov0" title="0">{
                                errorMsg := context.HandleError(liquid.NewArgumentError("invalid integer"), nil)
                                *output += errorMsg
                                return
                        }</span>
                        <span class="cov6" title="7">cols = colsInt</span>
                } else<span class="cov0" title="0"> {
                        cols = length
                }</span>
        } else<span class="cov0" title="0"> {
                cols = length
        }</span>

        // Start first row
        <span class="cov6" title="7">*output += "&lt;tr class=\"row1\"&gt;\n"

        // Get underlying Context for Stack
        ctx := context.Context().(*liquid.Context)

        // Create new scope and iterate
        ctx.Stack(make(map[string]interface{}), func() </span><span class="cov6" title="7">{
                // Create tablerowloop drop
                tablerowloop := liquid.NewTablerowloopDrop(length, cols)
                ctx.Set("tablerowloop", tablerowloop)

                // Iterate over segment
                for _, item := range segment </span><span class="cov10" title="20">{
                        // Set variable
                        ctx.Set(t.variableName, item)

                        // Output &lt;td&gt; tag
                        *output += fmt.Sprintf("&lt;td class=\"col%d\"&gt;", tablerowloop.Col())

                        // Render block body
                        t.Block.RenderToOutputBuffer(context, output)

                        // Close &lt;/td&gt;
                        *output += "&lt;/td&gt;"

                        // Handle interrupts
                        if ctx.Interrupt() </span><span class="cov0" title="0">{
                                interrupt := ctx.PopInterrupt()
                                if _, ok := interrupt.(*liquid.BreakInterrupt); ok </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                        // Check if we need to close row and start new one
                        <span class="cov10" title="20">if tablerowloop.ColLast() &amp;&amp; !tablerowloop.Last() </span><span class="cov5" title="5">{
                                *output += fmt.Sprintf("&lt;/tr&gt;\n&lt;tr class=\"row%d\"&gt;", tablerowloop.Row()+1)
                        }</span>

                        // Increment loop
                        <span class="cov10" title="20">tablerowloop.Increment()</span>
                }
        })

        // Close last row
        <span class="cov6" title="7">*output += "&lt;/tr&gt;\n"</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package tags

import (
        "github.com/Notifuse/liquidgo/liquid"
)

// UnlessTag represents an unless block tag (opposite of if).
type UnlessTag struct {
        *IfTag
}

// NewUnlessTag creates a new UnlessTag.
func NewUnlessTag(tagName, markup string, parseContext liquid.ParseContextInterface) (*UnlessTag, error) <span class="cov10" title="9">{
        // Unless inherits from If, so we create an IfTag but with "unless" as the tag name
        // The Block needs to have the correct tag name for parsing
        block := liquid.NewBlock(tagName, markup, parseContext)

        // Parse the initial condition (same as if)
        condition, err := parseIfCondition(markup, parseContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create attachment for the first block
        <span class="cov10" title="9">attachment := liquid.NewBlockBody()
        condition.Attach(attachment)

        ifTag := &amp;IfTag{
                Block:  block,
                blocks: []ConditionBlock{condition},
        }

        return &amp;UnlessTag{
                IfTag: ifTag,
        }, nil</span>
}

// RenderToOutputBuffer renders the unless tag (negated if).
func (u *UnlessTag) RenderToOutputBuffer(context liquid.TagContext, output *string) <span class="cov8" title="7">{
        // Get the underlying Context which implements ConditionContext
        ctx := context.Context().(*liquid.Context)

        // Render the first block (unless condition) if it evaluates to false
        // Then render elsif/else blocks normally
        for i, block := range u.Blocks() </span><span class="cov9" title="8">{
                result, err := block.Evaluate(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle error
                        errorMsg := context.HandleError(err, nil)
                        *output += errorMsg
                        return
                }</span>

                // Convert result to liquid value
                <span class="cov9" title="8">resultVal := liquid.ToLiquidValue(result)

                // For the first block (unless), negate the condition
                // For elsif/else blocks, use normal logic
                shouldRender := false
                if i == 0 </span><span class="cov8" title="7">{
                        // First block: render if condition is false
                        shouldRender = (resultVal == nil || resultVal == false || resultVal == "")
                }</span> else<span class="cov1" title="1"> {
                        // Elsif/else blocks: render if condition is true
                        shouldRender = (resultVal != nil &amp;&amp; resultVal != false &amp;&amp; resultVal != "")
                }</span>

                <span class="cov9" title="8">if shouldRender </span><span class="cov8" title="6">{
                        // Render the attachment
                        if attachment, ok := block.Attachment().(*liquid.BlockBody); ok </span><span class="cov8" title="6">{
                                attachment.RenderToOutputBuffer(context, output)
                        }</span>
                        <span class="cov8" title="6">return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package liquid

import (
        "unicode/utf8"
)

// Template represents a compiled Liquid template.
// Templates are central to liquid. Interpreting templates is a two step process.
// First you compile the source code you got. During compile time some extensive
// error checking is performed. Your code should expect to get some SyntaxErrors.
//
// After you have a compiled template you can then render it.
// You can use a compiled template over and over again and keep it cached.
//
// Example:
//
//        template := liquid.ParseTemplate(source)
//        result := template.Render(map[string]interface{}{"user_name": "bob"})
type Template struct {
        environment     *Environment
        resourceLimits  *ResourceLimits
        root            *Document
        profiler        *Profiler
        registers       map[string]interface{}
        assigns         map[string]interface{}
        instanceAssigns map[string]interface{}
        name            string
        warnings        []error
        errors          []error
        rethrowErrors   bool
        lineNumbers     bool
        profiling       bool
}

// TemplateOptions contains options for parsing a template.
type TemplateOptions struct {
        Environment       *Environment
        GlobalFilter      func(interface{}) interface{}
        ExceptionRenderer func(error) interface{}
        Registers         map[string]interface{}
        Filters           []interface{}
        Profile           bool
        LineNumbers       bool
        StrictVariables   bool
        StrictFilters     bool
}

// ParseTemplate creates a new Template and parses the source code.
// To enable profiling, pass in Profile: true as an option.
func ParseTemplate(source string, options *TemplateOptions) (*Template, error) <span class="cov3" title="3">{
        template := NewTemplate(options)
        err := template.Parse(source, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="3">return template, nil</span>
}

// NewTemplate creates a new Template instance.
func NewTemplate(options *TemplateOptions) *Template <span class="cov10" title="34">{
        var env *Environment
        if options != nil &amp;&amp; options.Environment != nil </span><span class="cov9" title="31">{
                env = options.Environment
        }</span> else<span class="cov3" title="3"> {
                env = NewEnvironment()
        }</span>

        <span class="cov10" title="34">var resourceLimits *ResourceLimits
        config := ResourceLimitsConfig{}
        if env.defaultResourceLimits != nil </span><span class="cov10" title="34">{
                // Convert map[string]interface{} to ResourceLimitsConfig
                if renderLengthLimit, ok := env.defaultResourceLimits["render_length_limit"].(int); ok </span><span class="cov1" title="1">{
                        config.RenderLengthLimit = &amp;renderLengthLimit
                }</span>
                <span class="cov10" title="34">if renderScoreLimit, ok := env.defaultResourceLimits["render_score_limit"].(int); ok </span><span class="cov0" title="0">{
                        config.RenderScoreLimit = &amp;renderScoreLimit
                }</span>
                <span class="cov10" title="34">if assignScoreLimit, ok := env.defaultResourceLimits["assign_score_limit"].(int); ok </span><span class="cov1" title="1">{
                        config.AssignScoreLimit = &amp;assignScoreLimit
                }</span>
        }
        <span class="cov10" title="34">resourceLimits = NewResourceLimits(config)

        return &amp;Template{
                environment:     env,
                rethrowErrors:   false,
                resourceLimits:  resourceLimits,
                registers:       make(map[string]interface{}, 4), // Pre-allocate map
                assigns:         make(map[string]interface{}, 8), // Pre-allocate for typical assigns
                instanceAssigns: make(map[string]interface{}, 8), // Pre-allocate for instance assigns
                errors:          make([]error, 0, 2),             // Pre-allocate errors
                warnings:        make([]error, 0, 2),             // Pre-allocate warnings
        }</span>
}

// Parse parses source code.
// Returns self for easy chaining.
func (t *Template) Parse(source string, options *TemplateOptions) error <span class="cov9" title="24">{
        parseContext := t.configureOptions(options)

        // Convert source to string
        sourceStr := source

        // Validate encoding (Go strings are UTF-8 by default, but we should validate)
        // In Ruby: unless source.valid_encoding?
        if !isValidUTF8(sourceStr) </span><span class="cov1" title="1">{
                var locale *I18n
                if pc, ok := parseContext.(*ParseContext); ok </span><span class="cov1" title="1">{
                        locale = pc.Locale()
                }</span>
                <span class="cov1" title="1">var msg string
                if locale != nil </span><span class="cov1" title="1">{
                        msg = locale.T("errors.syntax.invalid_template_encoding", nil)
                }</span> else<span class="cov0" title="0"> {
                        msg = "Invalid template encoding"
                }</span>
                <span class="cov1" title="1">return NewTemplateEncodingError(msg)</span>
        }

        // Create tokenizer
        <span class="cov9" title="23">var startLineNumber *int
        if t.lineNumbers </span><span class="cov2" title="2">{
                lineNum := 1
                startLineNumber = &amp;lineNum
        }</span>
        <span class="cov9" title="23">tokenizer := parseContext.NewTokenizer(sourceStr, false, startLineNumber, false)

        // Parse document
        root, err := ParseDocument(tokenizer, parseContext)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="23">t.root = root
        // Get warnings from parse context if available
        if pc, ok := parseContext.(*ParseContext); ok </span><span class="cov9" title="23">{
                t.warnings = pc.Warnings()
        }</span>

        <span class="cov9" title="23">return nil</span>
}

// isValidUTF8 checks if a string is valid UTF-8.
func isValidUTF8(s string) bool <span class="cov9" title="24">{
        return utf8.ValidString(s)
}</span>

// Root returns the root document.
func (t *Template) Root() *Document <span class="cov3" title="3">{
        return t.root
}</span>

// SetRoot sets the root document.
func (t *Template) SetRoot(root *Document) <span class="cov1" title="1">{
        t.root = root
}</span>

// Name returns the template name.
func (t *Template) Name() string <span class="cov2" title="2">{
        return t.name
}</span>

// SetName sets the template name.
func (t *Template) SetName(name string) <span class="cov3" title="3">{
        t.name = name
}</span>

// ResourceLimits returns the resource limits.
func (t *Template) ResourceLimits() *ResourceLimits <span class="cov4" title="4">{
        return t.resourceLimits
}</span>

// SetResourceLimits sets the resource limits.
func (t *Template) SetResourceLimits(rl *ResourceLimits) <span class="cov2" title="2">{
        t.resourceLimits = rl
}</span>

// Warnings returns the warnings.
func (t *Template) Warnings() []error <span class="cov1" title="1">{
        return t.warnings
}</span>

// Profiler returns the profiler (if profiling was enabled).
func (t *Template) Profiler() *Profiler <span class="cov3" title="3">{
        return t.profiler
}</span>

// Registers returns the registers map.
func (t *Template) Registers() map[string]interface{} <span class="cov5" title="5">{
        if t.registers == nil </span><span class="cov1" title="1">{
                t.registers = make(map[string]interface{})
        }</span>
        <span class="cov5" title="5">return t.registers</span>
}

// Assigns returns the assigns map.
func (t *Template) Assigns() map[string]interface{} <span class="cov5" title="5">{
        if t.assigns == nil </span><span class="cov1" title="1">{
                t.assigns = make(map[string]interface{})
        }</span>
        <span class="cov5" title="5">return t.assigns</span>
}

// InstanceAssigns returns the instance assigns map.
func (t *Template) InstanceAssigns() map[string]interface{} <span class="cov5" title="5">{
        if t.instanceAssigns == nil </span><span class="cov1" title="1">{
                t.instanceAssigns = make(map[string]interface{})
        }</span>
        <span class="cov5" title="5">return t.instanceAssigns</span>
}

// Errors returns the errors.
func (t *Template) Errors() []error <span class="cov4" title="4">{
        if t.errors == nil </span><span class="cov1" title="1">{
                t.errors = []error{}
        }</span>
        <span class="cov4" title="4">return t.errors</span>
}

// Render renders the template with the given assigns.
// Render takes a hash with local variables.
//
// Following options can be passed via RenderOptions:
//
//   - Filters: array with local filters
//   - Registers: hash with register variables. Those can be accessed from
//     filters and tags and might be useful to integrate liquid more with its host application
func (t *Template) Render(assigns interface{}, options *RenderOptions) (output string) <span class="cov9" title="24">{
        if t.root == nil </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov9" title="23">context := t.buildContext(assigns, options)

        // If a Context was passed directly, use its resource limits
        // Otherwise, set resource limits from template (in case they were updated)
        if _, ok := assigns.(*Context); !ok </span><span class="cov8" title="20">{
                if ctx, ok := context.(*Context); ok </span><span class="cov8" title="20">{
                        ctx.SetResourceLimits(t.resourceLimits)
                }</span>
        }

        // Retrying a render resets resource usage
        <span class="cov9" title="23">context.ResourceLimits().Reset()

        // Handle profiling
        if t.profiling </span><span class="cov1" title="1">{
                if ctx, ok := context.(*Context); ok &amp;&amp; ctx.Profiler() == nil </span><span class="cov1" title="1">{
                        t.profiler = NewProfiler()
                        ctx.SetProfiler(t.profiler)
                }</span>
        }

        // Cast to *Context to access TemplateName
        <span class="cov9" title="23">if ctx, ok := context.(*Context); ok </span><span class="cov9" title="23">{
                if ctx.TemplateName() == "" </span><span class="cov9" title="23">{
                        ctx.SetTemplateName(t.name)
                }</span>
        }

        // Use output from options if provided
        <span class="cov9" title="23">if options != nil &amp;&amp; options.Output != nil </span><span class="cov3" title="3">{
                output = *options.Output
        }</span>

        <span class="cov9" title="23">defer func() </span><span class="cov9" title="23">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        if memErr, ok := r.(*MemoryError); ok </span><span class="cov0" title="0">{
                                errorMsg := context.HandleError(memErr, nil)
                                // Set output to error message (named return allows defer to modify it)
                                output = errorMsg
                                if output == "" </span><span class="cov0" title="0">{
                                        output = "Liquid error: Memory limits exceeded"
                                }</span>
                        } else<span class="cov0" title="0"> {
                                panic(r)</span>
                        }
                }
                // Cast to *Context to access Errors
                <span class="cov9" title="23">if ctx, ok := context.(*Context); ok </span><span class="cov9" title="23">{
                        t.errors = ctx.Errors()
                        // Update template's resource limits from context's resource limits
                        // (in case assign_score or render_score was updated during rendering)
                        // Note: ctx.ResourceLimits() and t.resourceLimits should be the same object,
                        // but we update anyway to ensure consistency
                        if ctx.ResourceLimits() != nil &amp;&amp; t.resourceLimits != nil </span><span class="cov9" title="23">{
                                // Copy scores from context to template (they should be the same object, but ensure sync)
                                ctxRL := ctx.ResourceLimits()
                                t.resourceLimits.assignScore = ctxRL.AssignScore()
                                t.resourceLimits.renderScore = ctxRL.RenderScore()
                                t.resourceLimits.reachedLimit = ctxRL.Reached()
                        }</span>
                }
                // Update output in options if provided
                <span class="cov9" title="23">if options != nil &amp;&amp; options.Output != nil </span><span class="cov3" title="3">{
                        *options.Output = output
                }</span>
        }()

        <span class="cov9" title="23">t.root.RenderToOutputBuffer(context, &amp;output)
        return output</span>
}

// RenderOptions contains options for rendering a template.
type RenderOptions struct {
        Output            *string
        Registers         map[string]interface{}
        GlobalFilter      func(interface{}) interface{}
        ExceptionRenderer func(error) interface{}
        Filters           []interface{}
        StrictVariables   bool
        StrictFilters     bool
}

// Render! renders the template with rethrow_errors enabled.
func (t *Template) RenderBang(assigns interface{}, options *RenderOptions) string <span class="cov1" title="1">{
        t.rethrowErrors = true
        return t.Render(assigns, options)
}</span>

// RenderToOutputBuffer renders the template to the output buffer.
func (t *Template) RenderToOutputBuffer(context TagContext, output *string) <span class="cov6" title="8">{
        if t.root == nil </span><span class="cov2" title="2">{
                return
        }</span>

        // Cast to *Context to access methods
        <span class="cov5" title="6">if ctx, ok := context.(*Context); ok </span><span class="cov5" title="5">{
                // Retrying a render resets resource usage
                ctx.ResourceLimits().Reset()

                if ctx.TemplateName() == "" </span><span class="cov5" title="5">{
                        ctx.SetTemplateName(t.name)
                }</span>

                <span class="cov5" title="5">defer func() </span><span class="cov5" title="5">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if memErr, ok := r.(*MemoryError); ok </span><span class="cov0" title="0">{
                                        ctx.HandleError(memErr, nil)
                                }</span> else<span class="cov0" title="0"> {
                                        panic(r)</span>
                                }
                        }
                        <span class="cov5" title="5">t.errors = ctx.Errors()</span>
                }()

                <span class="cov5" title="5">t.root.RenderToOutputBuffer(context, output)</span>
        } else<span class="cov1" title="1"> {
                // Fallback: use Render method
                _ = t.Render(context, &amp;RenderOptions{Output: output})
        }</span>
}

// buildContext builds a Context from assigns and options.
func (t *Template) buildContext(assigns interface{}, options *RenderOptions) TagContext <span class="cov9" title="23">{
        var ctx *Context

        switch v := assigns.(type) </span>{
        case *Context:<span class="cov3" title="3">
                ctx = v
                if t.rethrowErrors </span><span class="cov1" title="1">{
                        ctx.SetExceptionRenderer(func(err error) interface{} </span><span class="cov0" title="0">{
                                panic(err)</span>
                        })
                }
                // Check if context has a drop associated with it (for drop-as-context pattern)
                // If the context doesn't already have a __drop__, check if template has one stored
                <span class="cov3" title="3">if len(ctx.Scopes()) &gt; 0 </span><span class="cov3" title="3">{
                        lastScope := ctx.Scopes()[len(ctx.Scopes())-1]
                        if _, hasDropAlready := lastScope["__drop__"]; !hasDropAlready </span><span class="cov3" title="3">{
                                // If template has a __drop__ in instanceAssigns, copy it to this context
                                if drop, hasDrop := t.instanceAssigns["__drop__"]; hasDrop </span><span class="cov1" title="1">{
                                        lastScope["__drop__"] = drop
                                }</span>
                        }
                }
        case map[string]interface{}:<span class="cov7" title="15">
                ctx = BuildContext(ContextConfig{
                        Environments:   []map[string]interface{}{v, t.assigns},
                        OuterScope:     t.instanceAssigns,
                        Registers:      NewRegisters(t.registers),
                        ResourceLimits: t.resourceLimits,
                        Environment:    t.environment,
                        RethrowErrors:  t.rethrowErrors,
                })</span>
        case nil:<span class="cov2" title="2">
                ctx = BuildContext(ContextConfig{
                        Environments:   []map[string]interface{}{t.assigns},
                        OuterScope:     t.instanceAssigns,
                        Registers:      NewRegisters(t.registers),
                        ResourceLimits: t.resourceLimits,
                        Environment:    t.environment,
                        RethrowErrors:  t.rethrowErrors,
                })</span>
        default:<span class="cov3" title="3">
                // Check if it's a drop - if so, we need to make it accessible for variable lookups
                // In Ruby Liquid, drops can be passed as context and their methods become available as variables
                // assigns is not nil here (nil case handled above)
                dropToStore := assigns
                // Wrap the drop in the outer scope so it's accessible
                // The drop itself will be the context for variable lookups
                outerScope := map[string]interface{}{"__drop__": assigns}

                ctx = BuildContext(ContextConfig{
                        Environments:   []map[string]interface{}{t.assigns},
                        OuterScope:     outerScope,
                        Registers:      NewRegisters(t.registers),
                        ResourceLimits: t.resourceLimits,
                        Environment:    t.environment,
                        RethrowErrors:  t.rethrowErrors,
                })

                // If assigns is a drop, we need special handling for variable lookups
                // Store it in a special way so FindVariable can access it
                if drop, ok := dropToStore.(interface{ SetContext(*Context) }); ok </span><span class="cov2" title="2">{
                        // Set the context on the drop
                        drop.SetContext(ctx)
                        // Make the drop available as the primary lookup source
                        // by putting it in the outer scope with a special key
                        ctx.Scopes()[len(ctx.Scopes())-1]["__drop__"] = dropToStore
                        // Also store in template's instance assigns for future renders
                        t.instanceAssigns["__drop__"] = dropToStore
                }</span>
        }

        // Apply options
        <span class="cov9" title="23">if options != nil </span><span class="cov6" title="9">{
                // Set registers
                if options.Registers != nil </span><span class="cov1" title="1">{
                        for key, value := range options.Registers </span><span class="cov1" title="1">{
                                ctx.Registers().Set(key, value)
                        }</span>
                }

                // Apply other options
                <span class="cov6" title="9">if options.Filters != nil </span><span class="cov1" title="1">{
                        ctx.AddFilters(options.Filters)
                }</span>
                <span class="cov6" title="9">if options.GlobalFilter != nil </span><span class="cov1" title="1">{
                        ctx.SetGlobalFilter(options.GlobalFilter)
                }</span>
                <span class="cov6" title="9">if options.ExceptionRenderer != nil </span><span class="cov1" title="1">{
                        ctx.SetExceptionRenderer(options.ExceptionRenderer)
                }</span>
                <span class="cov6" title="9">if options.StrictVariables </span><span class="cov1" title="1">{
                        ctx.SetStrictVariables(true)
                }</span>
                <span class="cov6" title="9">if options.StrictFilters </span><span class="cov1" title="1">{
                        ctx.SetStrictFilters(true)
                }</span>
        }

        <span class="cov9" title="23">return ctx</span>
}

// configureOptions configures parse options and returns a ParseContext.
func (t *Template) configureOptions(options *TemplateOptions) ParseContextInterface <span class="cov9" title="24">{
        if options == nil </span><span class="cov8" title="20">{
                options = &amp;TemplateOptions{}
        }</span>

        <span class="cov9" title="24">if options.Environment != nil </span><span class="cov4" title="4">{
                t.environment = options.Environment
        }</span> else<span class="cov8" title="20"> if t.environment == nil </span><span class="cov0" title="0">{
                t.environment = NewEnvironment()
        }</span>

        <span class="cov9" title="24">t.profiling = options.Profile
        t.lineNumbers = options.LineNumbers || t.profiling

        // Create parse context
        templateOpts := make(map[string]interface{})
        if options.StrictVariables </span><span class="cov1" title="1">{
                templateOpts["strict_variables"] = true
        }</span>
        <span class="cov9" title="24">if options.StrictFilters </span><span class="cov0" title="0">{
                templateOpts["strict_filters"] = true
        }</span>
        <span class="cov9" title="24">if t.lineNumbers </span><span class="cov2" title="2">{
                templateOpts["line_numbers"] = true
        }</span>

        <span class="cov9" title="24">parseContextOpts := ParseContextOptions{
                Environment:     t.environment,
                TemplateOptions: templateOpts,
        }

        return NewParseContext(parseContextOpts)</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package liquid

// TemplateFactory creates template instances.
type TemplateFactory struct{}

// NewTemplateFactory creates a new TemplateFactory.
func NewTemplateFactory() *TemplateFactory <span class="cov10" title="109">{
        return &amp;TemplateFactory{}
}</span>

// For returns a template instance for the given template name.
func (tf *TemplateFactory) For(templateName string) interface{} <span class="cov2" title="2">{
        // Return a new Template instance (name is not used in Ruby implementation)
        return NewTemplate(nil)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package liquid

import (
        "regexp"
        "strings"
)

var (
        tokenizerTagEnd             = regexp.MustCompile(`%\}`)
        tokenizerTagOrVariableStart = regexp.MustCompile(`\{[\{\%]`)
)

const (
        openCurley  = '{'
        closeCurley = '}'
        percentage  = '%'
)

// Tokenizer tokenizes template source into text, tags, and variables.
type Tokenizer struct {
        lineNumber   *int
        ss           *StringScanner
        source       string
        tokens       []string
        offset       int
        forLiquidTag bool
}

// NewTokenizer creates a new tokenizer.
func NewTokenizer(source string, stringScanner *StringScanner, lineNumbers bool, startLineNumber *int, forLiquidTag bool) *Tokenizer <span class="cov8" title="86">{
        t := &amp;Tokenizer{
                source:       source,
                offset:       0,
                tokens:       []string{},
                forLiquidTag: forLiquidTag,
                ss:           stringScanner,
        }

        if startLineNumber != nil </span><span class="cov4" title="6">{
                t.lineNumber = startLineNumber
        }</span> else<span class="cov8" title="80"> if lineNumbers </span><span class="cov3" title="5">{
                one := 1
                t.lineNumber = &amp;one
        }</span>

        <span class="cov8" title="86">if source != "" </span><span class="cov8" title="82">{
                if t.ss == nil </span><span class="cov5" title="14">{
                        t.ss = NewStringScanner(source)
                }</span> else<span class="cov8" title="68"> {
                        t.ss.SetString(source)
                }</span>
                <span class="cov8" title="82">t.tokenize()</span>
        }

        <span class="cov8" title="86">return t</span>
}

// Shift returns the next token and advances the offset.
func (t *Tokenizer) Shift() string <span class="cov9" title="172">{
        if t.offset &gt;= len(t.tokens) </span><span class="cov8" title="64">{
                return ""
        }</span>

        <span class="cov8" title="108">token := t.tokens[t.offset]
        t.offset++

        if t.lineNumber != nil </span><span class="cov4" title="9">{
                if t.forLiquidTag </span><span class="cov4" title="6">{
                        *t.lineNumber++
                }</span> else<span class="cov2" title="3"> {
                        *t.lineNumber += strings.Count(token, "\n")
                }</span>
        }

        <span class="cov8" title="108">return token</span>
}

// LineNumber returns the current line number.
func (t *Tokenizer) LineNumber() *int <span class="cov9" title="112">{
        return t.lineNumber
}</span>

// ForLiquidTag returns whether this tokenizer is for a liquid tag.
func (t *Tokenizer) ForLiquidTag() bool <span class="cov7" title="51">{
        return t.forLiquidTag
}</span>

func (t *Tokenizer) tokenize() <span class="cov8" title="82">{
        if t.forLiquidTag </span><span class="cov5" title="16">{
                t.tokens = strings.Split(t.source, "\n")
        }</span> else<span class="cov8" title="66"> {
                for !t.ss.EOS() </span><span class="cov8" title="98">{
                        token := t.shiftNormal()
                        if token == "" </span><span class="cov0" title="0">{
                                // If we get an empty token but we're not at EOS, there might be remaining text
                                if !t.ss.EOS() </span><span class="cov0" title="0">{
                                        // Get remaining text
                                        rest := t.ss.Rest()
                                        if rest != "" </span><span class="cov0" title="0">{
                                                t.tokens = append(t.tokens, rest)
                                                t.ss.Terminate()
                                        }</span>
                                }
                                <span class="cov0" title="0">break</span>
                        }
                        <span class="cov8" title="98">t.tokens = append(t.tokens, token)</span>
                }
        }

        <span class="cov8" title="82">t.source = ""
        t.ss = nil</span>
}

func (t *Tokenizer) shiftNormal() string <span class="cov8" title="98">{
        if t.ss.EOS() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="98">token := t.nextToken()
        return token</span>
}

func (t *Tokenizer) nextToken() string <span class="cov8" title="98">{
        byteA := t.ss.PeekByte()

        if byteA == openCurley </span><span class="cov7" title="57">{
                t.ss.ScanByte()

                byteB := t.ss.PeekByte()

                switch byteB </span>{
                case percentage:<span class="cov6" title="28">
                        t.ss.ScanByte()
                        return t.nextTagToken()</span>
                case openCurley:<span class="cov6" title="29">
                        t.ss.ScanByte()
                        return t.nextVariableToken()</span>
                }

                <span class="cov0" title="0">t.ss.SetPos(t.ss.Pos() - 1)</span>
        }

        <span class="cov7" title="41">return t.nextTextToken()</span>
}

func (t *Tokenizer) nextTextToken() string <span class="cov7" title="41">{
        start := t.ss.Pos()

        // Save rest before SkipUntil (in case there's no match)
        restBeforeSkip := t.ss.Rest()

        skipLen := t.ss.SkipUntil(tokenizerTagOrVariableStart)
        if skipLen == 0 </span><span class="cov5" title="17">{
                // No match found, return the rest we saved
                t.ss.Terminate()
                return restBeforeSkip
        }</span>

        // Back up 2 characters to get the position before the match
        // (SkipUntil advances to after the match)
        // This also sets the scanner position back so nextToken can detect the tag/variable
        <span class="cov6" title="24">pos := t.ss.Pos() - 2
        if pos &lt; start </span><span class="cov0" title="0">{
                pos = start
        }</span>
        <span class="cov6" title="24">t.ss.SetPos(pos)
        return t.ss.Byteslice(start, pos-start)</span>
}

func (t *Tokenizer) nextVariableToken() string <span class="cov6" title="29">{
        start := t.ss.Pos() - 2

        byteA := t.ss.ScanByte()
        byteB := byteA

        for byteB != 0 </span><span class="cov6" title="31">{
                // Scan until we find a closing brace or opening brace
                for byteA != 0 &amp;&amp; byteA != closeCurley &amp;&amp; byteA != openCurley </span><span class="cov10" title="202">{
                        byteA = t.ss.ScanByte()
                }</span>

                <span class="cov6" title="31">if byteA == 0 </span><span class="cov1" title="1">{
                        break</span>
                }

                <span class="cov6" title="30">if t.ss.EOS() </span><span class="cov0" title="0">{
                        if byteA == closeCurley </span><span class="cov0" title="0">{
                                return t.ss.Byteslice(start, t.ss.Pos()-start)
                        }</span>
                        <span class="cov0" title="0">return "{{"</span>
                }

                <span class="cov6" title="30">byteB = t.ss.ScanByte()

                if byteA == closeCurley </span><span class="cov6" title="27">{
                        if byteB == closeCurley </span><span class="cov6" title="27">{
                                return t.ss.Byteslice(start, t.ss.Pos()-start)
                        }</span> else<span class="cov0" title="0"> {
                                // Not a closing brace, back up
                                t.ss.SetPos(t.ss.Pos() - 1)
                                return t.ss.Byteslice(start, t.ss.Pos()-start)
                        }</span>
                } else<span class="cov2" title="3"> if byteA == openCurley &amp;&amp; byteB == percentage </span><span class="cov1" title="1">{
                        return t.nextTagTokenWithStart(start)
                }</span>

                <span class="cov2" title="2">byteA = byteB</span>
        }

        <span class="cov1" title="1">return "{{"</span>
}

func (t *Tokenizer) nextTagToken() string <span class="cov6" title="28">{
        start := t.ss.Pos() - 2
        if len := t.ss.SkipUntil(tokenizerTagEnd); len &gt; 0 </span><span class="cov6" title="27">{
                return t.ss.Byteslice(start, len+2)
        }</span>
        <span class="cov1" title="1">return "{%"</span>
}

func (t *Tokenizer) nextTagTokenWithStart(start int) string <span class="cov1" title="1">{
        t.ss.SkipUntil(tokenizerTagEnd)
        return t.ss.Byteslice(start, t.ss.Pos()-start)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package liquid

// Usage provides usage tracking functionality.
// Currently a placeholder for future implementation.
type Usage struct{}

// Increment increments usage count for a given name.
// Currently a no-op, to be implemented when usage tracking is needed.
func (u *Usage) Increment(name string) {<span class="cov10" title="2">
        // TODO: Implement usage tracking
}</span>

// GlobalUsage is the global usage tracker.
var GlobalUsage = &amp;Usage{}

// IncrementUsage increments usage for the global tracker.
func IncrementUsage(name string) <span class="cov1" title="1">{
        GlobalUsage.Increment(name)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package liquid

import (
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"
        "time"
)

var (
        // DECIMAL_REGEX matches decimal numbers
        DECIMAL_REGEX = regexp.MustCompile(`^-?\d+\.\d+$`)

        // UNIX_TIMESTAMP_REGEX matches unix timestamps
        UNIX_TIMESTAMP_REGEX = regexp.MustCompile(`^\d+$`)
)

// SliceCollection slices a collection from index `from` to index `to` (exclusive).
// If `to` is nil, slices to the end.
func SliceCollection(collection interface{}, from int, to *int) []interface{} <span class="cov5" title="15">{
        // Check if collection has a LoadSlice method (for custom collections)
        if loadSlicer, ok := collection.(interface {
                LoadSlice(from int, to *int) []interface{}
        }); ok </span><span class="cov2" title="2">{
                if from != 0 || to != nil </span><span class="cov1" title="1">{
                        return loadSlicer.LoadSlice(from, to)
                }</span>
        }

        <span class="cov5" title="14">return sliceCollectionUsingEach(collection, from, to)</span>
}

func sliceCollectionUsingEach(collection interface{}, from int, to *int) []interface{} <span class="cov5" title="14">{
        var segments []interface{}

        // Handle strings specially
        if str, ok := collection.(string); ok </span><span class="cov2" title="2">{
                if str == "" </span><span class="cov1" title="1">{
                        return []interface{}{}
                }</span>
                <span class="cov1" title="1">return []interface{}{str}</span>
        }

        // Check if collection implements Each method
        <span class="cov5" title="12">if eacher, ok := collection.(interface {
                Each(func(interface{}))
        }); ok </span><span class="cov1" title="1">{
                index := 0
                eacher.Each(func(item interface{}) </span><span class="cov3" title="5">{
                        if to != nil &amp;&amp; *to &lt;= index </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov3" title="5">if from &lt;= index </span><span class="cov3" title="5">{
                                segments = append(segments, item)
                        }</span>
                        <span class="cov3" title="5">index++</span>
                })
                <span class="cov1" title="1">return segments</span>
        }

        // Use reflection to iterate
        <span class="cov4" title="11">v := reflect.ValueOf(collection)
        if v.Kind() != reflect.Slice &amp;&amp; v.Kind() != reflect.Array </span><span class="cov2" title="2">{
                return []interface{}{}
        }</span>

        <span class="cov4" title="9">index := 0
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov6" title="26">{
                if to != nil &amp;&amp; *to &lt;= index </span><span class="cov3" title="4">{
                        break</span>
                }

                <span class="cov6" title="22">if from &lt;= index </span><span class="cov4" title="10">{
                        segments = append(segments, v.Index(i).Interface())
                }</span>

                <span class="cov6" title="22">index++</span>
        }

        <span class="cov4" title="9">return segments</span>
}

// ToInteger converts a value to an integer.
// Optimization: Fast path for int type (most common case).
func ToInteger(num interface{}) (int, error) <span class="cov7" title="62">{
        // Fast path for most common case
        if v, ok := num.(int); ok </span><span class="cov6" title="36">{
                return v, nil
        }</span>

        // Handle other numeric types
        <span class="cov6" title="26">switch v := num.(type) </span>{
        case int8:<span class="cov1" title="1">
                return int(v), nil</span>
        case int16:<span class="cov1" title="1">
                return int(v), nil</span>
        case int32:<span class="cov2" title="2">
                return int(v), nil</span>
        case int64:<span class="cov2" title="2">
                return int(v), nil</span>
        case uint:<span class="cov1" title="1">
                return int(v), nil</span>
        case uint8:<span class="cov1" title="1">
                return int(v), nil</span>
        case uint16:<span class="cov1" title="1">
                return int(v), nil</span>
        case uint32:<span class="cov1" title="1">
                return int(v), nil</span>
        case uint64:<span class="cov1" title="1">
                return int(v), nil</span>
        case float64:<span class="cov2" title="3">
                return int(v), nil</span>
        case string:<span class="cov3" title="5">
                i, err := strconv.Atoi(v)
                if err != nil </span><span class="cov3" title="4">{
                        return 0, NewArgumentError("invalid integer")
                }</span>
                <span class="cov1" title="1">return i, nil</span>
        default:<span class="cov4" title="7">
                return 0, NewArgumentError("invalid integer")</span>
        }
}

// ToNumber converts a value to a number (int or float64).
func ToNumber(obj interface{}) interface{} <span class="cov5" title="17">{
        switch v := obj.(type) </span>{
        case float32:<span class="cov1" title="1">
                return float64(v)</span>
        case float64:<span class="cov1" title="1">
                return v</span>
        case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov3" title="6">
                return v</span>
        case string:<span class="cov4" title="8">
                trimmed := strings.TrimSpace(v)
                if DECIMAL_REGEX.MatchString(trimmed) </span><span class="cov2" title="3">{
                        f, err := strconv.ParseFloat(trimmed, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                        <span class="cov2" title="3">return f</span>
                }
                <span class="cov3" title="5">i, err := strconv.Atoi(trimmed)
                if err != nil </span><span class="cov2" title="3">{
                        return 0
                }</span>
                <span class="cov2" title="2">return i</span>
        default:<span class="cov1" title="1">
                if toNumberer, ok := obj.(interface {
                        ToNumber() interface{}
                }); ok </span><span class="cov1" title="1">{
                        return toNumberer.ToNumber()
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
}

// ToDate converts a value to a time.Time.
func ToDate(obj interface{}) *time.Time <span class="cov4" title="10">{
        // If it already has a Strftime method (time.Time), return it
        if t, ok := obj.(time.Time); ok </span><span class="cov1" title="1">{
                return &amp;t
        }</span>

        <span class="cov4" title="9">switch v := obj.(type) </span>{
        case string:<span class="cov3" title="6">
                if v == "" </span><span class="cov1" title="1">{
                        return nil
                }</span>
                <span class="cov3" title="5">lower := strings.ToLower(v)
                if lower == "now" || lower == "today" </span><span class="cov2" title="2">{
                        now := time.Now()
                        return &amp;now
                }</span>
                <span class="cov2" title="3">if UNIX_TIMESTAMP_REGEX.MatchString(v) </span><span class="cov1" title="1">{
                        ts, err := strconv.ParseInt(v, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov1" title="1">t := time.Unix(ts, 0)
                        return &amp;t</span>
                }
                // Try parsing as RFC3339 or common formats
                <span class="cov2" title="2">t, err := time.Parse(time.RFC3339, v)
                if err != nil </span><span class="cov2" title="2">{
                        // Try other common formats
                        formats := []string{
                                time.RFC1123,
                                time.RFC1123Z,
                                "2006-01-02",
                                "2006-01-02 15:04:05",
                        }
                        for _, format := range formats </span><span class="cov4" title="7">{
                                if t, err := time.Parse(format, v); err == nil </span><span class="cov1" title="1">{
                                        return &amp;t
                                }</span>
                        }
                        <span class="cov1" title="1">return nil</span>
                }
                <span class="cov0" title="0">return &amp;t</span>
        case int, int64:<span class="cov2" title="2">
                var ts int64
                switch vv := v.(type) </span>{
                case int:<span class="cov1" title="1">
                        ts = int64(vv)</span>
                case int64:<span class="cov1" title="1">
                        ts = vv</span>
                }
                <span class="cov2" title="2">t := time.Unix(ts, 0)
                return &amp;t</span>
        default:<span class="cov1" title="1">
                return nil</span>
        }
}

// ToLiquidValue converts an object to its liquid representation.
func ToLiquidValue(obj interface{}) interface{} <span class="cov7" title="53">{
        if toLiquid, ok := obj.(interface {
                ToLiquidValue() interface{}
        }); ok </span><span class="cov1" title="1">{
                return toLiquid.ToLiquidValue()
        }</span>
        <span class="cov7" title="52">return obj</span>
}

// ToS converts an object to a string representation.
// Optimization: Fast path for common types to enable compiler inlining.
func ToS(obj interface{}, seen map[uintptr]bool) string <span class="cov10" title="231">{
        // Handle nil - in Liquid, nil renders as empty string (like Ruby's nil.to_s)
        if obj == nil </span><span class="cov3" title="6">{
                return ""
        }</span>

        // Fast path for common types (helps with inlining)
        <span class="cov9" title="225">switch v := obj.(type) </span>{
        case string:<span class="cov9" title="197">
                return v</span>
        case int:<span class="cov4" title="9">
                return strconv.Itoa(v)</span>
        case bool:<span class="cov2" title="2">
                if v </span><span class="cov1" title="1">{
                        return "true"
                }</span>
                <span class="cov1" title="1">return "false"</span>
        case float64:<span class="cov1" title="1">
                return strconv.FormatFloat(v, 'f', -1, 64)</span>
        case map[string]interface{}:<span class="cov2" title="2">
                if seen == nil </span><span class="cov2" title="2">{
                        seen = make(map[uintptr]bool)
                }</span>
                <span class="cov2" title="2">return hashInspect(v, seen)</span>
        case []interface{}:<span class="cov2" title="2">
                if seen == nil </span><span class="cov2" title="2">{
                        seen = make(map[uintptr]bool)
                }</span>
                <span class="cov2" title="2">return arrayInspect(v, seen)</span>
        default:<span class="cov5" title="12">
                return fmt.Sprintf("%v", obj)</span>
        }
}

// Inspect returns a detailed string representation of an object.
func Inspect(obj interface{}, seen map[uintptr]bool) string <span class="cov5" title="19">{
        if seen == nil </span><span class="cov3" title="5">{
                seen = make(map[uintptr]bool)
        }</span>

        <span class="cov5" title="19">switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov1" title="1">
                return hashInspect(v, seen)</span>
        case []interface{}:<span class="cov1" title="1">
                return arrayInspect(v, seen)</span>
        default:<span class="cov5" title="17">
                return fmt.Sprintf("%#v", obj)</span>
        }
}

func arrayInspect(arr []interface{}, seen map[uintptr]bool) string <span class="cov2" title="3">{
        ptr := reflect.ValueOf(arr).Pointer()
        if seen[ptr] </span><span class="cov0" title="0">{
                return "[...]"
        }</span>

        <span class="cov2" title="3">seen[ptr] = true
        defer delete(seen, ptr)

        var b strings.Builder
        b.WriteString("[")
        for i, item := range arr </span><span class="cov4" title="8">{
                if i &gt; 0 </span><span class="cov3" title="5">{
                        b.WriteString(", ")
                }</span>
                <span class="cov4" title="8">b.WriteString(Inspect(item, seen))</span>
        }
        <span class="cov2" title="3">b.WriteString("]")
        return b.String()</span>
}

func hashInspect(hash map[string]interface{}, seen map[uintptr]bool) string <span class="cov2" title="3">{
        ptr := reflect.ValueOf(hash).Pointer()
        if seen[ptr] </span><span class="cov0" title="0">{
                return "{...}"
        }</span>

        <span class="cov2" title="3">seen[ptr] = true
        defer delete(seen, ptr)

        var b strings.Builder
        b.WriteString("{")
        first := true
        for key, value := range hash </span><span class="cov2" title="3">{
                if !first </span><span class="cov0" title="0">{
                        b.WriteString(", ")
                }</span>
                <span class="cov2" title="3">first = false
                b.WriteString(Inspect(key, seen))
                b.WriteString("=&gt;")
                b.WriteString(Inspect(value, seen))</span>
        }
        <span class="cov2" title="3">b.WriteString("}")
        return b.String()</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package liquid

import (
        "regexp"
        "strings"
)

var (
        variableFilterMarkupRegex        = regexp.MustCompile(`\|\s*(.*)`)
        variableFilterParser             = regexp.MustCompile(`(?:\s+|"[^"]*"|'[^']*'|(?:[^\s,\|'"]|"[^"]*"|'[^']*')+)+`)
        variableFilterArgsRegex          = regexp.MustCompile(`(?::|,)\s*((?:\w+\s*:\s*)?(?:[^\s,\|'"]|"[^"]*"|'[^']*')+)`)
        variableJustTagAttributes        = regexp.MustCompile(`^(\w[\w-]*)\s*:\s*((?:"[^"]*"|'[^']*'|(?:[^\s,\|'"]|"[^"]*"|'[^']*')+)+)$`)
        variableMarkupWithQuotedFragment = regexp.MustCompile(`^([^\|]+)(.*)$`)
)

// ParseContextInterface interface for parsing expressions
// This interface is implemented by ParseContext struct
type ParseContextInterface interface {
        ParseExpression(markup string) interface{}
        SafeParseExpression(parser *Parser) interface{}
        NewParser(markup string) *Parser
        LineNumber() *int
        SetLineNumber(*int)
        Environment() *Environment
        TrimWhitespace() bool
        SetTrimWhitespace(bool)
        Depth() int
        IncrementDepth()
        DecrementDepth()
        NewBlockBody() *BlockBody
        NewTokenizer(source string, lineNumbers bool, startLineNumber *int, forLiquidTag bool) *Tokenizer
}

// Variable represents a Liquid variable with optional filters.
type Variable struct {
        name         interface{}
        parseContext ParseContextInterface
        lineNumber   *int
        markup       string
        filters      [][]interface{}
}

// NewVariable creates a new Variable from markup.
func NewVariable(markup string, parseContext ParseContextInterface) *Variable <span class="cov9" title="55">{
        v := &amp;Variable{
                markup:       markup,
                parseContext: parseContext,
                lineNumber:   parseContext.LineNumber(),
        }

        // Use parser switching based on error mode
        // Create a wrapper that implements the ParserSwitching interface
        var psContext interface {
                ErrorMode() string
                AddWarning(error)
        }
        if pc, ok := parseContext.(*ParseContext); ok </span><span class="cov9" title="41">{
                psContext = pc
        }</span> else<span class="cov6" title="14"> {
                // Fallback: create a minimal wrapper
                psContext = &amp;parseContextWrapper{
                        errorMode: "lax", // Default to lax if we can't determine
                }
        }</span>

        <span class="cov9" title="55">ps := &amp;ParserSwitching{
                parseContext:  psContext,
                lineNumber:    parseContext.LineNumber(),
                markupContext: v.markupContext,
        }

        err := ps.StrictParseWithErrorModeFallback(
                markup,
                func(m string) error </span><span class="cov9" title="49">{
                        // Catch panics from SafeParseExpression and convert to errors
                        var parseErr error
                        func() </span><span class="cov9" title="49">{
                                defer func() </span><span class="cov9" title="49">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                if e, ok := r.(error); ok </span><span class="cov0" title="0">{
                                                        parseErr = e
                                                }</span> else<span class="cov0" title="0"> {
                                                        panic(r)</span> // Re-panic non-error panics
                                                }
                                        }
                                }()
                                <span class="cov9" title="49">parseErr = v.strictParse(m)</span>
                        }()
                        <span class="cov9" title="49">return parseErr</span>
                },
                func(m string) error <span class="cov0" title="0">{
                        v.laxParse(m)
                        return nil
                }</span>,
                func(m string) error <span class="cov4" title="6">{
                        // Catch panics from SafeParseExpression and convert to errors
                        var parseErr error
                        func() </span><span class="cov4" title="6">{
                                defer func() </span><span class="cov4" title="6">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                if e, ok := r.(error); ok </span><span class="cov0" title="0">{
                                                        parseErr = e
                                                }</span> else<span class="cov0" title="0"> {
                                                        panic(r)</span> // Re-panic non-error panics
                                                }
                                        }
                                }()
                                <span class="cov4" title="6">parseErr = v.rigidParse(m)</span>
                        }()
                        <span class="cov4" title="6">return parseErr</span>
                },
        )

        // If there was an error, it's already been handled by parser switching
        // But in strict/rigid mode, we need to panic it
        <span class="cov9" title="55">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov9" title="55">return v</span>
}

// markupContext returns a context string for markup.
func (v *Variable) markupContext(markup string) string <span class="cov1" title="1">{
        return "in \"{{" + markup + "}}\""
}</span>

// Raw returns the raw markup.
func (v *Variable) Raw() string <span class="cov3" title="3">{
        return v.markup
}</span>

// Name returns the variable name expression.
func (v *Variable) Name() interface{} <span class="cov9" title="40">{
        return v.name
}</span>

// Filters returns the filters.
func (v *Variable) Filters() [][]interface{} <span class="cov9" title="42">{
        return v.filters
}</span>

// LineNumber returns the line number.
func (v *Variable) LineNumber() *int <span class="cov4" title="4">{
        return v.lineNumber
}</span>

func (v *Variable) laxParse(markup string) <span class="cov3" title="3">{
        v.filters = [][]interface{}{}
        matches := variableMarkupWithQuotedFragment.FindStringSubmatch(markup)
        if len(matches) &lt; 2 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">nameMarkup := strings.TrimSpace(matches[1])
        filterMarkup := matches[2]

        v.name = v.parseContext.ParseExpression(nameMarkup)

        if filterMarkup != "" </span><span class="cov2" title="2">{
                filterMatches := variableFilterMarkupRegex.FindStringSubmatch(filterMarkup)
                if len(filterMatches) &gt; 1 </span><span class="cov2" title="2">{
                        filters := variableFilterParser.FindAllString(filterMatches[1], -1)
                        for _, f := range filters </span><span class="cov3" title="3">{
                                f = strings.TrimSpace(f)
                                if f == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                // Extract filter name (first word)
                                <span class="cov3" title="3">parts := strings.Fields(f)
                                if len(parts) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov3" title="3">filterName := parts[0]
                                // Extract filter args
                                filterArgs := variableFilterArgsRegex.FindAllString(f, -1)
                                v.filters = append(v.filters, v.laxParseFilterExpressions(filterName, filterArgs))</span>
                        }
                }
        }
}

func (v *Variable) strictParse(markup string) error <span class="cov9" title="49">{
        v.filters = [][]interface{}{}
        p := v.parseContext.NewParser(markup)

        if p.Look(":end_of_string", 0) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov9" title="49">v.name = v.parseContext.SafeParseExpression(p)
        for </span><span class="cov10" title="59">{
                _, ok := p.ConsumeOptional(":pipe")
                if !ok </span><span class="cov9" title="49">{
                        break</span>
                }
                <span class="cov6" title="10">filterName, err := p.Consume(":id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="10">var filterArgs []string
                if _, ok := p.ConsumeOptional(":colon"); ok </span><span class="cov0" title="0">{
                        filterArgs = v.parseFilterArgs(p)
                }</span> else<span class="cov6" title="10"> {
                        filterArgs = []string{}
                }</span>
                <span class="cov6" title="10">v.filters = append(v.filters, v.laxParseFilterExpressions(filterName, filterArgs))</span>
        }
        <span class="cov9" title="49">_, err := p.Consume(":end_of_string")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="49">return nil</span>
}

func (v *Variable) rigidParse(markup string) error <span class="cov4" title="6">{
        v.filters = [][]interface{}{}
        p := v.parseContext.NewParser(markup)

        if p.Look(":end_of_string", 0) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="6">v.name = v.parseContext.SafeParseExpression(p)
        for </span><span class="cov5" title="9">{
                _, ok := p.ConsumeOptional(":pipe")
                if !ok </span><span class="cov4" title="6">{
                        break</span>
                }
                <span class="cov3" title="3">v.filters = append(v.filters, v.rigidParseFilterExpressions(p))</span>
        }
        <span class="cov4" title="6">_, err := p.Consume(":end_of_string")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="6">return nil</span>
}

func (v *Variable) parseFilterArgs(p *Parser) []string <span class="cov3" title="3">{
        arg, err := p.Argument()
        if err != nil </span><span class="cov1" title="1">{
                return []string{}
        }</span>
        <span class="cov2" title="2">filterArgs := []string{arg}
        for </span><span class="cov4" title="4">{
                _, ok := p.ConsumeOptional(":comma")
                if !ok </span><span class="cov2" title="2">{
                        break</span>
                }
                <span class="cov2" title="2">arg, err := p.Argument()
                if err == nil </span><span class="cov2" title="2">{
                        filterArgs = append(filterArgs, arg)
                }</span>
        }
        <span class="cov2" title="2">return filterArgs</span>
}

func (v *Variable) laxParseFilterExpressions(filterName string, unparsedArgs []string) []interface{} <span class="cov7" title="17">{
        filterArgs := []interface{}{}
        var keywordArgs map[string]interface{}

        for _, a := range unparsedArgs </span><span class="cov4" title="5">{
                matches := variableJustTagAttributes.FindStringSubmatch(a)
                if len(matches) == 3 </span><span class="cov2" title="2">{
                        if keywordArgs == nil </span><span class="cov2" title="2">{
                                keywordArgs = make(map[string]interface{})
                        }</span>
                        <span class="cov2" title="2">keywordArgs[matches[1]] = v.parseContext.ParseExpression(matches[2])</span>
                } else<span class="cov3" title="3"> {
                        filterArgs = append(filterArgs, v.parseContext.ParseExpression(a))
                }</span>
        }

        <span class="cov7" title="17">result := []interface{}{filterName, filterArgs}
        if keywordArgs != nil </span><span class="cov2" title="2">{
                result = append(result, keywordArgs)
        }</span>
        <span class="cov7" title="17">return result</span>
}

func (v *Variable) rigidParseFilterExpressions(p *Parser) []interface{} <span class="cov3" title="3">{
        filterName, _ := p.Consume(":id")
        filterArgs := []interface{}{}
        keywordArgs := make(map[string]interface{})

        if _, ok := p.ConsumeOptional(":colon"); ok </span><span class="cov2" title="2">{
                // Parse first argument (no leading comma)
                if !v.endOfArguments(p) </span><span class="cov2" title="2">{
                        v.argument(p, &amp;filterArgs, keywordArgs)
                }</span>

                // Parse remaining arguments (with leading commas)
                <span class="cov2" title="2">for </span><span class="cov3" title="3">{
                        _, ok := p.ConsumeOptional(":comma")
                        if !ok || v.endOfArguments(p) </span><span class="cov2" title="2">{
                                break</span>
                        }
                        <span class="cov1" title="1">v.argument(p, &amp;filterArgs, keywordArgs)</span>
                }
        }

        <span class="cov3" title="3">result := []interface{}{filterName, filterArgs}
        if len(keywordArgs) &gt; 0 </span><span class="cov1" title="1">{
                result = append(result, keywordArgs)
        }</span>
        <span class="cov3" title="3">return result</span>
}

func (v *Variable) argument(p *Parser, positionalArgs *[]interface{}, keywordArgs map[string]interface{}) <span class="cov4" title="5">{
        if p.Look(":id", 0) &amp;&amp; p.Look(":colon", 1) </span><span class="cov2" title="2">{
                key, _ := p.Consume(":id")
                _, _ = p.Consume(":colon")
                value := v.parseContext.SafeParseExpression(p)
                keywordArgs[key] = value
        }</span> else<span class="cov3" title="3"> {
                expr, err := p.Argument()
                if err == nil </span><span class="cov3" title="3">{
                        *positionalArgs = append(*positionalArgs, v.parseContext.ParseExpression(expr))
                }</span>
        }
}

func (v *Variable) endOfArguments(p *Parser) bool <span class="cov4" title="6">{
        return p.Look(":pipe", 0) || p.Look(":end_of_string", 0)
}</span>

// Render renders the variable.
func (v *Variable) Render(context TagContext) interface{} <span class="cov8" title="36">{
        // Evaluate the variable name expression directly (like Ruby: context.evaluate(@name))
        nameExpr := v.Name()
        value := context.Evaluate(nameExpr)

        // Apply filters
        for _, filter := range v.Filters() </span><span class="cov6" title="15">{
                if len(filter) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="15">filterName := ToS(filter[0], nil)
                var filterArgs []interface{}
                if len(filter) &gt; 1 </span><span class="cov6" title="15">{
                        if args, ok := filter[1].([]interface{}); ok </span><span class="cov6" title="15">{
                                filterArgs = args
                        }</span>
                }

                // Evaluate filter arguments
                <span class="cov6" title="15">evaluatedArgs := make([]interface{}, len(filterArgs))
                for i, arg := range filterArgs </span><span class="cov0" title="0">{
                        evaluatedArgs[i] = context.Evaluate(arg)
                }</span>

                // Invoke filter
                <span class="cov6" title="15">value = context.Invoke(filterName, value, evaluatedArgs...)</span>
        }

        // Apply global filter (like Ruby: context.apply_global_filter(obj))
        <span class="cov8" title="36">ctx := context.Context().(*Context)
        value = ctx.ApplyGlobalFilter(value)

        return value</span>
}

// RenderToOutputBuffer renders the variable to the output buffer.
func (v *Variable) RenderToOutputBuffer(context TagContext, output *string) <span class="cov8" title="29">{
        val := v.Render(context)
        *output += ToS(val, nil)
}</span>

// parseContextWrapper is a minimal wrapper for ParseContextInterface when it doesn't implement ErrorMode/AddWarning.
type parseContextWrapper struct {
        errorMode string
}

func (p *parseContextWrapper) ErrorMode() string <span class="cov6" title="14">{
        return p.errorMode
}</span>

func (p *parseContextWrapper) AddWarning(error) {<span class="cov1" title="1">
        // No-op for wrapper
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package liquid

import (
        "strings"
        "sync"
)

var (
        variableLookupCommandMethods = []string{"size", "first", "last"}
)

// globalVariableLookupCache provides thread-safe caching of parsed variable lookups.
// Optimization: Avoids re-parsing the same variable lookups repeatedly.
var globalVariableLookupCache sync.Map // map[string]*VariableLookup

// VariableLookup represents a variable lookup expression.
type VariableLookup struct {
        name         interface{}
        lookups      []interface{}
        commandFlags uint
}

// VariableLookupParse parses a markup string into a VariableLookup.
// Optimization: Uses global cache for better performance across templates.
func VariableLookupParse(markup string, ss *StringScanner, cache map[string]interface{}) *VariableLookup <span class="cov10" title="97">{
        // Try global cache first for simple variable lookups (no dynamic parts)
        // We can only cache if the markup doesn't contain dynamic expressions in brackets
        canCache := !strings.Contains(markup, "[")

        if canCache </span><span class="cov9" title="94">{
                if cached, ok := globalVariableLookupCache.Load(markup); ok </span><span class="cov9" title="60">{
                        return cached.(*VariableLookup)
                }</span>
        }

        // Scan for variable parts using VariableParser pattern
        // This matches [brackets] or identifier? patterns
        <span class="cov8" title="37">matches := VariableParser.FindAllString(markup, -1)
        if len(matches) == 0 </span><span class="cov0" title="0">{
                vl := &amp;VariableLookup{name: markup, lookups: []interface{}{}}
                if canCache </span><span class="cov0" title="0">{
                        globalVariableLookupCache.Store(markup, vl)
                }</span>
                <span class="cov0" title="0">return vl</span>
        }

        <span class="cov8" title="37">lookups := make([]interface{}, len(matches))
        for i, match := range matches </span><span class="cov8" title="50">{
                lookups[i] = match
        }</span>

        <span class="cov8" title="37">name := lookups[0]
        lookups = lookups[1:]

        // Parse name if it's in brackets
        if nameStr, ok := name.(string); ok </span><span class="cov8" title="37">{
                if strings.HasPrefix(nameStr, "[") &amp;&amp; strings.HasSuffix(nameStr, "]") </span><span class="cov0" title="0">{
                        name = Parse(nameStr[1:len(nameStr)-1], ss, cache)
                        canCache = false // Can't cache variable lookups with dynamic names
                }</span>
        }

        <span class="cov8" title="37">vl := &amp;VariableLookup{
                name:         name,
                lookups:      lookups,
                commandFlags: 0,
        }

        // Process lookups
        for i, lookup := range vl.lookups </span><span class="cov6" title="13">{
                if lookupStr, ok := lookup.(string); ok </span><span class="cov6" title="13">{
                        if strings.HasPrefix(lookupStr, "[") &amp;&amp; strings.HasSuffix(lookupStr, "]") </span><span class="cov3" title="4">{
                                // Parse bracket expression
                                vl.lookups[i] = Parse(lookupStr[1:len(lookupStr)-1], ss, cache)
                                canCache = false // Can't cache variable lookups with dynamic expressions
                        }</span> else<span class="cov5" title="9"> if isCommandMethod(lookupStr) </span><span class="cov3" title="3">{
                                // Mark as command method
                                vl.commandFlags |= 1 &lt;&lt; i
                        }</span>
                }
        }

        // Cache the result if it's cacheable (no dynamic parts)
        <span class="cov8" title="37">if canCache </span><span class="cov7" title="34">{
                globalVariableLookupCache.Store(markup, vl)
        }</span>

        <span class="cov8" title="37">return vl</span>
}

func isCommandMethod(method string) bool <span class="cov5" title="9">{
        for _, cmd := range variableLookupCommandMethods </span><span class="cov7" title="24">{
                if cmd == method </span><span class="cov3" title="3">{
                        return true
                }</span>
        }
        <span class="cov4" title="6">return false</span>
}

// LookupCommand returns true if the lookup at the given index is a command method.
func (vl *VariableLookup) LookupCommand(lookupIndex int) bool <span class="cov4" title="6">{
        return (vl.commandFlags &amp; (1 &lt;&lt; lookupIndex)) != 0
}</span>

// Name returns the variable name.
func (vl *VariableLookup) Name() interface{} <span class="cov2" title="2">{
        return vl.name
}</span>

// Lookups returns the lookups.
func (vl *VariableLookup) Lookups() []interface{} <span class="cov1" title="1">{
        return vl.lookups
}</span>

// Evaluate evaluates the variable lookup in the given context.
func (vl *VariableLookup) Evaluate(context *Context) interface{} <span class="cov9" title="71">{
        name := context.Evaluate(vl.name)
        obj := context.FindVariable(ToString(name, nil), false)

        for i, lookup := range vl.lookups </span><span class="cov4" title="6">{
                key := context.Evaluate(lookup)
                key = ToLiquidValue(key)

                // Try to access as map/array
                if m, ok := obj.(map[string]interface{}); ok </span><span class="cov3" title="4">{
                        if k, ok := key.(string); ok </span><span class="cov3" title="4">{
                                if val, exists := m[k]; exists </span><span class="cov3" title="4">{
                                        obj = val
                                        continue</span>
                                }
                        }
                }

                <span class="cov2" title="2">if arr, ok := obj.([]interface{}); ok </span><span class="cov1" title="1">{
                        idx, _ := ToInteger(key)
                        if idx &gt;= 0 &amp;&amp; idx &lt; len(arr) </span><span class="cov1" title="1">{
                                obj = arr[idx]
                                continue</span>
                        }
                }

                // Try command method
                <span class="cov1" title="1">if vl.LookupCommand(i) </span><span class="cov0" title="0">{
                        if _, ok := key.(string); ok </span><span class="cov0" title="0">{
                                // Try to call method on object
                                // For now, return nil
                                return nil
                        }</span>
                }

                // Try drop method invocation
                <span class="cov1" title="1">if keyStr, ok := key.(string); ok </span><span class="cov1" title="1">{
                        if IsInvokable(obj, keyStr) </span><span class="cov0" title="0">{
                                dropResult := InvokeDropOn(obj, keyStr)
                                // Even if result is nil, we found the method, so use it
                                // (nil is a valid return value)
                                obj = dropResult
                                continue</span>
                        }
                }

                // Not found
                <span class="cov1" title="1">if context.StrictVariables() </span><span class="cov0" title="0">{
                        panic(NewUndefinedVariable("undefined variable " + ToString(key, nil)))</span>
                }
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov9" title="70">return ToLiquid(obj)</span>
}

// ToString converts a value to string.
func ToString(v interface{}, ctx *Context) string <span class="cov9" title="71">{
        return ToS(v, nil)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
